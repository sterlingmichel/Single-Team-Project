{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/Users/smichel/Projects/Team-5-Project/database/packages/minimongo/local_collection.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","topLevelAwait","objectRestSpread","objectRestSpread","asyncGenerators","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"os.osx.arm64"},"sourceFileName":"packages/minimongo/local_collection.js","filename":"/Users/smichel/Projects/Team-5-Project/database/packages/minimongo/local_collection.js","targets":{},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"/Users/smichel/Projects/Team-5-Project/database","root":"/Users/smichel/Projects/Team-5-Project/database","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":false,"enforceStrictMode":false,"dynamicImport":true,"generateLetDeclarations":true,"topLevelAwait":true},"externalDependencies":[]},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"version":"7.17.2","helpers":true,"useESModules":false,"corejs":false},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-react-jsx","visitor":{"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXFragment":{"exit":[null]},"JSXElement":{"exit":[null]},"JSXAttribute":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false},"externalDependencies":[]},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-nullish-coalescing-operator","visitor":{"LogicalExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-chaining","visitor":{"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-catch-binding","visitor":{"CatchClause":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-logical-assignment-operators","visitor":{"AssignmentExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]}],"presets":[],"generatorOpts":{"filename":"/Users/smichel/Projects/Team-5-Project/database/packages/minimongo/local_collection.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/minimongo/local_collection.js"}},"code":"!module.wrapAsync(async function (module, __reifyWaitForDeps__, __reify_async_result__) {\n  \"use strict\";\n  try {\n    let _objectSpread;\n    module.link(\"@babel/runtime/helpers/objectSpread2\", {\n      default(v) {\n        _objectSpread = v;\n      }\n    }, 0);\n    module.export({\n      default: () => LocalCollection\n    });\n    let Cursor;\n    module.link(\"./cursor.js\", {\n      default(v) {\n        Cursor = v;\n      }\n    }, 0);\n    let ObserveHandle;\n    module.link(\"./observe_handle.js\", {\n      default(v) {\n        ObserveHandle = v;\n      }\n    }, 1);\n    let hasOwn, isIndexable, isNumericKey, isOperatorObject, populateDocumentWithQueryFields, projectionDetails;\n    module.link(\"./common.js\", {\n      hasOwn(v) {\n        hasOwn = v;\n      },\n      isIndexable(v) {\n        isIndexable = v;\n      },\n      isNumericKey(v) {\n        isNumericKey = v;\n      },\n      isOperatorObject(v) {\n        isOperatorObject = v;\n      },\n      populateDocumentWithQueryFields(v) {\n        populateDocumentWithQueryFields = v;\n      },\n      projectionDetails(v) {\n        projectionDetails = v;\n      }\n    }, 2);\n    let getAsyncMethodName;\n    module.link(\"./constants\", {\n      getAsyncMethodName(v) {\n        getAsyncMethodName = v;\n      }\n    }, 3);\n    if (__reifyWaitForDeps__()) (await __reifyWaitForDeps__())();\n    class LocalCollection {\n      constructor(name) {\n        this.name = name;\n        // _id -> document (also containing id)\n        this._docs = new LocalCollection._IdMap();\n        this._observeQueue = Meteor.isClient ? new Meteor._SynchronousQueue() : new Meteor._AsynchronousQueue();\n        this.next_qid = 1; // live query id generator\n\n        // qid -> live query object. keys:\n        //  ordered: bool. ordered queries have addedBefore/movedBefore callbacks.\n        //  results: array (ordered) or object (unordered) of current results\n        //    (aliased with this._docs!)\n        //  resultsSnapshot: snapshot of results. null if not paused.\n        //  cursor: Cursor object for the query.\n        //  selector, sorter, (callbacks): functions\n        this.queries = Object.create(null);\n\n        // null if not saving originals; an IdMap from id to original document value\n        // if saving originals. See comments before saveOriginals().\n        this._savedOriginals = null;\n\n        // True when observers are paused and we should not send callbacks.\n        this.paused = false;\n      }\n      countDocuments(selector, options) {\n        return this.find(selector !== null && selector !== void 0 ? selector : {}, options).countAsync();\n      }\n      estimatedDocumentCount(options) {\n        return this.find({}, options).countAsync();\n      }\n\n      // options may include sort, skip, limit, reactive\n      // sort may be any of these forms:\n      //     {a: 1, b: -1}\n      //     [[\"a\", \"asc\"], [\"b\", \"desc\"]]\n      //     [\"a\", [\"b\", \"desc\"]]\n      //   (in the first form you're beholden to key enumeration order in\n      //   your javascript VM)\n      //\n      // reactive: if given, and false, don't register with Tracker (default\n      // is true)\n      //\n      // XXX possibly should support retrieving a subset of fields? and\n      // have it be a hint (ignored on the client, when not copying the\n      // doc?)\n      //\n      // XXX sort does not yet support subkeys ('a.b') .. fix that!\n      // XXX add one more sort form: \"key\"\n      // XXX tests\n      find(selector, options) {\n        // default syntax for everything is to omit the selector argument.\n        // but if selector is explicitly passed in as false or undefined, we\n        // want a selector that matches nothing.\n        if (arguments.length === 0) {\n          selector = {};\n        }\n        return new LocalCollection.Cursor(this, selector, options);\n      }\n      findOne(selector) {\n        let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        if (arguments.length === 0) {\n          selector = {};\n        }\n\n        // NOTE: by setting limit 1 here, we end up using very inefficient\n        // code that recomputes the whole query on each update. The upside is\n        // that when you reactively depend on a findOne you only get\n        // invalidated when the found object changes, not any object in the\n        // collection. Most findOne will be by id, which has a fast path, so\n        // this might not be a big deal. In most cases, invalidation causes\n        // the called to re-query anyway, so this should be a net performance\n        // improvement.\n        options.limit = 1;\n        return this.find(selector, options).fetch()[0];\n      }\n      async findOneAsync(selector) {\n        let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        if (arguments.length === 0) {\n          selector = {};\n        }\n        options.limit = 1;\n        return (await this.find(selector, options).fetchAsync())[0];\n      }\n      prepareInsert(doc) {\n        assertHasValidFieldNames(doc);\n\n        // if you really want to use ObjectIDs, set this global.\n        // Mongo.Collection specifies its own ids and does not use this code.\n        if (!hasOwn.call(doc, '_id')) {\n          doc._id = LocalCollection._useOID ? new MongoID.ObjectID() : Random.id();\n        }\n        const id = doc._id;\n        if (this._docs.has(id)) {\n          throw MinimongoError(\"Duplicate _id '\".concat(id, \"'\"));\n        }\n        this._saveOriginal(id, undefined);\n        this._docs.set(id, doc);\n        return id;\n      }\n\n      // XXX possibly enforce that 'undefined' does not appear (we assume\n      // this in our handling of null and $exists)\n      insert(doc, callback) {\n        doc = EJSON.clone(doc);\n        const id = this.prepareInsert(doc);\n        const queriesToRecompute = [];\n\n        // trigger live queries that match\n        for (const qid of Object.keys(this.queries)) {\n          const query = this.queries[qid];\n          if (query.dirty) {\n            continue;\n          }\n          const matchResult = query.matcher.documentMatches(doc);\n          if (matchResult.result) {\n            if (query.distances && matchResult.distance !== undefined) {\n              query.distances.set(id, matchResult.distance);\n            }\n            if (query.cursor.skip || query.cursor.limit) {\n              queriesToRecompute.push(qid);\n            } else {\n              LocalCollection._insertInResultsSync(query, doc);\n            }\n          }\n        }\n        queriesToRecompute.forEach(qid => {\n          if (this.queries[qid]) {\n            this._recomputeResults(this.queries[qid]);\n          }\n        });\n        this._observeQueue.drain();\n        if (callback) {\n          Meteor.defer(() => {\n            callback(null, id);\n          });\n        }\n        return id;\n      }\n      async insertAsync(doc, callback) {\n        doc = EJSON.clone(doc);\n        const id = this.prepareInsert(doc);\n        const queriesToRecompute = [];\n\n        // trigger live queries that match\n        for (const qid of Object.keys(this.queries)) {\n          const query = this.queries[qid];\n          if (query.dirty) {\n            continue;\n          }\n          const matchResult = query.matcher.documentMatches(doc);\n          if (matchResult.result) {\n            if (query.distances && matchResult.distance !== undefined) {\n              query.distances.set(id, matchResult.distance);\n            }\n            if (query.cursor.skip || query.cursor.limit) {\n              queriesToRecompute.push(qid);\n            } else {\n              await LocalCollection._insertInResultsAsync(query, doc);\n            }\n          }\n        }\n        queriesToRecompute.forEach(qid => {\n          if (this.queries[qid]) {\n            this._recomputeResults(this.queries[qid]);\n          }\n        });\n        await this._observeQueue.drain();\n        if (callback) {\n          Meteor.defer(() => {\n            callback(null, id);\n          });\n        }\n        return id;\n      }\n\n      // Pause the observers. No callbacks from observers will fire until\n      // 'resumeObservers' is called.\n      pauseObservers() {\n        // No-op if already paused.\n        if (this.paused) {\n          return;\n        }\n\n        // Set the 'paused' flag such that new observer messages don't fire.\n        this.paused = true;\n\n        // Take a snapshot of the query results for each query.\n        Object.keys(this.queries).forEach(qid => {\n          const query = this.queries[qid];\n          query.resultsSnapshot = EJSON.clone(query.results);\n        });\n      }\n      clearResultQueries(callback) {\n        const result = this._docs.size();\n        this._docs.clear();\n        Object.keys(this.queries).forEach(qid => {\n          const query = this.queries[qid];\n          if (query.ordered) {\n            query.results = [];\n          } else {\n            query.results.clear();\n          }\n        });\n        if (callback) {\n          Meteor.defer(() => {\n            callback(null, result);\n          });\n        }\n        return result;\n      }\n      prepareRemove(selector) {\n        const matcher = new Minimongo.Matcher(selector);\n        const remove = [];\n        this._eachPossiblyMatchingDocSync(selector, (doc, id) => {\n          if (matcher.documentMatches(doc).result) {\n            remove.push(id);\n          }\n        });\n        const queriesToRecompute = [];\n        const queryRemove = [];\n        for (let i = 0; i < remove.length; i++) {\n          const removeId = remove[i];\n          const removeDoc = this._docs.get(removeId);\n          Object.keys(this.queries).forEach(qid => {\n            const query = this.queries[qid];\n            if (query.dirty) {\n              return;\n            }\n            if (query.matcher.documentMatches(removeDoc).result) {\n              if (query.cursor.skip || query.cursor.limit) {\n                queriesToRecompute.push(qid);\n              } else {\n                queryRemove.push({\n                  qid,\n                  doc: removeDoc\n                });\n              }\n            }\n          });\n          this._saveOriginal(removeId, removeDoc);\n          this._docs.remove(removeId);\n        }\n        return {\n          queriesToRecompute,\n          queryRemove,\n          remove\n        };\n      }\n      remove(selector, callback) {\n        // Easy special case: if we're not calling observeChanges callbacks and\n        // we're not saving originals and we got asked to remove everything, then\n        // just empty everything directly.\n        if (this.paused && !this._savedOriginals && EJSON.equals(selector, {})) {\n          return this.clearResultQueries(callback);\n        }\n        const {\n          queriesToRecompute,\n          queryRemove,\n          remove\n        } = this.prepareRemove(selector);\n\n        // run live query callbacks _after_ we've removed the documents.\n        queryRemove.forEach(remove => {\n          const query = this.queries[remove.qid];\n          if (query) {\n            query.distances && query.distances.remove(remove.doc._id);\n            LocalCollection._removeFromResultsSync(query, remove.doc);\n          }\n        });\n        queriesToRecompute.forEach(qid => {\n          const query = this.queries[qid];\n          if (query) {\n            this._recomputeResults(query);\n          }\n        });\n        this._observeQueue.drain();\n        const result = remove.length;\n        if (callback) {\n          Meteor.defer(() => {\n            callback(null, result);\n          });\n        }\n        return result;\n      }\n      async removeAsync(selector, callback) {\n        // Easy special case: if we're not calling observeChanges callbacks and\n        // we're not saving originals and we got asked to remove everything, then\n        // just empty everything directly.\n        if (this.paused && !this._savedOriginals && EJSON.equals(selector, {})) {\n          return this.clearResultQueries(callback);\n        }\n        const {\n          queriesToRecompute,\n          queryRemove,\n          remove\n        } = this.prepareRemove(selector);\n\n        // run live query callbacks _after_ we've removed the documents.\n        for (const remove of queryRemove) {\n          const query = this.queries[remove.qid];\n          if (query) {\n            query.distances && query.distances.remove(remove.doc._id);\n            await LocalCollection._removeFromResultsAsync(query, remove.doc);\n          }\n        }\n        queriesToRecompute.forEach(qid => {\n          const query = this.queries[qid];\n          if (query) {\n            this._recomputeResults(query);\n          }\n        });\n        await this._observeQueue.drain();\n        const result = remove.length;\n        if (callback) {\n          Meteor.defer(() => {\n            callback(null, result);\n          });\n        }\n        return result;\n      }\n\n      // Resume the observers. Observers immediately receive change\n      // notifications to bring them to the current state of the\n      // database. Note that this is not just replaying all the changes that\n      // happened during the pause, it is a smarter 'coalesced' diff.\n      _resumeObservers() {\n        // No-op if not paused.\n        if (!this.paused) {\n          return;\n        }\n\n        // Unset the 'paused' flag. Make sure to do this first, otherwise\n        // observer methods won't actually fire when we trigger them.\n        this.paused = false;\n        Object.keys(this.queries).forEach(qid => {\n          const query = this.queries[qid];\n          if (query.dirty) {\n            query.dirty = false;\n\n            // re-compute results will perform `LocalCollection._diffQueryChanges`\n            // automatically.\n            this._recomputeResults(query, query.resultsSnapshot);\n          } else {\n            // Diff the current results against the snapshot and send to observers.\n            // pass the query object for its observer callbacks.\n            LocalCollection._diffQueryChanges(query.ordered, query.resultsSnapshot, query.results, query, {\n              projectionFn: query.projectionFn\n            });\n          }\n          query.resultsSnapshot = null;\n        });\n      }\n      async resumeObserversServer() {\n        this._resumeObservers();\n        await this._observeQueue.drain();\n      }\n      resumeObserversClient() {\n        this._resumeObservers();\n        this._observeQueue.drain();\n      }\n      retrieveOriginals() {\n        if (!this._savedOriginals) {\n          throw new Error('Called retrieveOriginals without saveOriginals');\n        }\n        const originals = this._savedOriginals;\n        this._savedOriginals = null;\n        return originals;\n      }\n\n      // To track what documents are affected by a piece of code, call\n      // saveOriginals() before it and retrieveOriginals() after it.\n      // retrieveOriginals returns an object whose keys are the ids of the documents\n      // that were affected since the call to saveOriginals(), and the values are\n      // equal to the document's contents at the time of saveOriginals. (In the case\n      // of an inserted document, undefined is the value.) You must alternate\n      // between calls to saveOriginals() and retrieveOriginals().\n      saveOriginals() {\n        if (this._savedOriginals) {\n          throw new Error('Called saveOriginals twice without retrieveOriginals');\n        }\n        this._savedOriginals = new LocalCollection._IdMap();\n      }\n      prepareUpdate(selector) {\n        // Save the original results of any query that we might need to\n        // _recomputeResults on, because _modifyAndNotify will mutate the objects in\n        // it. (We don't need to save the original results of paused queries because\n        // they already have a resultsSnapshot and we won't be diffing in\n        // _recomputeResults.)\n        const qidToOriginalResults = {};\n\n        // We should only clone each document once, even if it appears in multiple\n        // queries\n        const docMap = new LocalCollection._IdMap();\n        const idsMatched = LocalCollection._idsMatchedBySelector(selector);\n        Object.keys(this.queries).forEach(qid => {\n          const query = this.queries[qid];\n          if ((query.cursor.skip || query.cursor.limit) && !this.paused) {\n            // Catch the case of a reactive `count()` on a cursor with skip\n            // or limit, which registers an unordered observe. This is a\n            // pretty rare case, so we just clone the entire result set with\n            // no optimizations for documents that appear in these result\n            // sets and other queries.\n            if (query.results instanceof LocalCollection._IdMap) {\n              qidToOriginalResults[qid] = query.results.clone();\n              return;\n            }\n            if (!(query.results instanceof Array)) {\n              throw new Error('Assertion failed: query.results not an array');\n            }\n\n            // Clones a document to be stored in `qidToOriginalResults`\n            // because it may be modified before the new and old result sets\n            // are diffed. But if we know exactly which document IDs we're\n            // going to modify, then we only need to clone those.\n            const memoizedCloneIfNeeded = doc => {\n              if (docMap.has(doc._id)) {\n                return docMap.get(doc._id);\n              }\n              const docToMemoize = idsMatched && !idsMatched.some(id => EJSON.equals(id, doc._id)) ? doc : EJSON.clone(doc);\n              docMap.set(doc._id, docToMemoize);\n              return docToMemoize;\n            };\n            qidToOriginalResults[qid] = query.results.map(memoizedCloneIfNeeded);\n          }\n        });\n        return qidToOriginalResults;\n      }\n      finishUpdate(_ref) {\n        let {\n          options,\n          updateCount,\n          callback,\n          insertedId\n        } = _ref;\n        // Return the number of affected documents, or in the upsert case, an object\n        // containing the number of affected docs and the id of the doc that was\n        // inserted, if any.\n        let result;\n        if (options._returnObject) {\n          result = {\n            numberAffected: updateCount\n          };\n          if (insertedId !== undefined) {\n            result.insertedId = insertedId;\n          }\n        } else {\n          result = updateCount;\n        }\n        if (callback) {\n          Meteor.defer(() => {\n            callback(null, result);\n          });\n        }\n        return result;\n      }\n\n      // XXX atomicity: if multi is true, and one modification fails, do\n      // we rollback the whole operation, or what?\n      async updateAsync(selector, mod, options, callback) {\n        if (!callback && options instanceof Function) {\n          callback = options;\n          options = null;\n        }\n        if (!options) {\n          options = {};\n        }\n        const matcher = new Minimongo.Matcher(selector, true);\n        const qidToOriginalResults = this.prepareUpdate(selector);\n        let recomputeQids = {};\n        let updateCount = 0;\n        await this._eachPossiblyMatchingDocAsync(selector, async (doc, id) => {\n          const queryResult = matcher.documentMatches(doc);\n          if (queryResult.result) {\n            // XXX Should we save the original even if mod ends up being a no-op?\n            this._saveOriginal(id, doc);\n            recomputeQids = await this._modifyAndNotifyAsync(doc, mod, queryResult.arrayIndices);\n            ++updateCount;\n            if (!options.multi) {\n              return false; // break\n            }\n          }\n          return true;\n        });\n        Object.keys(recomputeQids).forEach(qid => {\n          const query = this.queries[qid];\n          if (query) {\n            this._recomputeResults(query, qidToOriginalResults[qid]);\n          }\n        });\n        await this._observeQueue.drain();\n\n        // If we are doing an upsert, and we didn't modify any documents yet, then\n        // it's time to do an insert. Figure out what document we are inserting, and\n        // generate an id for it.\n        let insertedId;\n        if (updateCount === 0 && options.upsert) {\n          const doc = LocalCollection._createUpsertDocument(selector, mod);\n          if (!doc._id && options.insertedId) {\n            doc._id = options.insertedId;\n          }\n          insertedId = await this.insertAsync(doc);\n          updateCount = 1;\n        }\n        return this.finishUpdate({\n          options,\n          insertedId,\n          updateCount,\n          callback\n        });\n      }\n      // XXX atomicity: if multi is true, and one modification fails, do\n      // we rollback the whole operation, or what?\n      update(selector, mod, options, callback) {\n        if (!callback && options instanceof Function) {\n          callback = options;\n          options = null;\n        }\n        if (!options) {\n          options = {};\n        }\n        const matcher = new Minimongo.Matcher(selector, true);\n        const qidToOriginalResults = this.prepareUpdate(selector);\n        let recomputeQids = {};\n        let updateCount = 0;\n        this._eachPossiblyMatchingDocSync(selector, (doc, id) => {\n          const queryResult = matcher.documentMatches(doc);\n          if (queryResult.result) {\n            // XXX Should we save the original even if mod ends up being a no-op?\n            this._saveOriginal(id, doc);\n            recomputeQids = this._modifyAndNotifySync(doc, mod, queryResult.arrayIndices);\n            ++updateCount;\n            if (!options.multi) {\n              return false; // break\n            }\n          }\n          return true;\n        });\n        Object.keys(recomputeQids).forEach(qid => {\n          const query = this.queries[qid];\n          if (query) {\n            this._recomputeResults(query, qidToOriginalResults[qid]);\n          }\n        });\n        this._observeQueue.drain();\n\n        // If we are doing an upsert, and we didn't modify any documents yet, then\n        // it's time to do an insert. Figure out what document we are inserting, and\n        // generate an id for it.\n        let insertedId;\n        if (updateCount === 0 && options.upsert) {\n          const doc = LocalCollection._createUpsertDocument(selector, mod);\n          if (!doc._id && options.insertedId) {\n            doc._id = options.insertedId;\n          }\n          insertedId = this.insert(doc);\n          updateCount = 1;\n        }\n        return this.finishUpdate({\n          options,\n          updateCount,\n          callback,\n          selector,\n          mod\n        });\n      }\n\n      // A convenience wrapper on update. LocalCollection.upsert(sel, mod) is\n      // equivalent to LocalCollection.update(sel, mod, {upsert: true,\n      // _returnObject: true}).\n      upsert(selector, mod, options, callback) {\n        if (!callback && typeof options === 'function') {\n          callback = options;\n          options = {};\n        }\n        return this.update(selector, mod, Object.assign({}, options, {\n          upsert: true,\n          _returnObject: true\n        }), callback);\n      }\n      upsertAsync(selector, mod, options, callback) {\n        if (!callback && typeof options === 'function') {\n          callback = options;\n          options = {};\n        }\n        return this.updateAsync(selector, mod, Object.assign({}, options, {\n          upsert: true,\n          _returnObject: true\n        }), callback);\n      }\n\n      // Iterates over a subset of documents that could match selector; calls\n      // fn(doc, id) on each of them.  Specifically, if selector specifies\n      // specific _id's, it only looks at those.  doc is *not* cloned: it is the\n      // same object that is in _docs.\n      async _eachPossiblyMatchingDocAsync(selector, fn) {\n        const specificIds = LocalCollection._idsMatchedBySelector(selector);\n        if (specificIds) {\n          for (const id of specificIds) {\n            const doc = this._docs.get(id);\n            if (doc && !(await fn(doc, id))) {\n              break;\n            }\n          }\n        } else {\n          await this._docs.forEachAsync(fn);\n        }\n      }\n      _eachPossiblyMatchingDocSync(selector, fn) {\n        const specificIds = LocalCollection._idsMatchedBySelector(selector);\n        if (specificIds) {\n          for (const id of specificIds) {\n            const doc = this._docs.get(id);\n            if (doc && !fn(doc, id)) {\n              break;\n            }\n          }\n        } else {\n          this._docs.forEach(fn);\n        }\n      }\n      _getMatchedDocAndModify(doc, mod, arrayIndices) {\n        const matched_before = {};\n        Object.keys(this.queries).forEach(qid => {\n          const query = this.queries[qid];\n          if (query.dirty) {\n            return;\n          }\n          if (query.ordered) {\n            matched_before[qid] = query.matcher.documentMatches(doc).result;\n          } else {\n            // Because we don't support skip or limit (yet) in unordered queries, we\n            // can just do a direct lookup.\n            matched_before[qid] = query.results.has(doc._id);\n          }\n        });\n        return matched_before;\n      }\n      _modifyAndNotifySync(doc, mod, arrayIndices) {\n        const matched_before = this._getMatchedDocAndModify(doc, mod, arrayIndices);\n        const old_doc = EJSON.clone(doc);\n        LocalCollection._modify(doc, mod, {\n          arrayIndices\n        });\n        const recomputeQids = {};\n        for (const qid of Object.keys(this.queries)) {\n          const query = this.queries[qid];\n          if (query.dirty) {\n            continue;\n          }\n          const afterMatch = query.matcher.documentMatches(doc);\n          const after = afterMatch.result;\n          const before = matched_before[qid];\n          if (after && query.distances && afterMatch.distance !== undefined) {\n            query.distances.set(doc._id, afterMatch.distance);\n          }\n          if (query.cursor.skip || query.cursor.limit) {\n            // We need to recompute any query where the doc may have been in the\n            // cursor's window either before or after the update. (Note that if skip\n            // or limit is set, \"before\" and \"after\" being true do not necessarily\n            // mean that the document is in the cursor's output after skip/limit is\n            // applied... but if they are false, then the document definitely is NOT\n            // in the output. So it's safe to skip recompute if neither before or\n            // after are true.)\n            if (before || after) {\n              recomputeQids[qid] = true;\n            }\n          } else if (before && !after) {\n            LocalCollection._removeFromResultsSync(query, doc);\n          } else if (!before && after) {\n            LocalCollection._insertInResultsSync(query, doc);\n          } else if (before && after) {\n            LocalCollection._updateInResultsSync(query, doc, old_doc);\n          }\n        }\n        return recomputeQids;\n      }\n      async _modifyAndNotifyAsync(doc, mod, arrayIndices) {\n        const matched_before = this._getMatchedDocAndModify(doc, mod, arrayIndices);\n        const old_doc = EJSON.clone(doc);\n        LocalCollection._modify(doc, mod, {\n          arrayIndices\n        });\n        const recomputeQids = {};\n        for (const qid of Object.keys(this.queries)) {\n          const query = this.queries[qid];\n          if (query.dirty) {\n            continue;\n          }\n          const afterMatch = query.matcher.documentMatches(doc);\n          const after = afterMatch.result;\n          const before = matched_before[qid];\n          if (after && query.distances && afterMatch.distance !== undefined) {\n            query.distances.set(doc._id, afterMatch.distance);\n          }\n          if (query.cursor.skip || query.cursor.limit) {\n            // We need to recompute any query where the doc may have been in the\n            // cursor's window either before or after the update. (Note that if skip\n            // or limit is set, \"before\" and \"after\" being true do not necessarily\n            // mean that the document is in the cursor's output after skip/limit is\n            // applied... but if they are false, then the document definitely is NOT\n            // in the output. So it's safe to skip recompute if neither before or\n            // after are true.)\n            if (before || after) {\n              recomputeQids[qid] = true;\n            }\n          } else if (before && !after) {\n            await LocalCollection._removeFromResultsAsync(query, doc);\n          } else if (!before && after) {\n            await LocalCollection._insertInResultsAsync(query, doc);\n          } else if (before && after) {\n            await LocalCollection._updateInResultsAsync(query, doc, old_doc);\n          }\n        }\n        return recomputeQids;\n      }\n\n      // Recomputes the results of a query and runs observe callbacks for the\n      // difference between the previous results and the current results (unless\n      // paused). Used for skip/limit queries.\n      //\n      // When this is used by insert or remove, it can just use query.results for\n      // the old results (and there's no need to pass in oldResults), because these\n      // operations don't mutate the documents in the collection. Update needs to\n      // pass in an oldResults which was deep-copied before the modifier was\n      // applied.\n      //\n      // oldResults is guaranteed to be ignored if the query is not paused.\n      _recomputeResults(query, oldResults) {\n        if (this.paused) {\n          // There's no reason to recompute the results now as we're still paused.\n          // By flagging the query as \"dirty\", the recompute will be performed\n          // when resumeObservers is called.\n          query.dirty = true;\n          return;\n        }\n        if (!this.paused && !oldResults) {\n          oldResults = query.results;\n        }\n        if (query.distances) {\n          query.distances.clear();\n        }\n        query.results = query.cursor._getRawObjects({\n          distances: query.distances,\n          ordered: query.ordered\n        });\n        if (!this.paused) {\n          LocalCollection._diffQueryChanges(query.ordered, oldResults, query.results, query, {\n            projectionFn: query.projectionFn\n          });\n        }\n      }\n      _saveOriginal(id, doc) {\n        // Are we even trying to save originals?\n        if (!this._savedOriginals) {\n          return;\n        }\n\n        // Have we previously mutated the original (and so 'doc' is not actually\n        // original)?  (Note the 'has' check rather than truth: we store undefined\n        // here for inserted docs!)\n        if (this._savedOriginals.has(id)) {\n          return;\n        }\n        this._savedOriginals.set(id, EJSON.clone(doc));\n      }\n    }\n    LocalCollection.Cursor = Cursor;\n    LocalCollection.ObserveHandle = ObserveHandle;\n\n    // XXX maybe move these into another ObserveHelpers package or something\n\n    // _CachingChangeObserver is an object which receives observeChanges callbacks\n    // and keeps a cache of the current cursor state up to date in this.docs. Users\n    // of this class should read the docs field but not modify it. You should pass\n    // the \"applyChange\" field as the callbacks to the underlying observeChanges\n    // call. Optionally, you can specify your own observeChanges callbacks which are\n    // invoked immediately before the docs field is updated; this object is made\n    // available as `this` to those callbacks.\n    LocalCollection._CachingChangeObserver = class _CachingChangeObserver {\n      constructor() {\n        let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        const orderedFromCallbacks = options.callbacks && LocalCollection._observeChangesCallbacksAreOrdered(options.callbacks);\n        if (hasOwn.call(options, 'ordered')) {\n          this.ordered = options.ordered;\n          if (options.callbacks && options.ordered !== orderedFromCallbacks) {\n            throw Error('ordered option doesn\\'t match callbacks');\n          }\n        } else if (options.callbacks) {\n          this.ordered = orderedFromCallbacks;\n        } else {\n          throw Error('must provide ordered or callbacks');\n        }\n        const callbacks = options.callbacks || {};\n        if (this.ordered) {\n          this.docs = new OrderedDict(MongoID.idStringify);\n          this.applyChange = {\n            addedBefore: (id, fields, before) => {\n              // Take a shallow copy since the top-level properties can be changed\n              const doc = _objectSpread({}, fields);\n              doc._id = id;\n              if (callbacks.addedBefore) {\n                callbacks.addedBefore.call(this, id, EJSON.clone(fields), before);\n              }\n\n              // This line triggers if we provide added with movedBefore.\n              if (callbacks.added) {\n                callbacks.added.call(this, id, EJSON.clone(fields));\n              }\n\n              // XXX could `before` be a falsy ID?  Technically\n              // idStringify seems to allow for them -- though\n              // OrderedDict won't call stringify on a falsy arg.\n              this.docs.putBefore(id, doc, before || null);\n            },\n            movedBefore: (id, before) => {\n              if (callbacks.movedBefore) {\n                callbacks.movedBefore.call(this, id, before);\n              }\n              this.docs.moveBefore(id, before || null);\n            }\n          };\n        } else {\n          this.docs = new LocalCollection._IdMap();\n          this.applyChange = {\n            added: (id, fields) => {\n              // Take a shallow copy since the top-level properties can be changed\n              const doc = _objectSpread({}, fields);\n              if (callbacks.added) {\n                callbacks.added.call(this, id, EJSON.clone(fields));\n              }\n              doc._id = id;\n              this.docs.set(id, doc);\n            }\n          };\n        }\n\n        // The methods in _IdMap and OrderedDict used by these callbacks are\n        // identical.\n        this.applyChange.changed = (id, fields) => {\n          const doc = this.docs.get(id);\n          if (!doc) {\n            throw new Error(\"Unknown id for changed: \".concat(id));\n          }\n          if (callbacks.changed) {\n            callbacks.changed.call(this, id, EJSON.clone(fields));\n          }\n          DiffSequence.applyChanges(doc, fields);\n        };\n        this.applyChange.removed = id => {\n          if (callbacks.removed) {\n            callbacks.removed.call(this, id);\n          }\n          this.docs.remove(id);\n        };\n      }\n    };\n    LocalCollection._IdMap = class _IdMap extends IdMap {\n      constructor() {\n        super(MongoID.idStringify, MongoID.idParse);\n      }\n    };\n\n    // Wrap a transform function to return objects that have the _id field\n    // of the untransformed document. This ensures that subsystems such as\n    // the observe-sequence package that call `observe` can keep track of\n    // the documents identities.\n    //\n    // - Require that it returns objects\n    // - If the return value has an _id field, verify that it matches the\n    //   original _id field\n    // - If the return value doesn't have an _id field, add it back.\n    LocalCollection.wrapTransform = transform => {\n      if (!transform) {\n        return null;\n      }\n\n      // No need to doubly-wrap transforms.\n      if (transform.__wrappedTransform__) {\n        return transform;\n      }\n      const wrapped = doc => {\n        if (!hasOwn.call(doc, '_id')) {\n          // XXX do we ever have a transform on the oplog's collection? because that\n          // collection has no _id.\n          throw new Error('can only transform documents with _id');\n        }\n        const id = doc._id;\n\n        // XXX consider making tracker a weak dependency and checking\n        // Package.tracker here\n        const transformed = Tracker.nonreactive(() => transform(doc));\n        if (!LocalCollection._isPlainObject(transformed)) {\n          throw new Error('transform must return object');\n        }\n        if (hasOwn.call(transformed, '_id')) {\n          if (!EJSON.equals(transformed._id, id)) {\n            throw new Error('transformed document can\\'t have different _id');\n          }\n        } else {\n          transformed._id = id;\n        }\n        return transformed;\n      };\n      wrapped.__wrappedTransform__ = true;\n      return wrapped;\n    };\n\n    // XXX the sorted-query logic below is laughably inefficient. we'll\n    // need to come up with a better datastructure for this.\n    //\n    // XXX the logic for observing with a skip or a limit is even more\n    // laughably inefficient. we recompute the whole results every time!\n\n    // This binary search puts a value between any equal values, and the first\n    // lesser value.\n    LocalCollection._binarySearch = (cmp, array, value) => {\n      let first = 0;\n      let range = array.length;\n      while (range > 0) {\n        const halfRange = Math.floor(range / 2);\n        if (cmp(value, array[first + halfRange]) >= 0) {\n          first += halfRange + 1;\n          range -= halfRange + 1;\n        } else {\n          range = halfRange;\n        }\n      }\n      return first;\n    };\n    LocalCollection._checkSupportedProjection = fields => {\n      if (fields !== Object(fields) || Array.isArray(fields)) {\n        throw MinimongoError('fields option must be an object');\n      }\n      Object.keys(fields).forEach(keyPath => {\n        if (keyPath.split('.').includes('$')) {\n          throw MinimongoError('Minimongo doesn\\'t support $ operator in projections yet.');\n        }\n        const value = fields[keyPath];\n        if (typeof value === 'object' && ['$elemMatch', '$meta', '$slice'].some(key => hasOwn.call(value, key))) {\n          throw MinimongoError('Minimongo doesn\\'t support operators in projections yet.');\n        }\n        if (![1, 0, true, false].includes(value)) {\n          throw MinimongoError('Projection values should be one of 1, 0, true, or false');\n        }\n      });\n    };\n\n    // Knows how to compile a fields projection to a predicate function.\n    // @returns - Function: a closure that filters out an object according to the\n    //            fields projection rules:\n    //            @param obj - Object: MongoDB-styled document\n    //            @returns - Object: a document with the fields filtered out\n    //                       according to projection rules. Doesn't retain subfields\n    //                       of passed argument.\n    LocalCollection._compileProjection = fields => {\n      LocalCollection._checkSupportedProjection(fields);\n      const _idProjection = fields._id === undefined ? true : fields._id;\n      const details = projectionDetails(fields);\n\n      // returns transformed doc according to ruleTree\n      const transform = (doc, ruleTree) => {\n        // Special case for \"sets\"\n        if (Array.isArray(doc)) {\n          return doc.map(subdoc => transform(subdoc, ruleTree));\n        }\n        const result = details.including ? {} : EJSON.clone(doc);\n        Object.keys(ruleTree).forEach(key => {\n          if (doc == null || !hasOwn.call(doc, key)) {\n            return;\n          }\n          const rule = ruleTree[key];\n          if (rule === Object(rule)) {\n            // For sub-objects/subsets we branch\n            if (doc[key] === Object(doc[key])) {\n              result[key] = transform(doc[key], rule);\n            }\n          } else if (details.including) {\n            // Otherwise we don't even touch this subfield\n            result[key] = EJSON.clone(doc[key]);\n          } else {\n            delete result[key];\n          }\n        });\n        return doc != null ? result : doc;\n      };\n      return doc => {\n        const result = transform(doc, details.tree);\n        if (_idProjection && hasOwn.call(doc, '_id')) {\n          result._id = doc._id;\n        }\n        if (!_idProjection && hasOwn.call(result, '_id')) {\n          delete result._id;\n        }\n        return result;\n      };\n    };\n\n    // Calculates the document to insert in case we're doing an upsert and the\n    // selector does not match any elements\n    LocalCollection._createUpsertDocument = (selector, modifier) => {\n      const selectorDocument = populateDocumentWithQueryFields(selector);\n      const isModify = LocalCollection._isModificationMod(modifier);\n      const newDoc = {};\n      if (selectorDocument._id) {\n        newDoc._id = selectorDocument._id;\n        delete selectorDocument._id;\n      }\n\n      // This double _modify call is made to help with nested properties (see issue\n      // #8631). We do this even if it's a replacement for validation purposes (e.g.\n      // ambiguous id's)\n      LocalCollection._modify(newDoc, {\n        $set: selectorDocument\n      });\n      LocalCollection._modify(newDoc, modifier, {\n        isInsert: true\n      });\n      if (isModify) {\n        return newDoc;\n      }\n\n      // Replacement can take _id from query document\n      const replacement = Object.assign({}, modifier);\n      if (newDoc._id) {\n        replacement._id = newDoc._id;\n      }\n      return replacement;\n    };\n    LocalCollection._diffObjects = (left, right, callbacks) => {\n      return DiffSequence.diffObjects(left, right, callbacks);\n    };\n\n    // ordered: bool.\n    // old_results and new_results: collections of documents.\n    //    if ordered, they are arrays.\n    //    if unordered, they are IdMaps\n    LocalCollection._diffQueryChanges = (ordered, oldResults, newResults, observer, options) => DiffSequence.diffQueryChanges(ordered, oldResults, newResults, observer, options);\n    LocalCollection._diffQueryOrderedChanges = (oldResults, newResults, observer, options) => DiffSequence.diffQueryOrderedChanges(oldResults, newResults, observer, options);\n    LocalCollection._diffQueryUnorderedChanges = (oldResults, newResults, observer, options) => DiffSequence.diffQueryUnorderedChanges(oldResults, newResults, observer, options);\n    LocalCollection._findInOrderedResults = (query, doc) => {\n      if (!query.ordered) {\n        throw new Error('Can\\'t call _findInOrderedResults on unordered query');\n      }\n      for (let i = 0; i < query.results.length; i++) {\n        if (query.results[i] === doc) {\n          return i;\n        }\n      }\n      throw Error('object missing from query');\n    };\n\n    // If this is a selector which explicitly constrains the match by ID to a finite\n    // number of documents, returns a list of their IDs.  Otherwise returns\n    // null. Note that the selector may have other restrictions so it may not even\n    // match those document!  We care about $in and $and since those are generated\n    // access-controlled update and remove.\n    LocalCollection._idsMatchedBySelector = selector => {\n      // Is the selector just an ID?\n      if (LocalCollection._selectorIsId(selector)) {\n        return [selector];\n      }\n      if (!selector) {\n        return null;\n      }\n\n      // Do we have an _id clause?\n      if (hasOwn.call(selector, '_id')) {\n        // Is the _id clause just an ID?\n        if (LocalCollection._selectorIsId(selector._id)) {\n          return [selector._id];\n        }\n\n        // Is the _id clause {_id: {$in: [\"x\", \"y\", \"z\"]}}?\n        if (selector._id && Array.isArray(selector._id.$in) && selector._id.$in.length && selector._id.$in.every(LocalCollection._selectorIsId)) {\n          return selector._id.$in;\n        }\n        return null;\n      }\n\n      // If this is a top-level $and, and any of the clauses constrain their\n      // documents, then the whole selector is constrained by any one clause's\n      // constraint. (Well, by their intersection, but that seems unlikely.)\n      if (Array.isArray(selector.$and)) {\n        for (let i = 0; i < selector.$and.length; ++i) {\n          const subIds = LocalCollection._idsMatchedBySelector(selector.$and[i]);\n          if (subIds) {\n            return subIds;\n          }\n        }\n      }\n      return null;\n    };\n    LocalCollection._insertInResultsSync = (query, doc) => {\n      const fields = EJSON.clone(doc);\n      delete fields._id;\n      if (query.ordered) {\n        if (!query.sorter) {\n          query.addedBefore(doc._id, query.projectionFn(fields), null);\n          query.results.push(doc);\n        } else {\n          const i = LocalCollection._insertInSortedList(query.sorter.getComparator({\n            distances: query.distances\n          }), query.results, doc);\n          let next = query.results[i + 1];\n          if (next) {\n            next = next._id;\n          } else {\n            next = null;\n          }\n          query.addedBefore(doc._id, query.projectionFn(fields), next);\n        }\n        query.added(doc._id, query.projectionFn(fields));\n      } else {\n        query.added(doc._id, query.projectionFn(fields));\n        query.results.set(doc._id, doc);\n      }\n    };\n    LocalCollection._insertInResultsAsync = async (query, doc) => {\n      const fields = EJSON.clone(doc);\n      delete fields._id;\n      if (query.ordered) {\n        if (!query.sorter) {\n          await query.addedBefore(doc._id, query.projectionFn(fields), null);\n          query.results.push(doc);\n        } else {\n          const i = LocalCollection._insertInSortedList(query.sorter.getComparator({\n            distances: query.distances\n          }), query.results, doc);\n          let next = query.results[i + 1];\n          if (next) {\n            next = next._id;\n          } else {\n            next = null;\n          }\n          await query.addedBefore(doc._id, query.projectionFn(fields), next);\n        }\n        await query.added(doc._id, query.projectionFn(fields));\n      } else {\n        await query.added(doc._id, query.projectionFn(fields));\n        query.results.set(doc._id, doc);\n      }\n    };\n    LocalCollection._insertInSortedList = (cmp, array, value) => {\n      if (array.length === 0) {\n        array.push(value);\n        return 0;\n      }\n      const i = LocalCollection._binarySearch(cmp, array, value);\n      array.splice(i, 0, value);\n      return i;\n    };\n    LocalCollection._isModificationMod = mod => {\n      let isModify = false;\n      let isReplace = false;\n      Object.keys(mod).forEach(key => {\n        if (key.substr(0, 1) === '$') {\n          isModify = true;\n        } else {\n          isReplace = true;\n        }\n      });\n      if (isModify && isReplace) {\n        throw new Error('Update parameter cannot have both modifier and non-modifier fields.');\n      }\n      return isModify;\n    };\n\n    // XXX maybe this should be EJSON.isObject, though EJSON doesn't know about\n    // RegExp\n    // XXX note that _type(undefined) === 3!!!!\n    LocalCollection._isPlainObject = x => {\n      return x && LocalCollection._f._type(x) === 3;\n    };\n\n    // XXX need a strategy for passing the binding of $ into this\n    // function, from the compiled selector\n    //\n    // maybe just {key.up.to.just.before.dollarsign: array_index}\n    //\n    // XXX atomicity: if one modification fails, do we roll back the whole\n    // change?\n    //\n    // options:\n    //   - isInsert is set when _modify is being called to compute the document to\n    //     insert as part of an upsert operation. We use this primarily to figure\n    //     out when to set the fields in $setOnInsert, if present.\n    LocalCollection._modify = function (doc, modifier) {\n      let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      if (!LocalCollection._isPlainObject(modifier)) {\n        throw MinimongoError('Modifier must be an object');\n      }\n\n      // Make sure the caller can't mutate our data structures.\n      modifier = EJSON.clone(modifier);\n      const isModifier = isOperatorObject(modifier);\n      const newDoc = isModifier ? EJSON.clone(doc) : modifier;\n      if (isModifier) {\n        // apply modifiers to the doc.\n        Object.keys(modifier).forEach(operator => {\n          // Treat $setOnInsert as $set if this is an insert.\n          const setOnInsert = options.isInsert && operator === '$setOnInsert';\n          const modFunc = MODIFIERS[setOnInsert ? '$set' : operator];\n          const operand = modifier[operator];\n          if (!modFunc) {\n            throw MinimongoError(\"Invalid modifier specified \".concat(operator));\n          }\n          Object.keys(operand).forEach(keypath => {\n            const arg = operand[keypath];\n            if (keypath === '') {\n              throw MinimongoError('An empty update path is not valid.');\n            }\n            const keyparts = keypath.split('.');\n            if (!keyparts.every(Boolean)) {\n              throw MinimongoError(\"The update path '\".concat(keypath, \"' contains an empty field name, \") + 'which is not allowed.');\n            }\n            const target = findModTarget(newDoc, keyparts, {\n              arrayIndices: options.arrayIndices,\n              forbidArray: operator === '$rename',\n              noCreate: NO_CREATE_MODIFIERS[operator]\n            });\n            modFunc(target, keyparts.pop(), arg, keypath, newDoc);\n          });\n        });\n        if (doc._id && !EJSON.equals(doc._id, newDoc._id)) {\n          throw MinimongoError(\"After applying the update to the document {_id: \\\"\".concat(doc._id, \"\\\", ...},\") + ' the (immutable) field \\'_id\\' was found to have been altered to ' + \"_id: \\\"\".concat(newDoc._id, \"\\\"\"));\n        }\n      } else {\n        if (doc._id && modifier._id && !EJSON.equals(doc._id, modifier._id)) {\n          throw MinimongoError(\"The _id field cannot be changed from {_id: \\\"\".concat(doc._id, \"\\\"} to \") + \"{_id: \\\"\".concat(modifier._id, \"\\\"}\"));\n        }\n\n        // replace the whole document\n        assertHasValidFieldNames(modifier);\n      }\n\n      // move new document into place.\n      Object.keys(doc).forEach(key => {\n        // Note: this used to be for (var key in doc) however, this does not\n        // work right in Opera. Deleting from a doc while iterating over it\n        // would sometimes cause opera to skip some keys.\n        if (key !== '_id') {\n          delete doc[key];\n        }\n      });\n      Object.keys(newDoc).forEach(key => {\n        doc[key] = newDoc[key];\n      });\n    };\n    LocalCollection._observeFromObserveChanges = (cursor, observeCallbacks) => {\n      const transform = cursor.getTransform() || (doc => doc);\n      let suppressed = !!observeCallbacks._suppress_initial;\n      let observeChangesCallbacks;\n      if (LocalCollection._observeCallbacksAreOrdered(observeCallbacks)) {\n        // The \"_no_indices\" option sets all index arguments to -1 and skips the\n        // linear scans required to generate them.  This lets observers that don't\n        // need absolute indices benefit from the other features of this API --\n        // relative order, transforms, and applyChanges -- without the speed hit.\n        const indices = !observeCallbacks._no_indices;\n        observeChangesCallbacks = {\n          addedBefore(id, fields, before) {\n            const check = suppressed || !(observeCallbacks.addedAt || observeCallbacks.added);\n            if (check) {\n              return;\n            }\n            const doc = transform(Object.assign(fields, {\n              _id: id\n            }));\n            if (observeCallbacks.addedAt) {\n              observeCallbacks.addedAt(doc, indices ? before ? this.docs.indexOf(before) : this.docs.size() : -1, before);\n            } else {\n              observeCallbacks.added(doc);\n            }\n          },\n          changed(id, fields) {\n            if (!(observeCallbacks.changedAt || observeCallbacks.changed)) {\n              return;\n            }\n            let doc = EJSON.clone(this.docs.get(id));\n            if (!doc) {\n              throw new Error(\"Unknown id for changed: \".concat(id));\n            }\n            const oldDoc = transform(EJSON.clone(doc));\n            DiffSequence.applyChanges(doc, fields);\n            if (observeCallbacks.changedAt) {\n              observeCallbacks.changedAt(transform(doc), oldDoc, indices ? this.docs.indexOf(id) : -1);\n            } else {\n              observeCallbacks.changed(transform(doc), oldDoc);\n            }\n          },\n          movedBefore(id, before) {\n            if (!observeCallbacks.movedTo) {\n              return;\n            }\n            const from = indices ? this.docs.indexOf(id) : -1;\n            let to = indices ? before ? this.docs.indexOf(before) : this.docs.size() : -1;\n\n            // When not moving backwards, adjust for the fact that removing the\n            // document slides everything back one slot.\n            if (to > from) {\n              --to;\n            }\n            observeCallbacks.movedTo(transform(EJSON.clone(this.docs.get(id))), from, to, before || null);\n          },\n          removed(id) {\n            if (!(observeCallbacks.removedAt || observeCallbacks.removed)) {\n              return;\n            }\n\n            // technically maybe there should be an EJSON.clone here, but it's about\n            // to be removed from this.docs!\n            const doc = transform(this.docs.get(id));\n            if (observeCallbacks.removedAt) {\n              observeCallbacks.removedAt(doc, indices ? this.docs.indexOf(id) : -1);\n            } else {\n              observeCallbacks.removed(doc);\n            }\n          }\n        };\n      } else {\n        observeChangesCallbacks = {\n          added(id, fields) {\n            if (!suppressed && observeCallbacks.added) {\n              observeCallbacks.added(transform(Object.assign(fields, {\n                _id: id\n              })));\n            }\n          },\n          changed(id, fields) {\n            if (observeCallbacks.changed) {\n              const oldDoc = this.docs.get(id);\n              const doc = EJSON.clone(oldDoc);\n              DiffSequence.applyChanges(doc, fields);\n              observeCallbacks.changed(transform(doc), transform(EJSON.clone(oldDoc)));\n            }\n          },\n          removed(id) {\n            if (observeCallbacks.removed) {\n              observeCallbacks.removed(transform(this.docs.get(id)));\n            }\n          }\n        };\n      }\n      const changeObserver = new LocalCollection._CachingChangeObserver({\n        callbacks: observeChangesCallbacks\n      });\n\n      // CachingChangeObserver clones all received input on its callbacks\n      // So we can mark it as safe to reduce the ejson clones.\n      // This is tested by the `mongo-livedata - (extended) scribbling` tests\n      changeObserver.applyChange._fromObserve = true;\n      const handle = cursor.observeChanges(changeObserver.applyChange, {\n        nonMutatingCallbacks: true\n      });\n\n      // If needed, re-enable callbacks as soon as the initial batch is ready.\n      const setSuppressed = h => {\n        var _h$isReadyPromise;\n        if (h.isReady) suppressed = false;else (_h$isReadyPromise = h.isReadyPromise) === null || _h$isReadyPromise === void 0 ? void 0 : _h$isReadyPromise.then(() => suppressed = false);\n      };\n      // When we call cursor.observeChanges() it can be the on from\n      // the mongo package (instead of the minimongo one) and it doesn't have isReady and isReadyPromise\n      if (Meteor._isPromise(handle)) {\n        handle.then(setSuppressed);\n      } else {\n        setSuppressed(handle);\n      }\n      return handle;\n    };\n    LocalCollection._observeCallbacksAreOrdered = callbacks => {\n      if (callbacks.added && callbacks.addedAt) {\n        throw new Error('Please specify only one of added() and addedAt()');\n      }\n      if (callbacks.changed && callbacks.changedAt) {\n        throw new Error('Please specify only one of changed() and changedAt()');\n      }\n      if (callbacks.removed && callbacks.removedAt) {\n        throw new Error('Please specify only one of removed() and removedAt()');\n      }\n      return !!(callbacks.addedAt || callbacks.changedAt || callbacks.movedTo || callbacks.removedAt);\n    };\n    LocalCollection._observeChangesCallbacksAreOrdered = callbacks => {\n      if (callbacks.added && callbacks.addedBefore) {\n        throw new Error('Please specify only one of added() and addedBefore()');\n      }\n      return !!(callbacks.addedBefore || callbacks.movedBefore);\n    };\n    LocalCollection._removeFromResultsSync = (query, doc) => {\n      if (query.ordered) {\n        const i = LocalCollection._findInOrderedResults(query, doc);\n        query.removed(doc._id);\n        query.results.splice(i, 1);\n      } else {\n        const id = doc._id; // in case callback mutates doc\n\n        query.removed(doc._id);\n        query.results.remove(id);\n      }\n    };\n    LocalCollection._removeFromResultsAsync = async (query, doc) => {\n      if (query.ordered) {\n        const i = LocalCollection._findInOrderedResults(query, doc);\n        await query.removed(doc._id);\n        query.results.splice(i, 1);\n      } else {\n        const id = doc._id; // in case callback mutates doc\n\n        await query.removed(doc._id);\n        query.results.remove(id);\n      }\n    };\n\n    // Is this selector just shorthand for lookup by _id?\n    LocalCollection._selectorIsId = selector => typeof selector === 'number' || typeof selector === 'string' || selector instanceof MongoID.ObjectID;\n\n    // Is the selector just lookup by _id (shorthand or not)?\n    LocalCollection._selectorIsIdPerhapsAsObject = selector => LocalCollection._selectorIsId(selector) || LocalCollection._selectorIsId(selector && selector._id) && Object.keys(selector).length === 1;\n    LocalCollection._updateInResultsSync = (query, doc, old_doc) => {\n      if (!EJSON.equals(doc._id, old_doc._id)) {\n        throw new Error('Can\\'t change a doc\\'s _id while updating');\n      }\n      const projectionFn = query.projectionFn;\n      const changedFields = DiffSequence.makeChangedFields(projectionFn(doc), projectionFn(old_doc));\n      if (!query.ordered) {\n        if (Object.keys(changedFields).length) {\n          query.changed(doc._id, changedFields);\n          query.results.set(doc._id, doc);\n        }\n        return;\n      }\n      const old_idx = LocalCollection._findInOrderedResults(query, doc);\n      if (Object.keys(changedFields).length) {\n        query.changed(doc._id, changedFields);\n      }\n      if (!query.sorter) {\n        return;\n      }\n\n      // just take it out and put it back in again, and see if the index changes\n      query.results.splice(old_idx, 1);\n      const new_idx = LocalCollection._insertInSortedList(query.sorter.getComparator({\n        distances: query.distances\n      }), query.results, doc);\n      if (old_idx !== new_idx) {\n        let next = query.results[new_idx + 1];\n        if (next) {\n          next = next._id;\n        } else {\n          next = null;\n        }\n        query.movedBefore && query.movedBefore(doc._id, next);\n      }\n    };\n    LocalCollection._updateInResultsAsync = async (query, doc, old_doc) => {\n      if (!EJSON.equals(doc._id, old_doc._id)) {\n        throw new Error('Can\\'t change a doc\\'s _id while updating');\n      }\n      const projectionFn = query.projectionFn;\n      const changedFields = DiffSequence.makeChangedFields(projectionFn(doc), projectionFn(old_doc));\n      if (!query.ordered) {\n        if (Object.keys(changedFields).length) {\n          await query.changed(doc._id, changedFields);\n          query.results.set(doc._id, doc);\n        }\n        return;\n      }\n      const old_idx = LocalCollection._findInOrderedResults(query, doc);\n      if (Object.keys(changedFields).length) {\n        await query.changed(doc._id, changedFields);\n      }\n      if (!query.sorter) {\n        return;\n      }\n\n      // just take it out and put it back in again, and see if the index changes\n      query.results.splice(old_idx, 1);\n      const new_idx = LocalCollection._insertInSortedList(query.sorter.getComparator({\n        distances: query.distances\n      }), query.results, doc);\n      if (old_idx !== new_idx) {\n        let next = query.results[new_idx + 1];\n        if (next) {\n          next = next._id;\n        } else {\n          next = null;\n        }\n        query.movedBefore && (await query.movedBefore(doc._id, next));\n      }\n    };\n    const MODIFIERS = {\n      $currentDate(target, field, arg) {\n        if (typeof arg === 'object' && hasOwn.call(arg, '$type')) {\n          if (arg.$type !== 'date') {\n            throw MinimongoError('Minimongo does currently only support the date type in ' + '$currentDate modifiers', {\n              field\n            });\n          }\n        } else if (arg !== true) {\n          throw MinimongoError('Invalid $currentDate modifier', {\n            field\n          });\n        }\n        target[field] = new Date();\n      },\n      $inc(target, field, arg) {\n        if (typeof arg !== 'number') {\n          throw MinimongoError('Modifier $inc allowed for numbers only', {\n            field\n          });\n        }\n        if (field in target) {\n          if (typeof target[field] !== 'number') {\n            throw MinimongoError('Cannot apply $inc modifier to non-number', {\n              field\n            });\n          }\n          target[field] += arg;\n        } else {\n          target[field] = arg;\n        }\n      },\n      $min(target, field, arg) {\n        if (typeof arg !== 'number') {\n          throw MinimongoError('Modifier $min allowed for numbers only', {\n            field\n          });\n        }\n        if (field in target) {\n          if (typeof target[field] !== 'number') {\n            throw MinimongoError('Cannot apply $min modifier to non-number', {\n              field\n            });\n          }\n          if (target[field] > arg) {\n            target[field] = arg;\n          }\n        } else {\n          target[field] = arg;\n        }\n      },\n      $max(target, field, arg) {\n        if (typeof arg !== 'number') {\n          throw MinimongoError('Modifier $max allowed for numbers only', {\n            field\n          });\n        }\n        if (field in target) {\n          if (typeof target[field] !== 'number') {\n            throw MinimongoError('Cannot apply $max modifier to non-number', {\n              field\n            });\n          }\n          if (target[field] < arg) {\n            target[field] = arg;\n          }\n        } else {\n          target[field] = arg;\n        }\n      },\n      $mul(target, field, arg) {\n        if (typeof arg !== 'number') {\n          throw MinimongoError('Modifier $mul allowed for numbers only', {\n            field\n          });\n        }\n        if (field in target) {\n          if (typeof target[field] !== 'number') {\n            throw MinimongoError('Cannot apply $mul modifier to non-number', {\n              field\n            });\n          }\n          target[field] *= arg;\n        } else {\n          target[field] = 0;\n        }\n      },\n      $rename(target, field, arg, keypath, doc) {\n        // no idea why mongo has this restriction..\n        if (keypath === arg) {\n          throw MinimongoError('$rename source must differ from target', {\n            field\n          });\n        }\n        if (target === null) {\n          throw MinimongoError('$rename source field invalid', {\n            field\n          });\n        }\n        if (typeof arg !== 'string') {\n          throw MinimongoError('$rename target must be a string', {\n            field\n          });\n        }\n        if (arg.includes('\\0')) {\n          // Null bytes are not allowed in Mongo field names\n          // https://docs.mongodb.com/manual/reference/limits/#Restrictions-on-Field-Names\n          throw MinimongoError('The \\'to\\' field for $rename cannot contain an embedded null byte', {\n            field\n          });\n        }\n        if (target === undefined) {\n          return;\n        }\n        const object = target[field];\n        delete target[field];\n        const keyparts = arg.split('.');\n        const target2 = findModTarget(doc, keyparts, {\n          forbidArray: true\n        });\n        if (target2 === null) {\n          throw MinimongoError('$rename target field invalid', {\n            field\n          });\n        }\n        target2[keyparts.pop()] = object;\n      },\n      $set(target, field, arg) {\n        if (target !== Object(target)) {\n          // not an array or an object\n          const error = MinimongoError('Cannot set property on non-object field', {\n            field\n          });\n          error.setPropertyError = true;\n          throw error;\n        }\n        if (target === null) {\n          const error = MinimongoError('Cannot set property on null', {\n            field\n          });\n          error.setPropertyError = true;\n          throw error;\n        }\n        assertHasValidFieldNames(arg);\n        target[field] = arg;\n      },\n      $setOnInsert(target, field, arg) {\n        // converted to `$set` in `_modify`\n      },\n      $unset(target, field, arg) {\n        if (target !== undefined) {\n          if (target instanceof Array) {\n            if (field in target) {\n              target[field] = null;\n            }\n          } else {\n            delete target[field];\n          }\n        }\n      },\n      $push(target, field, arg) {\n        if (target[field] === undefined) {\n          target[field] = [];\n        }\n        if (!(target[field] instanceof Array)) {\n          throw MinimongoError('Cannot apply $push modifier to non-array', {\n            field\n          });\n        }\n        if (!(arg && arg.$each)) {\n          // Simple mode: not $each\n          assertHasValidFieldNames(arg);\n          target[field].push(arg);\n          return;\n        }\n\n        // Fancy mode: $each (and maybe $slice and $sort and $position)\n        const toPush = arg.$each;\n        if (!(toPush instanceof Array)) {\n          throw MinimongoError('$each must be an array', {\n            field\n          });\n        }\n        assertHasValidFieldNames(toPush);\n\n        // Parse $position\n        let position = undefined;\n        if ('$position' in arg) {\n          if (typeof arg.$position !== 'number') {\n            throw MinimongoError('$position must be a numeric value', {\n              field\n            });\n          }\n\n          // XXX should check to make sure integer\n          if (arg.$position < 0) {\n            throw MinimongoError('$position in $push must be zero or positive', {\n              field\n            });\n          }\n          position = arg.$position;\n        }\n\n        // Parse $slice.\n        let slice = undefined;\n        if ('$slice' in arg) {\n          if (typeof arg.$slice !== 'number') {\n            throw MinimongoError('$slice must be a numeric value', {\n              field\n            });\n          }\n\n          // XXX should check to make sure integer\n          slice = arg.$slice;\n        }\n\n        // Parse $sort.\n        let sortFunction = undefined;\n        if (arg.$sort) {\n          if (slice === undefined) {\n            throw MinimongoError('$sort requires $slice to be present', {\n              field\n            });\n          }\n\n          // XXX this allows us to use a $sort whose value is an array, but that's\n          // actually an extension of the Node driver, so it won't work\n          // server-side. Could be confusing!\n          // XXX is it correct that we don't do geo-stuff here?\n          sortFunction = new Minimongo.Sorter(arg.$sort).getComparator();\n          toPush.forEach(element => {\n            if (LocalCollection._f._type(element) !== 3) {\n              throw MinimongoError('$push like modifiers using $sort require all elements to be ' + 'objects', {\n                field\n              });\n            }\n          });\n        }\n\n        // Actually push.\n        if (position === undefined) {\n          toPush.forEach(element => {\n            target[field].push(element);\n          });\n        } else {\n          const spliceArguments = [position, 0];\n          toPush.forEach(element => {\n            spliceArguments.push(element);\n          });\n          target[field].splice(...spliceArguments);\n        }\n\n        // Actually sort.\n        if (sortFunction) {\n          target[field].sort(sortFunction);\n        }\n\n        // Actually slice.\n        if (slice !== undefined) {\n          if (slice === 0) {\n            target[field] = []; // differs from Array.slice!\n          } else if (slice < 0) {\n            target[field] = target[field].slice(slice);\n          } else {\n            target[field] = target[field].slice(0, slice);\n          }\n        }\n      },\n      $pushAll(target, field, arg) {\n        if (!(typeof arg === 'object' && arg instanceof Array)) {\n          throw MinimongoError('Modifier $pushAll/pullAll allowed for arrays only');\n        }\n        assertHasValidFieldNames(arg);\n        const toPush = target[field];\n        if (toPush === undefined) {\n          target[field] = arg;\n        } else if (!(toPush instanceof Array)) {\n          throw MinimongoError('Cannot apply $pushAll modifier to non-array', {\n            field\n          });\n        } else {\n          toPush.push(...arg);\n        }\n      },\n      $addToSet(target, field, arg) {\n        let isEach = false;\n        if (typeof arg === 'object') {\n          // check if first key is '$each'\n          const keys = Object.keys(arg);\n          if (keys[0] === '$each') {\n            isEach = true;\n          }\n        }\n        const values = isEach ? arg.$each : [arg];\n        assertHasValidFieldNames(values);\n        const toAdd = target[field];\n        if (toAdd === undefined) {\n          target[field] = values;\n        } else if (!(toAdd instanceof Array)) {\n          throw MinimongoError('Cannot apply $addToSet modifier to non-array', {\n            field\n          });\n        } else {\n          values.forEach(value => {\n            if (toAdd.some(element => LocalCollection._f._equal(value, element))) {\n              return;\n            }\n            toAdd.push(value);\n          });\n        }\n      },\n      $pop(target, field, arg) {\n        if (target === undefined) {\n          return;\n        }\n        const toPop = target[field];\n        if (toPop === undefined) {\n          return;\n        }\n        if (!(toPop instanceof Array)) {\n          throw MinimongoError('Cannot apply $pop modifier to non-array', {\n            field\n          });\n        }\n        if (typeof arg === 'number' && arg < 0) {\n          toPop.splice(0, 1);\n        } else {\n          toPop.pop();\n        }\n      },\n      $pull(target, field, arg) {\n        if (target === undefined) {\n          return;\n        }\n        const toPull = target[field];\n        if (toPull === undefined) {\n          return;\n        }\n        if (!(toPull instanceof Array)) {\n          throw MinimongoError('Cannot apply $pull/pullAll modifier to non-array', {\n            field\n          });\n        }\n        let out;\n        if (arg != null && typeof arg === 'object' && !(arg instanceof Array)) {\n          // XXX would be much nicer to compile this once, rather than\n          // for each document we modify.. but usually we're not\n          // modifying that many documents, so we'll let it slide for\n          // now\n\n          // XXX Minimongo.Matcher isn't up for the job, because we need\n          // to permit stuff like {$pull: {a: {$gt: 4}}}.. something\n          // like {$gt: 4} is not normally a complete selector.\n          // same issue as $elemMatch possibly?\n          const matcher = new Minimongo.Matcher(arg);\n          out = toPull.filter(element => !matcher.documentMatches(element).result);\n        } else {\n          out = toPull.filter(element => !LocalCollection._f._equal(element, arg));\n        }\n        target[field] = out;\n      },\n      $pullAll(target, field, arg) {\n        if (!(typeof arg === 'object' && arg instanceof Array)) {\n          throw MinimongoError('Modifier $pushAll/pullAll allowed for arrays only', {\n            field\n          });\n        }\n        if (target === undefined) {\n          return;\n        }\n        const toPull = target[field];\n        if (toPull === undefined) {\n          return;\n        }\n        if (!(toPull instanceof Array)) {\n          throw MinimongoError('Cannot apply $pull/pullAll modifier to non-array', {\n            field\n          });\n        }\n        target[field] = toPull.filter(object => !arg.some(element => LocalCollection._f._equal(object, element)));\n      },\n      $bit(target, field, arg) {\n        // XXX mongo only supports $bit on integers, and we only support\n        // native javascript numbers (doubles) so far, so we can't support $bit\n        throw MinimongoError('$bit is not supported', {\n          field\n        });\n      },\n      $v() {\n        // As discussed in https://github.com/meteor/meteor/issues/9623,\n        // the `$v` operator is not needed by Meteor, but problems can occur if\n        // it's not at least callable (as of Mongo >= 3.6). It's defined here as\n        // a no-op to work around these problems.\n      }\n    };\n    const NO_CREATE_MODIFIERS = {\n      $pop: true,\n      $pull: true,\n      $pullAll: true,\n      $rename: true,\n      $unset: true\n    };\n\n    // Make sure field names do not contain Mongo restricted\n    // characters ('.', '$', '\\0').\n    // https://docs.mongodb.com/manual/reference/limits/#Restrictions-on-Field-Names\n    const invalidCharMsg = {\n      $: 'start with \\'$\\'',\n      '.': 'contain \\'.\\'',\n      '\\0': 'contain null bytes'\n    };\n\n    // checks if all field names in an object are valid\n    function assertHasValidFieldNames(doc) {\n      if (doc && typeof doc === 'object') {\n        JSON.stringify(doc, (key, value) => {\n          assertIsValidFieldName(key);\n          return value;\n        });\n      }\n    }\n    function assertIsValidFieldName(key) {\n      let match;\n      if (typeof key === 'string' && (match = key.match(/^\\$|\\.|\\0/))) {\n        throw MinimongoError(\"Key \".concat(key, \" must not \").concat(invalidCharMsg[match[0]]));\n      }\n    }\n\n    // for a.b.c.2.d.e, keyparts should be ['a', 'b', 'c', '2', 'd', 'e'],\n    // and then you would operate on the 'e' property of the returned\n    // object.\n    //\n    // if options.noCreate is falsey, creates intermediate levels of\n    // structure as necessary, like mkdir -p (and raises an exception if\n    // that would mean giving a non-numeric property to an array.) if\n    // options.noCreate is true, return undefined instead.\n    //\n    // may modify the last element of keyparts to signal to the caller that it needs\n    // to use a different value to index into the returned object (for example,\n    // ['a', '01'] -> ['a', 1]).\n    //\n    // if forbidArray is true, return null if the keypath goes through an array.\n    //\n    // if options.arrayIndices is set, use its first element for the (first) '$' in\n    // the path.\n    function findModTarget(doc, keyparts) {\n      let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      let usedArrayIndex = false;\n      for (let i = 0; i < keyparts.length; i++) {\n        const last = i === keyparts.length - 1;\n        let keypart = keyparts[i];\n        if (!isIndexable(doc)) {\n          if (options.noCreate) {\n            return undefined;\n          }\n          const error = MinimongoError(\"cannot use the part '\".concat(keypart, \"' to traverse \").concat(doc));\n          error.setPropertyError = true;\n          throw error;\n        }\n        if (doc instanceof Array) {\n          if (options.forbidArray) {\n            return null;\n          }\n          if (keypart === '$') {\n            if (usedArrayIndex) {\n              throw MinimongoError('Too many positional (i.e. \\'$\\') elements');\n            }\n            if (!options.arrayIndices || !options.arrayIndices.length) {\n              throw MinimongoError('The positional operator did not find the match needed from the ' + 'query');\n            }\n            keypart = options.arrayIndices[0];\n            usedArrayIndex = true;\n          } else if (isNumericKey(keypart)) {\n            keypart = parseInt(keypart);\n          } else {\n            if (options.noCreate) {\n              return undefined;\n            }\n            throw MinimongoError(\"can't append to array using string field name [\".concat(keypart, \"]\"));\n          }\n          if (last) {\n            keyparts[i] = keypart; // handle 'a.01'\n          }\n          if (options.noCreate && keypart >= doc.length) {\n            return undefined;\n          }\n          while (doc.length < keypart) {\n            doc.push(null);\n          }\n          if (!last) {\n            if (doc.length === keypart) {\n              doc.push({});\n            } else if (typeof doc[keypart] !== 'object') {\n              throw MinimongoError(\"can't modify field '\".concat(keyparts[i + 1], \"' of list value \") + JSON.stringify(doc[keypart]));\n            }\n          }\n        } else {\n          assertIsValidFieldName(keypart);\n          if (!(keypart in doc)) {\n            if (options.noCreate) {\n              return undefined;\n            }\n            if (!last) {\n              doc[keypart] = {};\n            }\n          }\n        }\n        if (last) {\n          return doc;\n        }\n        doc = doc[keypart];\n      }\n\n      // notreached\n    }\n    __reify_async_result__();\n  } catch (_reifyError) {\n    return __reify_async_result__(_reifyError);\n  }\n  __reify_async_result__()\n}, {\n  self: this,\n  async: false\n});","map":{"version":3,"names":["_objectSpread","module","link","default","v","export","LocalCollection","Cursor","ObserveHandle","hasOwn","isIndexable","isNumericKey","isOperatorObject","populateDocumentWithQueryFields","projectionDetails","getAsyncMethodName","__reifyWaitForDeps__","constructor","name","_docs","_IdMap","_observeQueue","Meteor","isClient","_SynchronousQueue","_AsynchronousQueue","next_qid","queries","Object","create","_savedOriginals","paused","countDocuments","selector","options","find","countAsync","estimatedDocumentCount","arguments","length","findOne","undefined","limit","fetch","findOneAsync","fetchAsync","prepareInsert","doc","assertHasValidFieldNames","call","_id","_useOID","MongoID","ObjectID","Random","id","has","MinimongoError","concat","_saveOriginal","set","insert","callback","EJSON","clone","queriesToRecompute","qid","keys","query","dirty","matchResult","matcher","documentMatches","result","distances","distance","cursor","skip","push","_insertInResultsSync","forEach","_recomputeResults","drain","defer","insertAsync","_insertInResultsAsync","pauseObservers","resultsSnapshot","results","clearResultQueries","size","clear","ordered","prepareRemove","Minimongo","Matcher","remove","_eachPossiblyMatchingDocSync","queryRemove","i","removeId","removeDoc","get","equals","_removeFromResultsSync","removeAsync","_removeFromResultsAsync","_resumeObservers","_diffQueryChanges","projectionFn","resumeObserversServer","resumeObserversClient","retrieveOriginals","Error","originals","saveOriginals","prepareUpdate","qidToOriginalResults","docMap","idsMatched","_idsMatchedBySelector","Array","memoizedCloneIfNeeded","docToMemoize","some","map","finishUpdate","_ref","updateCount","insertedId","_returnObject","numberAffected","updateAsync","mod","Function","recomputeQids","_eachPossiblyMatchingDocAsync","queryResult","_modifyAndNotifyAsync","arrayIndices","multi","upsert","_createUpsertDocument","update","_modifyAndNotifySync","assign","upsertAsync","fn","specificIds","forEachAsync","_getMatchedDocAndModify","matched_before","old_doc","_modify","afterMatch","after","before","_updateInResultsSync","_updateInResultsAsync","oldResults","_getRawObjects","_CachingChangeObserver","orderedFromCallbacks","callbacks","_observeChangesCallbacksAreOrdered","docs","OrderedDict","idStringify","applyChange","addedBefore","fields","added","putBefore","movedBefore","moveBefore","changed","DiffSequence","applyChanges","removed","IdMap","idParse","wrapTransform","transform","__wrappedTransform__","wrapped","transformed","Tracker","nonreactive","_isPlainObject","_binarySearch","cmp","array","value","first","range","halfRange","Math","floor","_checkSupportedProjection","isArray","keyPath","split","includes","key","_compileProjection","_idProjection","details","ruleTree","subdoc","including","rule","tree","modifier","selectorDocument","isModify","_isModificationMod","newDoc","$set","isInsert","replacement","_diffObjects","left","right","diffObjects","newResults","observer","diffQueryChanges","_diffQueryOrderedChanges","diffQueryOrderedChanges","_diffQueryUnorderedChanges","diffQueryUnorderedChanges","_findInOrderedResults","_selectorIsId","$in","every","$and","subIds","sorter","_insertInSortedList","getComparator","next","splice","isReplace","substr","x","_f","_type","isModifier","operator","setOnInsert","modFunc","MODIFIERS","operand","keypath","arg","keyparts","Boolean","target","findModTarget","forbidArray","noCreate","NO_CREATE_MODIFIERS","pop","_observeFromObserveChanges","observeCallbacks","getTransform","suppressed","_suppress_initial","observeChangesCallbacks","_observeCallbacksAreOrdered","indices","_no_indices","check","addedAt","indexOf","changedAt","oldDoc","movedTo","from","to","removedAt","changeObserver","_fromObserve","handle","observeChanges","nonMutatingCallbacks","setSuppressed","h","_h$isReadyPromise","isReady","isReadyPromise","then","_isPromise","_selectorIsIdPerhapsAsObject","changedFields","makeChangedFields","old_idx","new_idx","$currentDate","field","$type","Date","$inc","$min","$max","$mul","$rename","object","target2","error","setPropertyError","$setOnInsert","$unset","$push","$each","toPush","position","$position","slice","$slice","sortFunction","$sort","Sorter","element","spliceArguments","sort","$pushAll","$addToSet","isEach","values","toAdd","_equal","$pop","toPop","$pull","toPull","out","filter","$pullAll","$bit","$v","invalidCharMsg","$","JSON","stringify","assertIsValidFieldName","match","usedArrayIndex","last","keypart","parseInt","__reify_async_result__","_reifyError","self","async"],"sources":["packages/minimongo/local_collection.js"],"sourcesContent":["import Cursor from './cursor.js';\nimport ObserveHandle from './observe_handle.js';\nimport {\n  hasOwn,\n  isIndexable,\n  isNumericKey,\n  isOperatorObject,\n  populateDocumentWithQueryFields,\n  projectionDetails,\n} from './common.js';\n\nimport { getAsyncMethodName } from './constants';\n\n// XXX type checking on selectors (graceful error if malformed)\n\n// LocalCollection: a set of documents that supports queries and modifiers.\nexport default class LocalCollection {\n  constructor(name) {\n    this.name = name;\n    // _id -> document (also containing id)\n    this._docs = new LocalCollection._IdMap;\n\n    this._observeQueue = Meteor.isClient\n      ? new Meteor._SynchronousQueue()\n      : new Meteor._AsynchronousQueue();\n\n    this.next_qid = 1; // live query id generator\n\n    // qid -> live query object. keys:\n    //  ordered: bool. ordered queries have addedBefore/movedBefore callbacks.\n    //  results: array (ordered) or object (unordered) of current results\n    //    (aliased with this._docs!)\n    //  resultsSnapshot: snapshot of results. null if not paused.\n    //  cursor: Cursor object for the query.\n    //  selector, sorter, (callbacks): functions\n    this.queries = Object.create(null);\n\n    // null if not saving originals; an IdMap from id to original document value\n    // if saving originals. See comments before saveOriginals().\n    this._savedOriginals = null;\n\n    // True when observers are paused and we should not send callbacks.\n    this.paused = false;\n  }\n\n  countDocuments(selector, options) {\n    return this.find(selector ?? {}, options).countAsync();\n  }\n\n  estimatedDocumentCount(options) {\n    return this.find({}, options).countAsync();\n  }\n\n  // options may include sort, skip, limit, reactive\n  // sort may be any of these forms:\n  //     {a: 1, b: -1}\n  //     [[\"a\", \"asc\"], [\"b\", \"desc\"]]\n  //     [\"a\", [\"b\", \"desc\"]]\n  //   (in the first form you're beholden to key enumeration order in\n  //   your javascript VM)\n  //\n  // reactive: if given, and false, don't register with Tracker (default\n  // is true)\n  //\n  // XXX possibly should support retrieving a subset of fields? and\n  // have it be a hint (ignored on the client, when not copying the\n  // doc?)\n  //\n  // XXX sort does not yet support subkeys ('a.b') .. fix that!\n  // XXX add one more sort form: \"key\"\n  // XXX tests\n  find(selector, options) {\n    // default syntax for everything is to omit the selector argument.\n    // but if selector is explicitly passed in as false or undefined, we\n    // want a selector that matches nothing.\n    if (arguments.length === 0) {\n      selector = {};\n    }\n\n    return new LocalCollection.Cursor(this, selector, options);\n  }\n\n  findOne(selector, options = {}) {\n    if (arguments.length === 0) {\n      selector = {};\n    }\n\n    // NOTE: by setting limit 1 here, we end up using very inefficient\n    // code that recomputes the whole query on each update. The upside is\n    // that when you reactively depend on a findOne you only get\n    // invalidated when the found object changes, not any object in the\n    // collection. Most findOne will be by id, which has a fast path, so\n    // this might not be a big deal. In most cases, invalidation causes\n    // the called to re-query anyway, so this should be a net performance\n    // improvement.\n    options.limit = 1;\n\n    return this.find(selector, options).fetch()[0];\n  }\n  async findOneAsync(selector, options = {}) {\n    if (arguments.length === 0) {\n      selector = {};\n    }\n    options.limit = 1;\n    return (await this.find(selector, options).fetchAsync())[0];\n  }\n  prepareInsert(doc) {\n    assertHasValidFieldNames(doc);\n\n    // if you really want to use ObjectIDs, set this global.\n    // Mongo.Collection specifies its own ids and does not use this code.\n    if (!hasOwn.call(doc, '_id')) {\n      doc._id = LocalCollection._useOID ? new MongoID.ObjectID() : Random.id();\n    }\n\n    const id = doc._id;\n\n    if (this._docs.has(id)) {\n      throw MinimongoError(`Duplicate _id '${id}'`);\n    }\n\n    this._saveOriginal(id, undefined);\n    this._docs.set(id, doc);\n\n    return id;\n  }\n\n  // XXX possibly enforce that 'undefined' does not appear (we assume\n  // this in our handling of null and $exists)\n  insert(doc, callback) {\n    doc = EJSON.clone(doc);\n    const id = this.prepareInsert(doc);\n    const queriesToRecompute = [];\n\n    // trigger live queries that match\n    for (const qid of Object.keys(this.queries)) {\n      const query = this.queries[qid];\n\n      if (query.dirty) {\n        continue;\n      }\n\n      const matchResult = query.matcher.documentMatches(doc);\n\n      if (matchResult.result) {\n        if (query.distances && matchResult.distance !== undefined) {\n          query.distances.set(id, matchResult.distance);\n        }\n\n        if (query.cursor.skip || query.cursor.limit) {\n          queriesToRecompute.push(qid);\n        } else {\n          LocalCollection._insertInResultsSync(query, doc);\n        }\n      }\n    }\n\n    queriesToRecompute.forEach(qid => {\n      if (this.queries[qid]) {\n        this._recomputeResults(this.queries[qid]);\n      }\n    });\n\n    this._observeQueue.drain();\n    if (callback) {\n      Meteor.defer(() => {\n        callback(null, id);\n      });\n    }\n\n    return id;\n  }\n  async insertAsync(doc, callback) {\n    doc = EJSON.clone(doc);\n    const id = this.prepareInsert(doc);\n    const queriesToRecompute = [];\n\n    // trigger live queries that match\n    for (const qid of Object.keys(this.queries)) {\n      const query = this.queries[qid];\n\n      if (query.dirty) {\n        continue;\n      }\n\n      const matchResult = query.matcher.documentMatches(doc);\n\n      if (matchResult.result) {\n        if (query.distances && matchResult.distance !== undefined) {\n          query.distances.set(id, matchResult.distance);\n        }\n\n        if (query.cursor.skip || query.cursor.limit) {\n          queriesToRecompute.push(qid);\n        } else {\n          await LocalCollection._insertInResultsAsync(query, doc);\n        }\n      }\n    }\n\n    queriesToRecompute.forEach(qid => {\n      if (this.queries[qid]) {\n        this._recomputeResults(this.queries[qid]);\n      }\n    });\n\n    await this._observeQueue.drain();\n    if (callback) {\n      Meteor.defer(() => {\n        callback(null, id);\n      });\n    }\n\n    return id;\n  }\n\n  // Pause the observers. No callbacks from observers will fire until\n  // 'resumeObservers' is called.\n  pauseObservers() {\n    // No-op if already paused.\n    if (this.paused) {\n      return;\n    }\n\n    // Set the 'paused' flag such that new observer messages don't fire.\n    this.paused = true;\n\n    // Take a snapshot of the query results for each query.\n    Object.keys(this.queries).forEach(qid => {\n      const query = this.queries[qid];\n      query.resultsSnapshot = EJSON.clone(query.results);\n    });\n  }\n\n  clearResultQueries(callback) {\n    const result = this._docs.size();\n\n    this._docs.clear();\n\n    Object.keys(this.queries).forEach(qid => {\n      const query = this.queries[qid];\n\n      if (query.ordered) {\n        query.results = [];\n      } else {\n        query.results.clear();\n      }\n    });\n\n    if (callback) {\n      Meteor.defer(() => {\n        callback(null, result);\n      });\n    }\n\n    return result;\n  }\n\n\n  prepareRemove(selector) {\n    const matcher = new Minimongo.Matcher(selector);\n    const remove = [];\n\n    this._eachPossiblyMatchingDocSync(selector, (doc, id) => {\n      if (matcher.documentMatches(doc).result) {\n        remove.push(id);\n      }\n    });\n\n    const queriesToRecompute = [];\n    const queryRemove = [];\n\n    for (let i = 0; i < remove.length; i++) {\n      const removeId = remove[i];\n      const removeDoc = this._docs.get(removeId);\n\n      Object.keys(this.queries).forEach(qid => {\n        const query = this.queries[qid];\n\n        if (query.dirty) {\n          return;\n        }\n\n        if (query.matcher.documentMatches(removeDoc).result) {\n          if (query.cursor.skip || query.cursor.limit) {\n            queriesToRecompute.push(qid);\n          } else {\n            queryRemove.push({qid, doc: removeDoc});\n          }\n        }\n      });\n\n      this._saveOriginal(removeId, removeDoc);\n      this._docs.remove(removeId);\n    }\n\n    return { queriesToRecompute, queryRemove, remove };\n  }\n\n  remove(selector, callback) {\n    // Easy special case: if we're not calling observeChanges callbacks and\n    // we're not saving originals and we got asked to remove everything, then\n    // just empty everything directly.\n    if (this.paused && !this._savedOriginals && EJSON.equals(selector, {})) {\n      return this.clearResultQueries(callback);\n    }\n\n    const { queriesToRecompute, queryRemove, remove } = this.prepareRemove(selector);\n\n    // run live query callbacks _after_ we've removed the documents.\n    queryRemove.forEach(remove => {\n      const query = this.queries[remove.qid];\n\n      if (query) {\n        query.distances && query.distances.remove(remove.doc._id);\n        LocalCollection._removeFromResultsSync(query, remove.doc);\n      }\n    });\n\n    queriesToRecompute.forEach(qid => {\n      const query = this.queries[qid];\n\n      if (query) {\n        this._recomputeResults(query);\n      }\n    });\n\n    this._observeQueue.drain();\n\n    const result = remove.length;\n\n    if (callback) {\n      Meteor.defer(() => {\n        callback(null, result);\n      });\n    }\n\n    return result;\n  }\n\n  async removeAsync(selector, callback) {\n    // Easy special case: if we're not calling observeChanges callbacks and\n    // we're not saving originals and we got asked to remove everything, then\n    // just empty everything directly.\n    if (this.paused && !this._savedOriginals && EJSON.equals(selector, {})) {\n      return this.clearResultQueries(callback);\n    }\n\n    const { queriesToRecompute, queryRemove, remove } = this.prepareRemove(selector);\n\n    // run live query callbacks _after_ we've removed the documents.\n    for (const remove of queryRemove) {\n      const query = this.queries[remove.qid];\n\n      if (query) {\n        query.distances && query.distances.remove(remove.doc._id);\n        await LocalCollection._removeFromResultsAsync(query, remove.doc);\n      }\n    }\n    queriesToRecompute.forEach(qid => {\n      const query = this.queries[qid];\n\n      if (query) {\n        this._recomputeResults(query);\n      }\n    });\n\n    await this._observeQueue.drain();\n\n    const result = remove.length;\n\n    if (callback) {\n      Meteor.defer(() => {\n        callback(null, result);\n      });\n    }\n\n    return result;\n  }\n\n  // Resume the observers. Observers immediately receive change\n  // notifications to bring them to the current state of the\n  // database. Note that this is not just replaying all the changes that\n  // happened during the pause, it is a smarter 'coalesced' diff.\n  _resumeObservers() {\n    // No-op if not paused.\n    if (!this.paused) {\n      return;\n    }\n\n    // Unset the 'paused' flag. Make sure to do this first, otherwise\n    // observer methods won't actually fire when we trigger them.\n    this.paused = false;\n\n    Object.keys(this.queries).forEach(qid => {\n      const query = this.queries[qid];\n\n      if (query.dirty) {\n        query.dirty = false;\n\n        // re-compute results will perform `LocalCollection._diffQueryChanges`\n        // automatically.\n        this._recomputeResults(query, query.resultsSnapshot);\n      } else {\n        // Diff the current results against the snapshot and send to observers.\n        // pass the query object for its observer callbacks.\n        LocalCollection._diffQueryChanges(\n          query.ordered,\n          query.resultsSnapshot,\n          query.results,\n          query,\n          {projectionFn: query.projectionFn}\n        );\n      }\n\n      query.resultsSnapshot = null;\n    });\n  }\n\n  async resumeObserversServer() {\n    this._resumeObservers();\n    await this._observeQueue.drain();\n  }\n  resumeObserversClient() {\n    this._resumeObservers();\n    this._observeQueue.drain();\n  }\n\n  retrieveOriginals() {\n    if (!this._savedOriginals) {\n      throw new Error('Called retrieveOriginals without saveOriginals');\n    }\n\n    const originals = this._savedOriginals;\n\n    this._savedOriginals = null;\n\n    return originals;\n  }\n\n  // To track what documents are affected by a piece of code, call\n  // saveOriginals() before it and retrieveOriginals() after it.\n  // retrieveOriginals returns an object whose keys are the ids of the documents\n  // that were affected since the call to saveOriginals(), and the values are\n  // equal to the document's contents at the time of saveOriginals. (In the case\n  // of an inserted document, undefined is the value.) You must alternate\n  // between calls to saveOriginals() and retrieveOriginals().\n  saveOriginals() {\n    if (this._savedOriginals) {\n      throw new Error('Called saveOriginals twice without retrieveOriginals');\n    }\n\n    this._savedOriginals = new LocalCollection._IdMap;\n  }\n\n  prepareUpdate(selector) {\n    // Save the original results of any query that we might need to\n    // _recomputeResults on, because _modifyAndNotify will mutate the objects in\n    // it. (We don't need to save the original results of paused queries because\n    // they already have a resultsSnapshot and we won't be diffing in\n    // _recomputeResults.)\n    const qidToOriginalResults = {};\n\n    // We should only clone each document once, even if it appears in multiple\n    // queries\n    const docMap = new LocalCollection._IdMap;\n    const idsMatched = LocalCollection._idsMatchedBySelector(selector);\n\n    Object.keys(this.queries).forEach(qid => {\n      const query = this.queries[qid];\n\n      if ((query.cursor.skip || query.cursor.limit) && ! this.paused) {\n        // Catch the case of a reactive `count()` on a cursor with skip\n        // or limit, which registers an unordered observe. This is a\n        // pretty rare case, so we just clone the entire result set with\n        // no optimizations for documents that appear in these result\n        // sets and other queries.\n        if (query.results instanceof LocalCollection._IdMap) {\n          qidToOriginalResults[qid] = query.results.clone();\n          return;\n        }\n\n        if (!(query.results instanceof Array)) {\n          throw new Error('Assertion failed: query.results not an array');\n        }\n\n        // Clones a document to be stored in `qidToOriginalResults`\n        // because it may be modified before the new and old result sets\n        // are diffed. But if we know exactly which document IDs we're\n        // going to modify, then we only need to clone those.\n        const memoizedCloneIfNeeded = doc => {\n          if (docMap.has(doc._id)) {\n            return docMap.get(doc._id);\n          }\n\n          const docToMemoize = (\n            idsMatched &&\n            !idsMatched.some(id => EJSON.equals(id, doc._id))\n          ) ? doc : EJSON.clone(doc);\n\n          docMap.set(doc._id, docToMemoize);\n\n          return docToMemoize;\n        };\n\n        qidToOriginalResults[qid] = query.results.map(memoizedCloneIfNeeded);\n      }\n    });\n\n    return qidToOriginalResults;\n  }\n\n  finishUpdate({ options, updateCount, callback, insertedId }) {\n\n\n    // Return the number of affected documents, or in the upsert case, an object\n    // containing the number of affected docs and the id of the doc that was\n    // inserted, if any.\n    let result;\n    if (options._returnObject) {\n      result = { numberAffected: updateCount };\n\n      if (insertedId !== undefined) {\n        result.insertedId = insertedId;\n      }\n    } else {\n      result = updateCount;\n    }\n\n    if (callback) {\n      Meteor.defer(() => {\n        callback(null, result);\n      });\n    }\n\n    return result;\n  }\n\n  // XXX atomicity: if multi is true, and one modification fails, do\n  // we rollback the whole operation, or what?\n  async updateAsync(selector, mod, options, callback) {\n    if (! callback && options instanceof Function) {\n      callback = options;\n      options = null;\n    }\n\n    if (!options) {\n      options = {};\n    }\n\n    const matcher = new Minimongo.Matcher(selector, true);\n\n    const qidToOriginalResults = this.prepareUpdate(selector);\n\n    let recomputeQids = {};\n\n    let updateCount = 0;\n\n    await this._eachPossiblyMatchingDocAsync(selector, async (doc, id) => {\n      const queryResult = matcher.documentMatches(doc);\n\n      if (queryResult.result) {\n        // XXX Should we save the original even if mod ends up being a no-op?\n        this._saveOriginal(id, doc);\n        recomputeQids = await this._modifyAndNotifyAsync(\n          doc,\n          mod,\n          queryResult.arrayIndices\n        );\n\n        ++updateCount;\n\n        if (!options.multi) {\n          return false; // break\n        }\n      }\n\n      return true;\n    });\n\n    Object.keys(recomputeQids).forEach(qid => {\n      const query = this.queries[qid];\n\n      if (query) {\n        this._recomputeResults(query, qidToOriginalResults[qid]);\n      }\n    });\n\n    await this._observeQueue.drain();\n\n    // If we are doing an upsert, and we didn't modify any documents yet, then\n    // it's time to do an insert. Figure out what document we are inserting, and\n    // generate an id for it.\n    let insertedId;\n    if (updateCount === 0 && options.upsert) {\n      const doc = LocalCollection._createUpsertDocument(selector, mod);\n      if (!doc._id && options.insertedId) {\n        doc._id = options.insertedId;\n      }\n\n      insertedId = await this.insertAsync(doc);\n      updateCount = 1;\n    }\n\n    return this.finishUpdate({\n      options,\n      insertedId,\n      updateCount,\n      callback,\n    });\n  }\n  // XXX atomicity: if multi is true, and one modification fails, do\n  // we rollback the whole operation, or what?\n  update(selector, mod, options, callback) {\n    if (! callback && options instanceof Function) {\n      callback = options;\n      options = null;\n    }\n\n    if (!options) {\n      options = {};\n    }\n\n    const matcher = new Minimongo.Matcher(selector, true);\n\n    const qidToOriginalResults = this.prepareUpdate(selector);\n\n    let recomputeQids = {};\n\n    let updateCount = 0;\n\n    this._eachPossiblyMatchingDocSync(selector, (doc, id) => {\n      const queryResult = matcher.documentMatches(doc);\n\n      if (queryResult.result) {\n        // XXX Should we save the original even if mod ends up being a no-op?\n        this._saveOriginal(id, doc);\n        recomputeQids = this._modifyAndNotifySync(\n          doc,\n          mod,\n          queryResult.arrayIndices\n        );\n\n        ++updateCount;\n\n        if (!options.multi) {\n          return false; // break\n        }\n      }\n\n      return true;\n    });\n\n    Object.keys(recomputeQids).forEach(qid => {\n      const query = this.queries[qid];\n      if (query) {\n        this._recomputeResults(query, qidToOriginalResults[qid]);\n      }\n    });\n\n    this._observeQueue.drain();\n\n\n    // If we are doing an upsert, and we didn't modify any documents yet, then\n    // it's time to do an insert. Figure out what document we are inserting, and\n    // generate an id for it.\n    let insertedId;\n    if (updateCount === 0 && options.upsert) {\n      const doc = LocalCollection._createUpsertDocument(selector, mod);\n      if (!doc._id && options.insertedId) {\n        doc._id = options.insertedId;\n      }\n\n      insertedId = this.insert(doc);\n      updateCount = 1;\n    }\n\n\n    return this.finishUpdate({\n      options,\n      updateCount,\n      callback,\n      selector,\n      mod,\n    });\n  }\n\n  // A convenience wrapper on update. LocalCollection.upsert(sel, mod) is\n  // equivalent to LocalCollection.update(sel, mod, {upsert: true,\n  // _returnObject: true}).\n  upsert(selector, mod, options, callback) {\n    if (!callback && typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n\n    return this.update(\n      selector,\n      mod,\n      Object.assign({}, options, {upsert: true, _returnObject: true}),\n      callback\n    );\n  }\n\n  upsertAsync(selector, mod, options, callback) {\n    if (!callback && typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n\n    return this.updateAsync(\n      selector,\n      mod,\n      Object.assign({}, options, {upsert: true, _returnObject: true}),\n      callback\n    );\n  }\n\n  // Iterates over a subset of documents that could match selector; calls\n  // fn(doc, id) on each of them.  Specifically, if selector specifies\n  // specific _id's, it only looks at those.  doc is *not* cloned: it is the\n  // same object that is in _docs.\n  async _eachPossiblyMatchingDocAsync(selector, fn) {\n    const specificIds = LocalCollection._idsMatchedBySelector(selector);\n\n    if (specificIds) {\n      for (const id of specificIds) {\n        const doc = this._docs.get(id);\n\n        if (doc && ! (await fn(doc, id))) {\n          break\n        }\n      }\n    } else {\n      await this._docs.forEachAsync(fn);\n    }\n  }\n  _eachPossiblyMatchingDocSync(selector, fn) {\n    const specificIds = LocalCollection._idsMatchedBySelector(selector);\n\n    if (specificIds) {\n      for (const id of specificIds) {\n        const doc = this._docs.get(id);\n\n        if (doc && !fn(doc, id)) {\n          break\n        }\n      }\n    } else {\n      this._docs.forEach(fn);\n    }\n  }\n\n  _getMatchedDocAndModify(doc, mod, arrayIndices) {\n    const matched_before = {};\n\n    Object.keys(this.queries).forEach(qid => {\n      const query = this.queries[qid];\n\n      if (query.dirty) {\n        return;\n      }\n\n      if (query.ordered) {\n        matched_before[qid] = query.matcher.documentMatches(doc).result;\n      } else {\n        // Because we don't support skip or limit (yet) in unordered queries, we\n        // can just do a direct lookup.\n        matched_before[qid] = query.results.has(doc._id);\n      }\n    });\n\n    return matched_before;\n  }\n\n  _modifyAndNotifySync(doc, mod, arrayIndices) {\n\n    const matched_before = this._getMatchedDocAndModify(doc, mod, arrayIndices);\n\n    const old_doc = EJSON.clone(doc);\n    LocalCollection._modify(doc, mod, {arrayIndices});\n\n    const recomputeQids = {};\n\n    for (const qid of Object.keys(this.queries)) {\n      const query = this.queries[qid];\n\n      if (query.dirty) {\n        continue;\n      }\n\n      const afterMatch = query.matcher.documentMatches(doc);\n      const after = afterMatch.result;\n      const before = matched_before[qid];\n\n      if (after && query.distances && afterMatch.distance !== undefined) {\n        query.distances.set(doc._id, afterMatch.distance);\n      }\n\n      if (query.cursor.skip || query.cursor.limit) {\n        // We need to recompute any query where the doc may have been in the\n        // cursor's window either before or after the update. (Note that if skip\n        // or limit is set, \"before\" and \"after\" being true do not necessarily\n        // mean that the document is in the cursor's output after skip/limit is\n        // applied... but if they are false, then the document definitely is NOT\n        // in the output. So it's safe to skip recompute if neither before or\n        // after are true.)\n        if (before || after) {\n          recomputeQids[qid] = true;\n        }\n      } else if (before && !after) {\n        LocalCollection._removeFromResultsSync(query, doc);\n      } else if (!before && after) {\n        LocalCollection._insertInResultsSync(query, doc);\n      } else if (before && after) {\n        LocalCollection._updateInResultsSync(query, doc, old_doc);\n      }\n    }\n    return recomputeQids;\n  }\n\n  async _modifyAndNotifyAsync(doc, mod, arrayIndices) {\n\n    const matched_before = this._getMatchedDocAndModify(doc, mod, arrayIndices);\n\n    const old_doc = EJSON.clone(doc);\n    LocalCollection._modify(doc, mod, {arrayIndices});\n\n    const recomputeQids = {};\n    for (const qid of Object.keys(this.queries)) {\n      const query = this.queries[qid];\n\n      if (query.dirty) {\n        continue;\n      }\n\n      const afterMatch = query.matcher.documentMatches(doc);\n      const after = afterMatch.result;\n      const before = matched_before[qid];\n\n      if (after && query.distances && afterMatch.distance !== undefined) {\n        query.distances.set(doc._id, afterMatch.distance);\n      }\n\n      if (query.cursor.skip || query.cursor.limit) {\n        // We need to recompute any query where the doc may have been in the\n        // cursor's window either before or after the update. (Note that if skip\n        // or limit is set, \"before\" and \"after\" being true do not necessarily\n        // mean that the document is in the cursor's output after skip/limit is\n        // applied... but if they are false, then the document definitely is NOT\n        // in the output. So it's safe to skip recompute if neither before or\n        // after are true.)\n        if (before || after) {\n          recomputeQids[qid] = true;\n        }\n      } else if (before && !after) {\n        await LocalCollection._removeFromResultsAsync(query, doc);\n      } else if (!before && after) {\n        await LocalCollection._insertInResultsAsync(query, doc);\n      } else if (before && after) {\n        await LocalCollection._updateInResultsAsync(query, doc, old_doc);\n      }\n    }\n    return recomputeQids;\n  }\n\n  // Recomputes the results of a query and runs observe callbacks for the\n  // difference between the previous results and the current results (unless\n  // paused). Used for skip/limit queries.\n  //\n  // When this is used by insert or remove, it can just use query.results for\n  // the old results (and there's no need to pass in oldResults), because these\n  // operations don't mutate the documents in the collection. Update needs to\n  // pass in an oldResults which was deep-copied before the modifier was\n  // applied.\n  //\n  // oldResults is guaranteed to be ignored if the query is not paused.\n  _recomputeResults(query, oldResults) {\n    if (this.paused) {\n      // There's no reason to recompute the results now as we're still paused.\n      // By flagging the query as \"dirty\", the recompute will be performed\n      // when resumeObservers is called.\n      query.dirty = true;\n      return;\n    }\n\n    if (!this.paused && !oldResults) {\n      oldResults = query.results;\n    }\n\n    if (query.distances) {\n      query.distances.clear();\n    }\n\n    query.results = query.cursor._getRawObjects({\n      distances: query.distances,\n      ordered: query.ordered\n    });\n\n    if (!this.paused) {\n      LocalCollection._diffQueryChanges(\n        query.ordered,\n        oldResults,\n        query.results,\n        query,\n        {projectionFn: query.projectionFn}\n      );\n    }\n  }\n\n  _saveOriginal(id, doc) {\n    // Are we even trying to save originals?\n    if (!this._savedOriginals) {\n      return;\n    }\n\n    // Have we previously mutated the original (and so 'doc' is not actually\n    // original)?  (Note the 'has' check rather than truth: we store undefined\n    // here for inserted docs!)\n    if (this._savedOriginals.has(id)) {\n      return;\n    }\n\n    this._savedOriginals.set(id, EJSON.clone(doc));\n  }\n}\n\nLocalCollection.Cursor = Cursor;\n\nLocalCollection.ObserveHandle = ObserveHandle;\n\n// XXX maybe move these into another ObserveHelpers package or something\n\n// _CachingChangeObserver is an object which receives observeChanges callbacks\n// and keeps a cache of the current cursor state up to date in this.docs. Users\n// of this class should read the docs field but not modify it. You should pass\n// the \"applyChange\" field as the callbacks to the underlying observeChanges\n// call. Optionally, you can specify your own observeChanges callbacks which are\n// invoked immediately before the docs field is updated; this object is made\n// available as `this` to those callbacks.\nLocalCollection._CachingChangeObserver = class _CachingChangeObserver {\n  constructor(options = {}) {\n    const orderedFromCallbacks = (\n      options.callbacks &&\n      LocalCollection._observeChangesCallbacksAreOrdered(options.callbacks)\n    );\n\n    if (hasOwn.call(options, 'ordered')) {\n      this.ordered = options.ordered;\n\n      if (options.callbacks && options.ordered !== orderedFromCallbacks) {\n        throw Error('ordered option doesn\\'t match callbacks');\n      }\n    } else if (options.callbacks) {\n      this.ordered = orderedFromCallbacks;\n    } else {\n      throw Error('must provide ordered or callbacks');\n    }\n\n    const callbacks = options.callbacks || {};\n\n    if (this.ordered) {\n      this.docs = new OrderedDict(MongoID.idStringify);\n      this.applyChange = {\n        addedBefore: (id, fields, before) => {\n          // Take a shallow copy since the top-level properties can be changed\n          const doc = { ...fields };\n\n          doc._id = id;\n\n          if (callbacks.addedBefore) {\n            callbacks.addedBefore.call(this, id, EJSON.clone(fields), before);\n          }\n\n          // This line triggers if we provide added with movedBefore.\n          if (callbacks.added) {\n            callbacks.added.call(this, id, EJSON.clone(fields));\n          }\n\n          // XXX could `before` be a falsy ID?  Technically\n          // idStringify seems to allow for them -- though\n          // OrderedDict won't call stringify on a falsy arg.\n          this.docs.putBefore(id, doc, before || null);\n        },\n        movedBefore: (id, before) => {\n          if (callbacks.movedBefore) {\n            callbacks.movedBefore.call(this, id, before);\n          }\n\n          this.docs.moveBefore(id, before || null);\n        },\n      };\n    } else {\n      this.docs = new LocalCollection._IdMap;\n      this.applyChange = {\n        added: (id, fields) => {\n          // Take a shallow copy since the top-level properties can be changed\n          const doc = { ...fields };\n\n          if (callbacks.added) {\n            callbacks.added.call(this, id, EJSON.clone(fields));\n          }\n\n          doc._id = id;\n\n          this.docs.set(id,  doc);\n        },\n      };\n    }\n\n    // The methods in _IdMap and OrderedDict used by these callbacks are\n    // identical.\n    this.applyChange.changed = (id, fields) => {\n      const doc = this.docs.get(id);\n\n      if (!doc) {\n        throw new Error(`Unknown id for changed: ${id}`);\n      }\n\n      if (callbacks.changed) {\n        callbacks.changed.call(this, id, EJSON.clone(fields));\n      }\n\n      DiffSequence.applyChanges(doc, fields);\n    };\n\n    this.applyChange.removed = id => {\n      if (callbacks.removed) {\n        callbacks.removed.call(this, id);\n      }\n\n      this.docs.remove(id);\n    };\n  }\n};\n\nLocalCollection._IdMap = class _IdMap extends IdMap {\n  constructor() {\n    super(MongoID.idStringify, MongoID.idParse);\n  }\n};\n\n// Wrap a transform function to return objects that have the _id field\n// of the untransformed document. This ensures that subsystems such as\n// the observe-sequence package that call `observe` can keep track of\n// the documents identities.\n//\n// - Require that it returns objects\n// - If the return value has an _id field, verify that it matches the\n//   original _id field\n// - If the return value doesn't have an _id field, add it back.\nLocalCollection.wrapTransform = transform => {\n  if (!transform) {\n    return null;\n  }\n\n  // No need to doubly-wrap transforms.\n  if (transform.__wrappedTransform__) {\n    return transform;\n  }\n\n  const wrapped = doc => {\n    if (!hasOwn.call(doc, '_id')) {\n      // XXX do we ever have a transform on the oplog's collection? because that\n      // collection has no _id.\n      throw new Error('can only transform documents with _id');\n    }\n\n    const id = doc._id;\n\n    // XXX consider making tracker a weak dependency and checking\n    // Package.tracker here\n    const transformed = Tracker.nonreactive(() => transform(doc));\n\n    if (!LocalCollection._isPlainObject(transformed)) {\n      throw new Error('transform must return object');\n    }\n\n    if (hasOwn.call(transformed, '_id')) {\n      if (!EJSON.equals(transformed._id, id)) {\n        throw new Error('transformed document can\\'t have different _id');\n      }\n    } else {\n      transformed._id = id;\n    }\n\n    return transformed;\n  };\n\n  wrapped.__wrappedTransform__ = true;\n\n  return wrapped;\n};\n\n// XXX the sorted-query logic below is laughably inefficient. we'll\n// need to come up with a better datastructure for this.\n//\n// XXX the logic for observing with a skip or a limit is even more\n// laughably inefficient. we recompute the whole results every time!\n\n// This binary search puts a value between any equal values, and the first\n// lesser value.\nLocalCollection._binarySearch = (cmp, array, value) => {\n  let first = 0;\n  let range = array.length;\n\n  while (range > 0) {\n    const halfRange = Math.floor(range / 2);\n\n    if (cmp(value, array[first + halfRange]) >= 0) {\n      first += halfRange + 1;\n      range -= halfRange + 1;\n    } else {\n      range = halfRange;\n    }\n  }\n\n  return first;\n};\n\nLocalCollection._checkSupportedProjection = fields => {\n  if (fields !== Object(fields) || Array.isArray(fields)) {\n    throw MinimongoError('fields option must be an object');\n  }\n\n  Object.keys(fields).forEach(keyPath => {\n    if (keyPath.split('.').includes('$')) {\n      throw MinimongoError(\n        'Minimongo doesn\\'t support $ operator in projections yet.'\n      );\n    }\n\n    const value = fields[keyPath];\n\n    if (typeof value === 'object' &&\n        ['$elemMatch', '$meta', '$slice'].some(key =>\n          hasOwn.call(value, key)\n        )) {\n      throw MinimongoError(\n        'Minimongo doesn\\'t support operators in projections yet.'\n      );\n    }\n\n    if (![1, 0, true, false].includes(value)) {\n      throw MinimongoError(\n        'Projection values should be one of 1, 0, true, or false'\n      );\n    }\n  });\n};\n\n// Knows how to compile a fields projection to a predicate function.\n// @returns - Function: a closure that filters out an object according to the\n//            fields projection rules:\n//            @param obj - Object: MongoDB-styled document\n//            @returns - Object: a document with the fields filtered out\n//                       according to projection rules. Doesn't retain subfields\n//                       of passed argument.\nLocalCollection._compileProjection = fields => {\n  LocalCollection._checkSupportedProjection(fields);\n\n  const _idProjection = fields._id === undefined ? true : fields._id;\n  const details = projectionDetails(fields);\n\n  // returns transformed doc according to ruleTree\n  const transform = (doc, ruleTree) => {\n    // Special case for \"sets\"\n    if (Array.isArray(doc)) {\n      return doc.map(subdoc => transform(subdoc, ruleTree));\n    }\n\n    const result = details.including ? {} : EJSON.clone(doc);\n\n    Object.keys(ruleTree).forEach(key => {\n      if (doc == null || !hasOwn.call(doc, key)) {\n        return;\n      }\n\n      const rule = ruleTree[key];\n\n      if (rule === Object(rule)) {\n        // For sub-objects/subsets we branch\n        if (doc[key] === Object(doc[key])) {\n          result[key] = transform(doc[key], rule);\n        }\n      } else if (details.including) {\n        // Otherwise we don't even touch this subfield\n        result[key] = EJSON.clone(doc[key]);\n      } else {\n        delete result[key];\n      }\n    });\n\n    return doc != null ? result : doc;\n  };\n\n  return doc => {\n    const result = transform(doc, details.tree);\n\n    if (_idProjection && hasOwn.call(doc, '_id')) {\n      result._id = doc._id;\n    }\n\n    if (!_idProjection && hasOwn.call(result, '_id')) {\n      delete result._id;\n    }\n\n    return result;\n  };\n};\n\n// Calculates the document to insert in case we're doing an upsert and the\n// selector does not match any elements\nLocalCollection._createUpsertDocument = (selector, modifier) => {\n  const selectorDocument = populateDocumentWithQueryFields(selector);\n  const isModify = LocalCollection._isModificationMod(modifier);\n\n  const newDoc = {};\n\n  if (selectorDocument._id) {\n    newDoc._id = selectorDocument._id;\n    delete selectorDocument._id;\n  }\n\n  // This double _modify call is made to help with nested properties (see issue\n  // #8631). We do this even if it's a replacement for validation purposes (e.g.\n  // ambiguous id's)\n  LocalCollection._modify(newDoc, {$set: selectorDocument});\n  LocalCollection._modify(newDoc, modifier, {isInsert: true});\n\n  if (isModify) {\n    return newDoc;\n  }\n\n  // Replacement can take _id from query document\n  const replacement = Object.assign({}, modifier);\n  if (newDoc._id) {\n    replacement._id = newDoc._id;\n  }\n\n  return replacement;\n};\n\nLocalCollection._diffObjects = (left, right, callbacks) => {\n  return DiffSequence.diffObjects(left, right, callbacks);\n};\n\n// ordered: bool.\n// old_results and new_results: collections of documents.\n//    if ordered, they are arrays.\n//    if unordered, they are IdMaps\nLocalCollection._diffQueryChanges = (ordered, oldResults, newResults, observer, options) =>\n  DiffSequence.diffQueryChanges(ordered, oldResults, newResults, observer, options)\n;\n\nLocalCollection._diffQueryOrderedChanges = (oldResults, newResults, observer, options) =>\n  DiffSequence.diffQueryOrderedChanges(oldResults, newResults, observer, options)\n;\n\nLocalCollection._diffQueryUnorderedChanges = (oldResults, newResults, observer, options) =>\n  DiffSequence.diffQueryUnorderedChanges(oldResults, newResults, observer, options)\n;\n\nLocalCollection._findInOrderedResults = (query, doc) => {\n  if (!query.ordered) {\n    throw new Error('Can\\'t call _findInOrderedResults on unordered query');\n  }\n\n  for (let i = 0; i < query.results.length; i++) {\n    if (query.results[i] === doc) {\n      return i;\n    }\n  }\n\n  throw Error('object missing from query');\n};\n\n// If this is a selector which explicitly constrains the match by ID to a finite\n// number of documents, returns a list of their IDs.  Otherwise returns\n// null. Note that the selector may have other restrictions so it may not even\n// match those document!  We care about $in and $and since those are generated\n// access-controlled update and remove.\nLocalCollection._idsMatchedBySelector = selector => {\n  // Is the selector just an ID?\n  if (LocalCollection._selectorIsId(selector)) {\n    return [selector];\n  }\n\n  if (!selector) {\n    return null;\n  }\n\n  // Do we have an _id clause?\n  if (hasOwn.call(selector, '_id')) {\n    // Is the _id clause just an ID?\n    if (LocalCollection._selectorIsId(selector._id)) {\n      return [selector._id];\n    }\n\n    // Is the _id clause {_id: {$in: [\"x\", \"y\", \"z\"]}}?\n    if (selector._id\n        && Array.isArray(selector._id.$in)\n        && selector._id.$in.length\n        && selector._id.$in.every(LocalCollection._selectorIsId)) {\n      return selector._id.$in;\n    }\n\n    return null;\n  }\n\n  // If this is a top-level $and, and any of the clauses constrain their\n  // documents, then the whole selector is constrained by any one clause's\n  // constraint. (Well, by their intersection, but that seems unlikely.)\n  if (Array.isArray(selector.$and)) {\n    for (let i = 0; i < selector.$and.length; ++i) {\n      const subIds = LocalCollection._idsMatchedBySelector(selector.$and[i]);\n\n      if (subIds) {\n        return subIds;\n      }\n    }\n  }\n\n  return null;\n};\n\nLocalCollection._insertInResultsSync = (query, doc) => {\n  const fields = EJSON.clone(doc);\n\n  delete fields._id;\n\n  if (query.ordered) {\n    if (!query.sorter) {\n      query.addedBefore(doc._id, query.projectionFn(fields), null);\n      query.results.push(doc);\n    } else {\n      const i = LocalCollection._insertInSortedList(\n        query.sorter.getComparator({distances: query.distances}),\n        query.results,\n        doc\n      );\n\n      let next = query.results[i + 1];\n      if (next) {\n        next = next._id;\n      } else {\n        next = null;\n      }\n\n      query.addedBefore(doc._id, query.projectionFn(fields), next);\n    }\n\n    query.added(doc._id, query.projectionFn(fields));\n  } else {\n    query.added(doc._id, query.projectionFn(fields));\n    query.results.set(doc._id, doc);\n  }\n};\n\nLocalCollection._insertInResultsAsync = async (query, doc) => {\n  const fields = EJSON.clone(doc);\n\n  delete fields._id;\n\n  if (query.ordered) {\n    if (!query.sorter) {\n      await query.addedBefore(doc._id, query.projectionFn(fields), null);\n      query.results.push(doc);\n    } else {\n      const i = LocalCollection._insertInSortedList(\n        query.sorter.getComparator({distances: query.distances}),\n        query.results,\n        doc\n      );\n\n      let next = query.results[i + 1];\n      if (next) {\n        next = next._id;\n      } else {\n        next = null;\n      }\n\n      await query.addedBefore(doc._id, query.projectionFn(fields), next);\n    }\n\n    await query.added(doc._id, query.projectionFn(fields));\n  } else {\n    await query.added(doc._id, query.projectionFn(fields));\n    query.results.set(doc._id, doc);\n  }\n};\n\nLocalCollection._insertInSortedList = (cmp, array, value) => {\n  if (array.length === 0) {\n    array.push(value);\n    return 0;\n  }\n\n  const i = LocalCollection._binarySearch(cmp, array, value);\n\n  array.splice(i, 0, value);\n\n  return i;\n};\n\nLocalCollection._isModificationMod = mod => {\n  let isModify = false;\n  let isReplace = false;\n\n  Object.keys(mod).forEach(key => {\n    if (key.substr(0, 1) === '$') {\n      isModify = true;\n    } else {\n      isReplace = true;\n    }\n  });\n\n  if (isModify && isReplace) {\n    throw new Error(\n      'Update parameter cannot have both modifier and non-modifier fields.'\n    );\n  }\n\n  return isModify;\n};\n\n// XXX maybe this should be EJSON.isObject, though EJSON doesn't know about\n// RegExp\n// XXX note that _type(undefined) === 3!!!!\nLocalCollection._isPlainObject = x => {\n  return x && LocalCollection._f._type(x) === 3;\n};\n\n// XXX need a strategy for passing the binding of $ into this\n// function, from the compiled selector\n//\n// maybe just {key.up.to.just.before.dollarsign: array_index}\n//\n// XXX atomicity: if one modification fails, do we roll back the whole\n// change?\n//\n// options:\n//   - isInsert is set when _modify is being called to compute the document to\n//     insert as part of an upsert operation. We use this primarily to figure\n//     out when to set the fields in $setOnInsert, if present.\nLocalCollection._modify = (doc, modifier, options = {}) => {\n  if (!LocalCollection._isPlainObject(modifier)) {\n    throw MinimongoError('Modifier must be an object');\n  }\n\n  // Make sure the caller can't mutate our data structures.\n  modifier = EJSON.clone(modifier);\n\n  const isModifier = isOperatorObject(modifier);\n  const newDoc = isModifier ? EJSON.clone(doc) : modifier;\n\n  if (isModifier) {\n    // apply modifiers to the doc.\n    Object.keys(modifier).forEach(operator => {\n      // Treat $setOnInsert as $set if this is an insert.\n      const setOnInsert = options.isInsert && operator === '$setOnInsert';\n      const modFunc = MODIFIERS[setOnInsert ? '$set' : operator];\n      const operand = modifier[operator];\n\n      if (!modFunc) {\n        throw MinimongoError(`Invalid modifier specified ${operator}`);\n      }\n\n      Object.keys(operand).forEach(keypath => {\n        const arg = operand[keypath];\n\n        if (keypath === '') {\n          throw MinimongoError('An empty update path is not valid.');\n        }\n\n        const keyparts = keypath.split('.');\n\n        if (!keyparts.every(Boolean)) {\n          throw MinimongoError(\n            `The update path '${keypath}' contains an empty field name, ` +\n            'which is not allowed.'\n          );\n        }\n\n        const target = findModTarget(newDoc, keyparts, {\n          arrayIndices: options.arrayIndices,\n          forbidArray: operator === '$rename',\n          noCreate: NO_CREATE_MODIFIERS[operator]\n        });\n\n        modFunc(target, keyparts.pop(), arg, keypath, newDoc);\n      });\n    });\n\n    if (doc._id && !EJSON.equals(doc._id, newDoc._id)) {\n      throw MinimongoError(\n        `After applying the update to the document {_id: \"${doc._id}\", ...},` +\n        ' the (immutable) field \\'_id\\' was found to have been altered to ' +\n        `_id: \"${newDoc._id}\"`\n      );\n    }\n  } else {\n    if (doc._id && modifier._id && !EJSON.equals(doc._id, modifier._id)) {\n      throw MinimongoError(\n        `The _id field cannot be changed from {_id: \"${doc._id}\"} to ` +\n        `{_id: \"${modifier._id}\"}`\n      );\n    }\n\n    // replace the whole document\n    assertHasValidFieldNames(modifier);\n  }\n\n  // move new document into place.\n  Object.keys(doc).forEach(key => {\n    // Note: this used to be for (var key in doc) however, this does not\n    // work right in Opera. Deleting from a doc while iterating over it\n    // would sometimes cause opera to skip some keys.\n    if (key !== '_id') {\n      delete doc[key];\n    }\n  });\n\n  Object.keys(newDoc).forEach(key => {\n    doc[key] = newDoc[key];\n  });\n};\n\nLocalCollection._observeFromObserveChanges = (cursor, observeCallbacks) => {\n  const transform = cursor.getTransform() || (doc => doc);\n  let suppressed = !!observeCallbacks._suppress_initial;\n\n  let observeChangesCallbacks;\n  if (LocalCollection._observeCallbacksAreOrdered(observeCallbacks)) {\n    // The \"_no_indices\" option sets all index arguments to -1 and skips the\n    // linear scans required to generate them.  This lets observers that don't\n    // need absolute indices benefit from the other features of this API --\n    // relative order, transforms, and applyChanges -- without the speed hit.\n    const indices = !observeCallbacks._no_indices;\n\n    observeChangesCallbacks = {\n      addedBefore(id, fields, before) {\n        const check = suppressed || !(observeCallbacks.addedAt || observeCallbacks.added)\n        if (check) {\n          return;\n        }\n\n        const doc = transform(Object.assign(fields, {_id: id}));\n\n        if (observeCallbacks.addedAt) {\n          observeCallbacks.addedAt(\n              doc,\n              indices\n                  ? before\n                      ? this.docs.indexOf(before)\n                      : this.docs.size()\n                  : -1,\n              before\n          );\n        } else {\n          observeCallbacks.added(doc);\n        }\n      },\n      changed(id, fields) {\n\n        if (!(observeCallbacks.changedAt || observeCallbacks.changed)) {\n          return;\n        }\n\n        let doc = EJSON.clone(this.docs.get(id));\n        if (!doc) {\n          throw new Error(`Unknown id for changed: ${id}`);\n        }\n\n        const oldDoc = transform(EJSON.clone(doc));\n\n        DiffSequence.applyChanges(doc, fields);\n\n        if (observeCallbacks.changedAt) {\n          observeCallbacks.changedAt(\n              transform(doc),\n              oldDoc,\n              indices ? this.docs.indexOf(id) : -1\n          );\n        } else {\n          observeCallbacks.changed(transform(doc), oldDoc);\n        }\n      },\n      movedBefore(id, before) {\n        if (!observeCallbacks.movedTo) {\n          return;\n        }\n\n        const from = indices ? this.docs.indexOf(id) : -1;\n        let to = indices\n            ? before\n                ? this.docs.indexOf(before)\n                : this.docs.size()\n            : -1;\n\n        // When not moving backwards, adjust for the fact that removing the\n        // document slides everything back one slot.\n        if (to > from) {\n          --to;\n        }\n\n        observeCallbacks.movedTo(\n            transform(EJSON.clone(this.docs.get(id))),\n            from,\n            to,\n            before || null\n        );\n      },\n      removed(id) {\n        if (!(observeCallbacks.removedAt || observeCallbacks.removed)) {\n          return;\n        }\n\n        // technically maybe there should be an EJSON.clone here, but it's about\n        // to be removed from this.docs!\n        const doc = transform(this.docs.get(id));\n\n        if (observeCallbacks.removedAt) {\n          observeCallbacks.removedAt(doc, indices ? this.docs.indexOf(id) : -1);\n        } else {\n          observeCallbacks.removed(doc);\n        }\n      },\n    };\n  } else {\n    observeChangesCallbacks = {\n      added(id, fields) {\n        if (!suppressed && observeCallbacks.added) {\n          observeCallbacks.added(transform(Object.assign(fields, {_id: id})));\n        }\n      },\n      changed(id, fields) {\n        if (observeCallbacks.changed) {\n          const oldDoc = this.docs.get(id);\n          const doc = EJSON.clone(oldDoc);\n\n          DiffSequence.applyChanges(doc, fields);\n\n          observeCallbacks.changed(\n              transform(doc),\n              transform(EJSON.clone(oldDoc))\n          );\n        }\n      },\n      removed(id) {\n        if (observeCallbacks.removed) {\n          observeCallbacks.removed(transform(this.docs.get(id)));\n        }\n      },\n    };\n  }\n\n  const changeObserver = new LocalCollection._CachingChangeObserver({\n    callbacks: observeChangesCallbacks\n  });\n\n  // CachingChangeObserver clones all received input on its callbacks\n  // So we can mark it as safe to reduce the ejson clones.\n  // This is tested by the `mongo-livedata - (extended) scribbling` tests\n  changeObserver.applyChange._fromObserve = true;\n  const handle = cursor.observeChanges(changeObserver.applyChange,\n      { nonMutatingCallbacks: true });\n\n  // If needed, re-enable callbacks as soon as the initial batch is ready.\n  const setSuppressed = (h) => {\n    if (h.isReady) suppressed = false;\n    else h.isReadyPromise?.then(() => (suppressed = false));\n  };\n  // When we call cursor.observeChanges() it can be the on from\n  // the mongo package (instead of the minimongo one) and it doesn't have isReady and isReadyPromise\n  if (Meteor._isPromise(handle)) {\n    handle.then(setSuppressed);\n  } else {\n    setSuppressed(handle);\n  }\n  return handle;\n};\n\nLocalCollection._observeCallbacksAreOrdered = callbacks => {\n  if (callbacks.added && callbacks.addedAt) {\n    throw new Error('Please specify only one of added() and addedAt()');\n  }\n\n  if (callbacks.changed && callbacks.changedAt) {\n    throw new Error('Please specify only one of changed() and changedAt()');\n  }\n\n  if (callbacks.removed && callbacks.removedAt) {\n    throw new Error('Please specify only one of removed() and removedAt()');\n  }\n\n  return !!(\n    callbacks.addedAt ||\n    callbacks.changedAt ||\n    callbacks.movedTo ||\n    callbacks.removedAt\n  );\n};\n\nLocalCollection._observeChangesCallbacksAreOrdered = callbacks => {\n  if (callbacks.added && callbacks.addedBefore) {\n    throw new Error('Please specify only one of added() and addedBefore()');\n  }\n\n  return !!(callbacks.addedBefore || callbacks.movedBefore);\n};\n\nLocalCollection._removeFromResultsSync = (query, doc) => {\n  if (query.ordered) {\n    const i = LocalCollection._findInOrderedResults(query, doc);\n\n    query.removed(doc._id);\n    query.results.splice(i, 1);\n  } else {\n    const id = doc._id;  // in case callback mutates doc\n\n    query.removed(doc._id);\n    query.results.remove(id);\n  }\n};\n\nLocalCollection._removeFromResultsAsync = async (query, doc) => {\n  if (query.ordered) {\n    const i = LocalCollection._findInOrderedResults(query, doc);\n\n    await query.removed(doc._id);\n    query.results.splice(i, 1);\n  } else {\n    const id = doc._id;  // in case callback mutates doc\n\n    await query.removed(doc._id);\n    query.results.remove(id);\n  }\n};\n\n// Is this selector just shorthand for lookup by _id?\nLocalCollection._selectorIsId = selector =>\n  typeof selector === 'number' ||\n  typeof selector === 'string' ||\n  selector instanceof MongoID.ObjectID\n;\n\n// Is the selector just lookup by _id (shorthand or not)?\nLocalCollection._selectorIsIdPerhapsAsObject = selector =>\n  LocalCollection._selectorIsId(selector) ||\n  LocalCollection._selectorIsId(selector && selector._id) &&\n  Object.keys(selector).length === 1\n;\n\nLocalCollection._updateInResultsSync = (query, doc, old_doc) => {\n  if (!EJSON.equals(doc._id, old_doc._id)) {\n    throw new Error('Can\\'t change a doc\\'s _id while updating');\n  }\n\n  const projectionFn = query.projectionFn;\n  const changedFields = DiffSequence.makeChangedFields(\n    projectionFn(doc),\n    projectionFn(old_doc)\n  );\n\n  if (!query.ordered) {\n    if (Object.keys(changedFields).length) {\n      query.changed(doc._id, changedFields);\n      query.results.set(doc._id, doc);\n    }\n\n    return;\n  }\n\n  const old_idx = LocalCollection._findInOrderedResults(query, doc);\n\n  if (Object.keys(changedFields).length) {\n    query.changed(doc._id, changedFields);\n  }\n\n  if (!query.sorter) {\n    return;\n  }\n\n  // just take it out and put it back in again, and see if the index changes\n  query.results.splice(old_idx, 1);\n\n  const new_idx = LocalCollection._insertInSortedList(\n    query.sorter.getComparator({distances: query.distances}),\n    query.results,\n    doc\n  );\n\n  if (old_idx !== new_idx) {\n    let next = query.results[new_idx + 1];\n    if (next) {\n      next = next._id;\n    } else {\n      next = null;\n    }\n\n    query.movedBefore && query.movedBefore(doc._id, next);\n  }\n};\n\nLocalCollection._updateInResultsAsync = async (query, doc, old_doc) => {\n  if (!EJSON.equals(doc._id, old_doc._id)) {\n    throw new Error('Can\\'t change a doc\\'s _id while updating');\n  }\n\n  const projectionFn = query.projectionFn;\n  const changedFields = DiffSequence.makeChangedFields(\n    projectionFn(doc),\n    projectionFn(old_doc)\n  );\n\n  if (!query.ordered) {\n    if (Object.keys(changedFields).length) {\n      await query.changed(doc._id, changedFields);\n      query.results.set(doc._id, doc);\n    }\n\n    return;\n  }\n\n  const old_idx = LocalCollection._findInOrderedResults(query, doc);\n\n  if (Object.keys(changedFields).length) {\n    await query.changed(doc._id, changedFields);\n  }\n\n  if (!query.sorter) {\n    return;\n  }\n\n  // just take it out and put it back in again, and see if the index changes\n  query.results.splice(old_idx, 1);\n\n  const new_idx = LocalCollection._insertInSortedList(\n    query.sorter.getComparator({distances: query.distances}),\n    query.results,\n    doc\n  );\n\n  if (old_idx !== new_idx) {\n    let next = query.results[new_idx + 1];\n    if (next) {\n      next = next._id;\n    } else {\n      next = null;\n    }\n\n    query.movedBefore && await query.movedBefore(doc._id, next);\n  }\n};\n\nconst MODIFIERS = {\n  $currentDate(target, field, arg) {\n    if (typeof arg === 'object' && hasOwn.call(arg, '$type')) {\n      if (arg.$type !== 'date') {\n        throw MinimongoError(\n          'Minimongo does currently only support the date type in ' +\n          '$currentDate modifiers',\n          {field}\n        );\n      }\n    } else if (arg !== true) {\n      throw MinimongoError('Invalid $currentDate modifier', {field});\n    }\n\n    target[field] = new Date();\n  },\n  $inc(target, field, arg) {\n    if (typeof arg !== 'number') {\n      throw MinimongoError('Modifier $inc allowed for numbers only', {field});\n    }\n\n    if (field in target) {\n      if (typeof target[field] !== 'number') {\n        throw MinimongoError(\n          'Cannot apply $inc modifier to non-number',\n          {field}\n        );\n      }\n\n      target[field] += arg;\n    } else {\n      target[field] = arg;\n    }\n  },\n  $min(target, field, arg) {\n    if (typeof arg !== 'number') {\n      throw MinimongoError('Modifier $min allowed for numbers only', {field});\n    }\n\n    if (field in target) {\n      if (typeof target[field] !== 'number') {\n        throw MinimongoError(\n          'Cannot apply $min modifier to non-number',\n          {field}\n        );\n      }\n\n      if (target[field] > arg) {\n        target[field] = arg;\n      }\n    } else {\n      target[field] = arg;\n    }\n  },\n  $max(target, field, arg) {\n    if (typeof arg !== 'number') {\n      throw MinimongoError('Modifier $max allowed for numbers only', {field});\n    }\n\n    if (field in target) {\n      if (typeof target[field] !== 'number') {\n        throw MinimongoError(\n          'Cannot apply $max modifier to non-number',\n          {field}\n        );\n      }\n\n      if (target[field] < arg) {\n        target[field] = arg;\n      }\n    } else {\n      target[field] = arg;\n    }\n  },\n  $mul(target, field, arg) {\n    if (typeof arg !== 'number') {\n      throw MinimongoError('Modifier $mul allowed for numbers only', {field});\n    }\n\n    if (field in target) {\n      if (typeof target[field] !== 'number') {\n        throw MinimongoError(\n          'Cannot apply $mul modifier to non-number',\n          {field}\n        );\n      }\n\n      target[field] *= arg;\n    } else {\n      target[field] = 0;\n    }\n  },\n  $rename(target, field, arg, keypath, doc) {\n    // no idea why mongo has this restriction..\n    if (keypath === arg) {\n      throw MinimongoError('$rename source must differ from target', {field});\n    }\n\n    if (target === null) {\n      throw MinimongoError('$rename source field invalid', {field});\n    }\n\n    if (typeof arg !== 'string') {\n      throw MinimongoError('$rename target must be a string', {field});\n    }\n\n    if (arg.includes('\\0')) {\n      // Null bytes are not allowed in Mongo field names\n      // https://docs.mongodb.com/manual/reference/limits/#Restrictions-on-Field-Names\n      throw MinimongoError(\n        'The \\'to\\' field for $rename cannot contain an embedded null byte',\n        {field}\n      );\n    }\n\n    if (target === undefined) {\n      return;\n    }\n\n    const object = target[field];\n\n    delete target[field];\n\n    const keyparts = arg.split('.');\n    const target2 = findModTarget(doc, keyparts, {forbidArray: true});\n\n    if (target2 === null) {\n      throw MinimongoError('$rename target field invalid', {field});\n    }\n\n    target2[keyparts.pop()] = object;\n  },\n  $set(target, field, arg) {\n    if (target !== Object(target)) { // not an array or an object\n      const error = MinimongoError(\n        'Cannot set property on non-object field',\n        {field}\n      );\n      error.setPropertyError = true;\n      throw error;\n    }\n\n    if (target === null) {\n      const error = MinimongoError('Cannot set property on null', {field});\n      error.setPropertyError = true;\n      throw error;\n    }\n\n    assertHasValidFieldNames(arg);\n\n    target[field] = arg;\n  },\n  $setOnInsert(target, field, arg) {\n    // converted to `$set` in `_modify`\n  },\n  $unset(target, field, arg) {\n    if (target !== undefined) {\n      if (target instanceof Array) {\n        if (field in target) {\n          target[field] = null;\n        }\n      } else {\n        delete target[field];\n      }\n    }\n  },\n  $push(target, field, arg) {\n    if (target[field] === undefined) {\n      target[field] = [];\n    }\n\n    if (!(target[field] instanceof Array)) {\n      throw MinimongoError('Cannot apply $push modifier to non-array', {field});\n    }\n\n    if (!(arg && arg.$each)) {\n      // Simple mode: not $each\n      assertHasValidFieldNames(arg);\n\n      target[field].push(arg);\n\n      return;\n    }\n\n    // Fancy mode: $each (and maybe $slice and $sort and $position)\n    const toPush = arg.$each;\n    if (!(toPush instanceof Array)) {\n      throw MinimongoError('$each must be an array', {field});\n    }\n\n    assertHasValidFieldNames(toPush);\n\n    // Parse $position\n    let position = undefined;\n    if ('$position' in arg) {\n      if (typeof arg.$position !== 'number') {\n        throw MinimongoError('$position must be a numeric value', {field});\n      }\n\n      // XXX should check to make sure integer\n      if (arg.$position < 0) {\n        throw MinimongoError(\n          '$position in $push must be zero or positive',\n          {field}\n        );\n      }\n\n      position = arg.$position;\n    }\n\n    // Parse $slice.\n    let slice = undefined;\n    if ('$slice' in arg) {\n      if (typeof arg.$slice !== 'number') {\n        throw MinimongoError('$slice must be a numeric value', {field});\n      }\n\n      // XXX should check to make sure integer\n      slice = arg.$slice;\n    }\n\n    // Parse $sort.\n    let sortFunction = undefined;\n    if (arg.$sort) {\n      if (slice === undefined) {\n        throw MinimongoError('$sort requires $slice to be present', {field});\n      }\n\n      // XXX this allows us to use a $sort whose value is an array, but that's\n      // actually an extension of the Node driver, so it won't work\n      // server-side. Could be confusing!\n      // XXX is it correct that we don't do geo-stuff here?\n      sortFunction = new Minimongo.Sorter(arg.$sort).getComparator();\n\n      toPush.forEach(element => {\n        if (LocalCollection._f._type(element) !== 3) {\n          throw MinimongoError(\n            '$push like modifiers using $sort require all elements to be ' +\n            'objects',\n            {field}\n          );\n        }\n      });\n    }\n\n    // Actually push.\n    if (position === undefined) {\n      toPush.forEach(element => {\n        target[field].push(element);\n      });\n    } else {\n      const spliceArguments = [position, 0];\n\n      toPush.forEach(element => {\n        spliceArguments.push(element);\n      });\n\n      target[field].splice(...spliceArguments);\n    }\n\n    // Actually sort.\n    if (sortFunction) {\n      target[field].sort(sortFunction);\n    }\n\n    // Actually slice.\n    if (slice !== undefined) {\n      if (slice === 0) {\n        target[field] = []; // differs from Array.slice!\n      } else if (slice < 0) {\n        target[field] = target[field].slice(slice);\n      } else {\n        target[field] = target[field].slice(0, slice);\n      }\n    }\n  },\n  $pushAll(target, field, arg) {\n    if (!(typeof arg === 'object' && arg instanceof Array)) {\n      throw MinimongoError('Modifier $pushAll/pullAll allowed for arrays only');\n    }\n\n    assertHasValidFieldNames(arg);\n\n    const toPush = target[field];\n\n    if (toPush === undefined) {\n      target[field] = arg;\n    } else if (!(toPush instanceof Array)) {\n      throw MinimongoError(\n        'Cannot apply $pushAll modifier to non-array',\n        {field}\n      );\n    } else {\n      toPush.push(...arg);\n    }\n  },\n  $addToSet(target, field, arg) {\n    let isEach = false;\n\n    if (typeof arg === 'object') {\n      // check if first key is '$each'\n      const keys = Object.keys(arg);\n      if (keys[0] === '$each') {\n        isEach = true;\n      }\n    }\n\n    const values = isEach ? arg.$each : [arg];\n\n    assertHasValidFieldNames(values);\n\n    const toAdd = target[field];\n    if (toAdd === undefined) {\n      target[field] = values;\n    } else if (!(toAdd instanceof Array)) {\n      throw MinimongoError(\n        'Cannot apply $addToSet modifier to non-array',\n        {field}\n      );\n    } else {\n      values.forEach(value => {\n        if (toAdd.some(element => LocalCollection._f._equal(value, element))) {\n          return;\n        }\n\n        toAdd.push(value);\n      });\n    }\n  },\n  $pop(target, field, arg) {\n    if (target === undefined) {\n      return;\n    }\n\n    const toPop = target[field];\n\n    if (toPop === undefined) {\n      return;\n    }\n\n    if (!(toPop instanceof Array)) {\n      throw MinimongoError('Cannot apply $pop modifier to non-array', {field});\n    }\n\n    if (typeof arg === 'number' && arg < 0) {\n      toPop.splice(0, 1);\n    } else {\n      toPop.pop();\n    }\n  },\n  $pull(target, field, arg) {\n    if (target === undefined) {\n      return;\n    }\n\n    const toPull = target[field];\n    if (toPull === undefined) {\n      return;\n    }\n\n    if (!(toPull instanceof Array)) {\n      throw MinimongoError(\n        'Cannot apply $pull/pullAll modifier to non-array',\n        {field}\n      );\n    }\n\n    let out;\n    if (arg != null && typeof arg === 'object' && !(arg instanceof Array)) {\n      // XXX would be much nicer to compile this once, rather than\n      // for each document we modify.. but usually we're not\n      // modifying that many documents, so we'll let it slide for\n      // now\n\n      // XXX Minimongo.Matcher isn't up for the job, because we need\n      // to permit stuff like {$pull: {a: {$gt: 4}}}.. something\n      // like {$gt: 4} is not normally a complete selector.\n      // same issue as $elemMatch possibly?\n      const matcher = new Minimongo.Matcher(arg);\n\n      out = toPull.filter(element => !matcher.documentMatches(element).result);\n    } else {\n      out = toPull.filter(element => !LocalCollection._f._equal(element, arg));\n    }\n\n    target[field] = out;\n  },\n  $pullAll(target, field, arg) {\n    if (!(typeof arg === 'object' && arg instanceof Array)) {\n      throw MinimongoError(\n        'Modifier $pushAll/pullAll allowed for arrays only',\n        {field}\n      );\n    }\n\n    if (target === undefined) {\n      return;\n    }\n\n    const toPull = target[field];\n\n    if (toPull === undefined) {\n      return;\n    }\n\n    if (!(toPull instanceof Array)) {\n      throw MinimongoError(\n        'Cannot apply $pull/pullAll modifier to non-array',\n        {field}\n      );\n    }\n\n    target[field] = toPull.filter(object =>\n      !arg.some(element => LocalCollection._f._equal(object, element))\n    );\n  },\n  $bit(target, field, arg) {\n    // XXX mongo only supports $bit on integers, and we only support\n    // native javascript numbers (doubles) so far, so we can't support $bit\n    throw MinimongoError('$bit is not supported', {field});\n  },\n  $v() {\n    // As discussed in https://github.com/meteor/meteor/issues/9623,\n    // the `$v` operator is not needed by Meteor, but problems can occur if\n    // it's not at least callable (as of Mongo >= 3.6). It's defined here as\n    // a no-op to work around these problems.\n  }\n};\n\nconst NO_CREATE_MODIFIERS = {\n  $pop: true,\n  $pull: true,\n  $pullAll: true,\n  $rename: true,\n  $unset: true\n};\n\n// Make sure field names do not contain Mongo restricted\n// characters ('.', '$', '\\0').\n// https://docs.mongodb.com/manual/reference/limits/#Restrictions-on-Field-Names\nconst invalidCharMsg = {\n  $: 'start with \\'$\\'',\n  '.': 'contain \\'.\\'',\n  '\\0': 'contain null bytes'\n};\n\n// checks if all field names in an object are valid\nfunction assertHasValidFieldNames(doc) {\n  if (doc && typeof doc === 'object') {\n    JSON.stringify(doc, (key, value) => {\n      assertIsValidFieldName(key);\n      return value;\n    });\n  }\n}\n\nfunction assertIsValidFieldName(key) {\n  let match;\n  if (typeof key === 'string' && (match = key.match(/^\\$|\\.|\\0/))) {\n    throw MinimongoError(`Key ${key} must not ${invalidCharMsg[match[0]]}`);\n  }\n}\n\n// for a.b.c.2.d.e, keyparts should be ['a', 'b', 'c', '2', 'd', 'e'],\n// and then you would operate on the 'e' property of the returned\n// object.\n//\n// if options.noCreate is falsey, creates intermediate levels of\n// structure as necessary, like mkdir -p (and raises an exception if\n// that would mean giving a non-numeric property to an array.) if\n// options.noCreate is true, return undefined instead.\n//\n// may modify the last element of keyparts to signal to the caller that it needs\n// to use a different value to index into the returned object (for example,\n// ['a', '01'] -> ['a', 1]).\n//\n// if forbidArray is true, return null if the keypath goes through an array.\n//\n// if options.arrayIndices is set, use its first element for the (first) '$' in\n// the path.\nfunction findModTarget(doc, keyparts, options = {}) {\n  let usedArrayIndex = false;\n\n  for (let i = 0; i < keyparts.length; i++) {\n    const last = i === keyparts.length - 1;\n    let keypart = keyparts[i];\n\n    if (!isIndexable(doc)) {\n      if (options.noCreate) {\n        return undefined;\n      }\n\n      const error = MinimongoError(\n        `cannot use the part '${keypart}' to traverse ${doc}`\n      );\n      error.setPropertyError = true;\n      throw error;\n    }\n\n    if (doc instanceof Array) {\n      if (options.forbidArray) {\n        return null;\n      }\n\n      if (keypart === '$') {\n        if (usedArrayIndex) {\n          throw MinimongoError('Too many positional (i.e. \\'$\\') elements');\n        }\n\n        if (!options.arrayIndices || !options.arrayIndices.length) {\n          throw MinimongoError(\n            'The positional operator did not find the match needed from the ' +\n            'query'\n          );\n        }\n\n        keypart = options.arrayIndices[0];\n        usedArrayIndex = true;\n      } else if (isNumericKey(keypart)) {\n        keypart = parseInt(keypart);\n      } else {\n        if (options.noCreate) {\n          return undefined;\n        }\n\n        throw MinimongoError(\n          `can't append to array using string field name [${keypart}]`\n        );\n      }\n\n      if (last) {\n        keyparts[i] = keypart; // handle 'a.01'\n      }\n\n      if (options.noCreate && keypart >= doc.length) {\n        return undefined;\n      }\n\n      while (doc.length < keypart) {\n        doc.push(null);\n      }\n\n      if (!last) {\n        if (doc.length === keypart) {\n          doc.push({});\n        } else if (typeof doc[keypart] !== 'object') {\n          throw MinimongoError(\n            `can't modify field '${keyparts[i + 1]}' of list value ` +\n            JSON.stringify(doc[keypart])\n          );\n        }\n      }\n    } else {\n      assertIsValidFieldName(keypart);\n\n      if (!(keypart in doc)) {\n        if (options.noCreate) {\n          return undefined;\n        }\n\n        if (!last) {\n          doc[keypart] = {};\n        }\n      }\n    }\n\n    if (last) {\n      return doc;\n    }\n\n    doc = doc[keypart];\n  }\n\n  // notreached\n}\n"],"mappings":"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","ignoreList":[]},"sourceType":"module","externalDependencies":{},"hash":"7f4ce066451f93aa42cfbb416a9658127ca2b7ef"}
