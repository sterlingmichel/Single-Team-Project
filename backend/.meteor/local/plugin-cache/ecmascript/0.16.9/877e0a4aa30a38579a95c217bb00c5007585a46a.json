{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/Users/smichel/Projects/Team-5-Project/database/packages/mongo/oplog_tailing.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","topLevelAwait","objectRestSpread","objectRestSpread","asyncGenerators","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"os.osx.arm64"},"sourceFileName":"packages/mongo/oplog_tailing.js","filename":"/Users/smichel/Projects/Team-5-Project/database/packages/mongo/oplog_tailing.js","targets":{},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"/Users/smichel/Projects/Team-5-Project/database","root":"/Users/smichel/Projects/Team-5-Project/database","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":false,"enforceStrictMode":false,"dynamicImport":true,"generateLetDeclarations":true,"topLevelAwait":true},"externalDependencies":[]},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"version":"7.17.2","helpers":true,"useESModules":false,"corejs":false},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-react-jsx","visitor":{"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXFragment":{"exit":[null]},"JSXElement":{"exit":[null]},"JSXAttribute":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false},"externalDependencies":[]},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-nullish-coalescing-operator","visitor":{"LogicalExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-chaining","visitor":{"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-catch-binding","visitor":{"CatchClause":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-logical-assignment-operators","visitor":{"AssignmentExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]}],"presets":[],"generatorOpts":{"filename":"/Users/smichel/Projects/Team-5-Project/database/packages/mongo/oplog_tailing.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/mongo/oplog_tailing.js"}},"code":"!module.wrapAsync(async function (module, __reifyWaitForDeps__, __reify_async_result__) {\n  \"use strict\";\n  try {\n    let isEmpty;\n    module.link(\"lodash.isempty\", {\n      default(v) {\n        isEmpty = v;\n      }\n    }, 0);\n    let has;\n    module.link(\"lodash.has\", {\n      default(v) {\n        has = v;\n      }\n    }, 1);\n    let NpmModuleMongodb;\n    module.link(\"meteor/npm-mongo\", {\n      NpmModuleMongodb(v) {\n        NpmModuleMongodb = v;\n      }\n    }, 2);\n    if (__reifyWaitForDeps__()) (await __reifyWaitForDeps__())();\n    const {\n      Long\n    } = NpmModuleMongodb;\n    OPLOG_COLLECTION = 'oplog.rs';\n    var TOO_FAR_BEHIND = process.env.METEOR_OPLOG_TOO_FAR_BEHIND || 2000;\n    var TAIL_TIMEOUT = +process.env.METEOR_OPLOG_TAIL_TIMEOUT || 30000;\n    idForOp = function (op) {\n      if (op.op === 'd') return op.o._id;else if (op.op === 'i') return op.o._id;else if (op.op === 'u') return op.o2._id;else if (op.op === 'c') throw Error(\"Operator 'c' doesn't supply an object with id: \" + EJSON.stringify(op));else throw Error(\"Unknown op: \" + EJSON.stringify(op));\n    };\n    OplogHandle = function (oplogUrl, dbName) {\n      var self = this;\n      self._oplogUrl = oplogUrl;\n      self._dbName = dbName;\n      self._oplogLastEntryConnection = null;\n      self._oplogTailConnection = null;\n      self._oplogOptions = null;\n      self._stopped = false;\n      self._tailHandle = null;\n      self._readyPromiseResolver = null;\n      self._readyPromise = new Promise(r => self._readyPromiseResolver = r);\n      self._crossbar = new DDPServer._Crossbar({\n        factPackage: \"mongo-livedata\",\n        factName: \"oplog-watchers\"\n      });\n      self._baseOplogSelector = {\n        ns: new RegExp(\"^(?:\" + [Meteor._escapeRegExp(self._dbName + \".\"), Meteor._escapeRegExp(\"admin.$cmd\")].join(\"|\") + \")\"),\n        $or: [{\n          op: {\n            $in: ['i', 'u', 'd']\n          }\n        },\n        // drop collection\n        {\n          op: 'c',\n          'o.drop': {\n            $exists: true\n          }\n        }, {\n          op: 'c',\n          'o.dropDatabase': 1\n        }, {\n          op: 'c',\n          'o.applyOps': {\n            $exists: true\n          }\n        }]\n      };\n\n      // Data structures to support waitUntilCaughtUp(). Each oplog entry has a\n      // MongoTimestamp object on it (which is not the same as a Date --- it's a\n      // combination of time and an incrementing counter; see\n      // http://docs.mongodb.org/manual/reference/bson-types/#timestamps).\n      //\n      // _catchingUpFutures is an array of {ts: MongoTimestamp, future: Future}\n      // objects, sorted by ascending timestamp. _lastProcessedTS is the\n      // MongoTimestamp of the last oplog entry we've processed.\n      //\n      // Each time we call waitUntilCaughtUp, we take a peek at the final oplog\n      // entry in the db.  If we've already processed it (ie, it is not greater than\n      // _lastProcessedTS), waitUntilCaughtUp immediately returns. Otherwise,\n      // waitUntilCaughtUp makes a new Future and inserts it along with the final\n      // timestamp entry that it read, into _catchingUpFutures. waitUntilCaughtUp\n      // then waits on that future, which is resolved once _lastProcessedTS is\n      // incremented to be past its timestamp by the worker fiber.\n      //\n      // XXX use a priority queue or something else that's faster than an array\n      self._catchingUpResolvers = [];\n      self._lastProcessedTS = null;\n      self._onSkippedEntriesHook = new Hook({\n        debugPrintExceptions: \"onSkippedEntries callback\"\n      });\n      self._entryQueue = new Meteor._DoubleEndedQueue();\n      self._workerActive = false;\n      self._startTrailingPromise = self._startTailing();\n      //TODO[fibers] Why wait?\n    };\n    MongoInternals.OplogHandle = OplogHandle;\n    Object.assign(OplogHandle.prototype, {\n      stop: async function () {\n        var self = this;\n        if (self._stopped) return;\n        self._stopped = true;\n        if (self._tailHandle) await self._tailHandle.stop();\n        // XXX should close connections too\n      },\n      _onOplogEntry: async function (trigger, callback) {\n        var self = this;\n        if (self._stopped) throw new Error(\"Called onOplogEntry on stopped handle!\");\n\n        // Calling onOplogEntry requires us to wait for the tailing to be ready.\n        await self._readyPromise;\n        var originalCallback = callback;\n        callback = Meteor.bindEnvironment(function (notification) {\n          originalCallback(notification);\n        }, function (err) {\n          Meteor._debug(\"Error in oplog callback\", err);\n        });\n        var listenHandle = self._crossbar.listen(trigger, callback);\n        return {\n          stop: async function () {\n            await listenHandle.stop();\n          }\n        };\n      },\n      onOplogEntry: function (trigger, callback) {\n        return this._onOplogEntry(trigger, callback);\n      },\n      // Register a callback to be invoked any time we skip oplog entries (eg,\n      // because we are too far behind).\n      onSkippedEntries: function (callback) {\n        var self = this;\n        if (self._stopped) throw new Error(\"Called onSkippedEntries on stopped handle!\");\n        return self._onSkippedEntriesHook.register(callback);\n      },\n      async _waitUntilCaughtUp() {\n        var self = this;\n        if (self._stopped) throw new Error(\"Called waitUntilCaughtUp on stopped handle!\");\n\n        // Calling waitUntilCaughtUp requries us to wait for the oplog connection to\n        // be ready.\n        await self._readyPromise;\n        var lastEntry;\n        while (!self._stopped) {\n          // We need to make the selector at least as restrictive as the actual\n          // tailing selector (ie, we need to specify the DB name) or else we might\n          // find a TS that won't show up in the actual tail stream.\n          try {\n            lastEntry = await self._oplogLastEntryConnection.findOneAsync(OPLOG_COLLECTION, self._baseOplogSelector, {\n              projection: {\n                ts: 1\n              },\n              sort: {\n                $natural: -1\n              }\n            });\n            break;\n          } catch (e) {\n            // During failover (eg) if we get an exception we should log and retry\n            // instead of crashing.\n            Meteor._debug(\"Got exception while reading last entry\", e);\n            await Meteor._sleepForMs(100);\n          }\n        }\n        if (self._stopped) return;\n        if (!lastEntry) {\n          // Really, nothing in the oplog? Well, we've processed everything.\n          return;\n        }\n        var ts = lastEntry.ts;\n        if (!ts) throw Error(\"oplog entry without ts: \" + EJSON.stringify(lastEntry));\n        if (self._lastProcessedTS && ts.lessThanOrEqual(self._lastProcessedTS)) {\n          // We've already caught up to here.\n          return;\n        }\n\n        // Insert the future into our list. Almost always, this will be at the end,\n        // but it's conceivable that if we fail over from one primary to another,\n        // the oplog entries we see will go backwards.\n        var insertAfter = self._catchingUpResolvers.length;\n        while (insertAfter - 1 > 0 && self._catchingUpResolvers[insertAfter - 1].ts.greaterThan(ts)) {\n          insertAfter--;\n        }\n        let promiseResolver = null;\n        const promiseToAwait = new Promise(r => promiseResolver = r);\n        self._catchingUpResolvers.splice(insertAfter, 0, {\n          ts: ts,\n          resolver: promiseResolver\n        });\n        await promiseToAwait;\n      },\n      // Calls `callback` once the oplog has been processed up to a point that is\n      // roughly \"now\": specifically, once we've processed all ops that are\n      // currently visible.\n      // XXX become convinced that this is actually safe even if oplogConnection\n      // is some kind of pool\n      waitUntilCaughtUp: async function () {\n        return this._waitUntilCaughtUp();\n      },\n      _startTailing: async function () {\n        var _Meteor$settings, _Meteor$settings$pack, _Meteor$settings$pack2, _Meteor$settings2, _Meteor$settings2$pac, _Meteor$settings2$pac2;\n        var self = this;\n        // First, make sure that we're talking to the local database.\n        var mongodbUri = Npm.require('mongodb-uri');\n        if (mongodbUri.parse(self._oplogUrl).database !== 'local') {\n          throw Error(\"$MONGO_OPLOG_URL must be set to the 'local' database of \" + \"a Mongo replica set\");\n        }\n\n        // We make two separate connections to Mongo. The Node Mongo driver\n        // implements a naive round-robin connection pool: each \"connection\" is a\n        // pool of several (5 by default) TCP connections, and each request is\n        // rotated through the pools. Tailable cursor queries block on the server\n        // until there is some data to return (or until a few seconds have\n        // passed). So if the connection pool used for tailing cursors is the same\n        // pool used for other queries, the other queries will be delayed by seconds\n        // 1/5 of the time.\n        //\n        // The tail connection will only ever be running a single tail command, so\n        // it only needs to make one underlying TCP connection.\n        self._oplogTailConnection = new MongoConnection(self._oplogUrl, {\n          maxPoolSize: 1,\n          minPoolSize: 1\n        });\n        // XXX better docs, but: it's to get monotonic results\n        // XXX is it safe to say \"if there's an in flight query, just use its\n        //     results\"? I don't think so but should consider that\n        self._oplogLastEntryConnection = new MongoConnection(self._oplogUrl, {\n          maxPoolSize: 1,\n          minPoolSize: 1\n        });\n\n        // Now, make sure that there actually is a repl set here. If not, oplog\n        // tailing won't ever find anything!\n        // More on the isMasterDoc\n        // https://docs.mongodb.com/manual/reference/command/isMaster/\n        const isMasterDoc = await new Promise(function (resolve, reject) {\n          self._oplogLastEntryConnection.db.admin().command({\n            ismaster: 1\n          }, function (err, result) {\n            if (err) reject(err);else resolve(result);\n          });\n        });\n        if (!(isMasterDoc && isMasterDoc.setName)) {\n          throw Error(\"$MONGO_OPLOG_URL must be set to the 'local' database of \" + \"a Mongo replica set\");\n        }\n\n        // Find the last oplog entry.\n        var lastOplogEntry = await self._oplogLastEntryConnection.findOneAsync(OPLOG_COLLECTION, {}, {\n          sort: {\n            $natural: -1\n          },\n          projection: {\n            ts: 1\n          }\n        });\n        var oplogSelector = Object.assign({}, self._baseOplogSelector);\n        if (lastOplogEntry) {\n          // Start after the last entry that currently exists.\n          oplogSelector.ts = {\n            $gt: lastOplogEntry.ts\n          };\n          // If there are any calls to callWhenProcessedLatest before any other\n          // oplog entries show up, allow callWhenProcessedLatest to call its\n          // callback immediately.\n          self._lastProcessedTS = lastOplogEntry.ts;\n        }\n\n        // These 2 settings allow you to either only watch certain collections (oplogIncludeCollections), or exclude some collections you don't want to watch for oplog updates (oplogExcludeCollections)\n        // Usage:\n        // settings.json = {\n        //   \"packages\": {\n        //     \"mongo\": {\n        //       \"oplogExcludeCollections\": [\"products\", \"prices\"] // This would exclude both collections \"products\" and \"prices\" from any oplog tailing. \n        //                                                            Beware! This means, that no subscriptions on these 2 collections will update anymore!\n        //     }\n        //   }\n        // }\n        const includeCollections = (_Meteor$settings = Meteor.settings) === null || _Meteor$settings === void 0 ? void 0 : (_Meteor$settings$pack = _Meteor$settings.packages) === null || _Meteor$settings$pack === void 0 ? void 0 : (_Meteor$settings$pack2 = _Meteor$settings$pack.mongo) === null || _Meteor$settings$pack2 === void 0 ? void 0 : _Meteor$settings$pack2.oplogIncludeCollections;\n        const excludeCollections = (_Meteor$settings2 = Meteor.settings) === null || _Meteor$settings2 === void 0 ? void 0 : (_Meteor$settings2$pac = _Meteor$settings2.packages) === null || _Meteor$settings2$pac === void 0 ? void 0 : (_Meteor$settings2$pac2 = _Meteor$settings2$pac.mongo) === null || _Meteor$settings2$pac2 === void 0 ? void 0 : _Meteor$settings2$pac2.oplogExcludeCollections;\n        if (includeCollections !== null && includeCollections !== void 0 && includeCollections.length && excludeCollections !== null && excludeCollections !== void 0 && excludeCollections.length) {\n          throw new Error(\"Can't use both mongo oplog settings oplogIncludeCollections and oplogExcludeCollections at the same time.\");\n        }\n        if (excludeCollections !== null && excludeCollections !== void 0 && excludeCollections.length) {\n          oplogSelector.ns = {\n            $regex: oplogSelector.ns,\n            $nin: excludeCollections.map(collName => \"\".concat(self._dbName, \".\").concat(collName))\n          };\n          self._oplogOptions = {\n            excludeCollections\n          };\n        } else if (includeCollections !== null && includeCollections !== void 0 && includeCollections.length) {\n          oplogSelector = {\n            $and: [{\n              $or: [{\n                ns: /^admin\\.\\$cmd/\n              }, {\n                ns: {\n                  $in: includeCollections.map(collName => \"\".concat(self._dbName, \".\").concat(collName))\n                }\n              }]\n            }, {\n              $or: oplogSelector.$or\n            },\n            // the initial $or to select only certain operations (op)\n            {\n              ts: oplogSelector.ts\n            }]\n          };\n          self._oplogOptions = {\n            includeCollections\n          };\n        }\n        var cursorDescription = new CursorDescription(OPLOG_COLLECTION, oplogSelector, {\n          tailable: true\n        });\n\n        // Start tailing the oplog.\n        //\n        // We restart the low-level oplog query every 30 seconds if we didn't get a\n        // doc. This is a workaround for #8598: the Node Mongo driver has at least\n        // one bug that can lead to query callbacks never getting called (even with\n        // an error) when leadership failover occur.\n        self._tailHandle = self._oplogTailConnection.tail(cursorDescription, function (doc) {\n          self._entryQueue.push(doc);\n          self._maybeStartWorker();\n        }, TAIL_TIMEOUT);\n        self._readyPromiseResolver();\n      },\n      _maybeStartWorker: function () {\n        var self = this;\n        if (self._workerActive) return;\n        self._workerActive = true;\n        Meteor.defer(async function () {\n          // May be called recursively in case of transactions.\n          async function handleDoc(doc) {\n            if (doc.ns === \"admin.$cmd\") {\n              if (doc.o.applyOps) {\n                // This was a successful transaction, so we need to apply the\n                // operations that were involved.\n                let nextTimestamp = doc.ts;\n                for (const op of doc.o.applyOps) {\n                  // See https://github.com/meteor/meteor/issues/10420.\n                  if (!op.ts) {\n                    op.ts = nextTimestamp;\n                    nextTimestamp = nextTimestamp.add(Long.ONE);\n                  }\n                  await handleDoc(op);\n                }\n                return;\n              }\n              throw new Error(\"Unknown command \" + EJSON.stringify(doc));\n            }\n            const trigger = {\n              dropCollection: false,\n              dropDatabase: false,\n              op: doc\n            };\n            if (typeof doc.ns === \"string\" && doc.ns.startsWith(self._dbName + \".\")) {\n              trigger.collection = doc.ns.slice(self._dbName.length + 1);\n            }\n\n            // Is it a special command and the collection name is hidden\n            // somewhere in operator?\n            if (trigger.collection === \"$cmd\") {\n              if (doc.o.dropDatabase) {\n                delete trigger.collection;\n                trigger.dropDatabase = true;\n              } else if (has(doc.o, \"drop\")) {\n                trigger.collection = doc.o.drop;\n                trigger.dropCollection = true;\n                trigger.id = null;\n              } else if (\"create\" in doc.o && \"idIndex\" in doc.o) {\n                // A collection got implicitly created within a transaction. There's\n                // no need to do anything about it.\n              } else {\n                throw Error(\"Unknown command \" + EJSON.stringify(doc));\n              }\n            } else {\n              // All other ops have an id.\n              trigger.id = idForOp(doc);\n            }\n            await self._crossbar.fire(trigger);\n          }\n          try {\n            while (!self._stopped && !self._entryQueue.isEmpty()) {\n              // Are we too far behind? Just tell our observers that they need to\n              // repoll, and drop our queue.\n              if (self._entryQueue.length > TOO_FAR_BEHIND) {\n                var lastEntry = self._entryQueue.pop();\n                self._entryQueue.clear();\n                self._onSkippedEntriesHook.each(function (callback) {\n                  callback();\n                  return true;\n                });\n\n                // Free any waitUntilCaughtUp() calls that were waiting for us to\n                // pass something that we just skipped.\n                self._setLastProcessedTS(lastEntry.ts);\n                continue;\n              }\n              const doc = self._entryQueue.shift();\n\n              // Fire trigger(s) for this doc.\n              await handleDoc(doc);\n\n              // Now that we've processed this operation, process pending\n              // sequencers.\n              if (doc.ts) {\n                self._setLastProcessedTS(doc.ts);\n              } else {\n                throw Error(\"oplog entry without ts: \" + EJSON.stringify(doc));\n              }\n            }\n          } finally {\n            self._workerActive = false;\n          }\n        });\n      },\n      _setLastProcessedTS: function (ts) {\n        var self = this;\n        self._lastProcessedTS = ts;\n        while (!isEmpty(self._catchingUpResolvers) && self._catchingUpResolvers[0].ts.lessThanOrEqual(self._lastProcessedTS)) {\n          var sequencer = self._catchingUpResolvers.shift();\n          sequencer.resolver();\n        }\n      },\n      //Methods used on tests to dinamically change TOO_FAR_BEHIND\n      _defineTooFarBehind: function (value) {\n        TOO_FAR_BEHIND = value;\n      },\n      _resetTooFarBehind: function () {\n        TOO_FAR_BEHIND = process.env.METEOR_OPLOG_TOO_FAR_BEHIND || 2000;\n      }\n    });\n    __reify_async_result__();\n  } catch (_reifyError) {\n    return __reify_async_result__(_reifyError);\n  }\n  __reify_async_result__()\n}, {\n  self: this,\n  async: false\n});","map":{"version":3,"names":["isEmpty","module","link","default","v","has","NpmModuleMongodb","__reifyWaitForDeps__","Long","OPLOG_COLLECTION","TOO_FAR_BEHIND","process","env","METEOR_OPLOG_TOO_FAR_BEHIND","TAIL_TIMEOUT","METEOR_OPLOG_TAIL_TIMEOUT","idForOp","op","o","_id","o2","Error","EJSON","stringify","OplogHandle","oplogUrl","dbName","self","_oplogUrl","_dbName","_oplogLastEntryConnection","_oplogTailConnection","_oplogOptions","_stopped","_tailHandle","_readyPromiseResolver","_readyPromise","Promise","r","_crossbar","DDPServer","_Crossbar","factPackage","factName","_baseOplogSelector","ns","RegExp","Meteor","_escapeRegExp","join","$or","$in","$exists","_catchingUpResolvers","_lastProcessedTS","_onSkippedEntriesHook","Hook","debugPrintExceptions","_entryQueue","_DoubleEndedQueue","_workerActive","_startTrailingPromise","_startTailing","MongoInternals","Object","assign","prototype","stop","_onOplogEntry","trigger","callback","originalCallback","bindEnvironment","notification","err","_debug","listenHandle","listen","onOplogEntry","onSkippedEntries","register","_waitUntilCaughtUp","lastEntry","findOneAsync","projection","ts","sort","$natural","e","_sleepForMs","lessThanOrEqual","insertAfter","length","greaterThan","promiseResolver","promiseToAwait","splice","resolver","waitUntilCaughtUp","_Meteor$settings","_Meteor$settings$pack","_Meteor$settings$pack2","_Meteor$settings2","_Meteor$settings2$pac","_Meteor$settings2$pac2","mongodbUri","Npm","require","parse","database","MongoConnection","maxPoolSize","minPoolSize","isMasterDoc","resolve","reject","db","admin","command","ismaster","result","setName","lastOplogEntry","oplogSelector","$gt","includeCollections","settings","packages","mongo","oplogIncludeCollections","excludeCollections","oplogExcludeCollections","$regex","$nin","map","collName","concat","$and","cursorDescription","CursorDescription","tailable","tail","doc","push","_maybeStartWorker","defer","handleDoc","applyOps","nextTimestamp","add","ONE","dropCollection","dropDatabase","startsWith","collection","slice","drop","id","fire","pop","clear","each","_setLastProcessedTS","shift","sequencer","_defineTooFarBehind","value","_resetTooFarBehind","__reify_async_result__","_reifyError","async"],"sources":["packages/mongo/oplog_tailing.js"],"sourcesContent":["import isEmpty from 'lodash.isempty';\nimport has from 'lodash.has';\n\nimport { NpmModuleMongodb } from \"meteor/npm-mongo\";\nconst { Long } = NpmModuleMongodb;\n\nOPLOG_COLLECTION = 'oplog.rs';\n\nvar TOO_FAR_BEHIND = process.env.METEOR_OPLOG_TOO_FAR_BEHIND || 2000;\nvar TAIL_TIMEOUT = +process.env.METEOR_OPLOG_TAIL_TIMEOUT || 30000;\n\nidForOp = function (op) {\n  if (op.op === 'd')\n    return op.o._id;\n  else if (op.op === 'i')\n    return op.o._id;\n  else if (op.op === 'u')\n    return op.o2._id;\n  else if (op.op === 'c')\n    throw Error(\"Operator 'c' doesn't supply an object with id: \" +\n                EJSON.stringify(op));\n  else\n    throw Error(\"Unknown op: \" + EJSON.stringify(op));\n};\n\nOplogHandle = function (oplogUrl, dbName) {\n  var self = this;\n  self._oplogUrl = oplogUrl;\n  self._dbName = dbName;\n\n  self._oplogLastEntryConnection = null;\n  self._oplogTailConnection = null;\n  self._oplogOptions = null;\n  self._stopped = false;\n  self._tailHandle = null;\n  self._readyPromiseResolver = null;\n  self._readyPromise = new Promise(r => self._readyPromiseResolver = r);\n  self._crossbar = new DDPServer._Crossbar({\n    factPackage: \"mongo-livedata\", factName: \"oplog-watchers\"\n  });\n  self._baseOplogSelector = {\n    ns: new RegExp(\"^(?:\" + [\n      Meteor._escapeRegExp(self._dbName + \".\"),\n      Meteor._escapeRegExp(\"admin.$cmd\"),\n    ].join(\"|\") + \")\"),\n\n    $or: [\n      { op: { $in: ['i', 'u', 'd'] } },\n      // drop collection\n      { op: 'c', 'o.drop': { $exists: true } },\n      { op: 'c', 'o.dropDatabase': 1 },\n      { op: 'c', 'o.applyOps': { $exists: true } },\n    ]\n  };\n\n  // Data structures to support waitUntilCaughtUp(). Each oplog entry has a\n  // MongoTimestamp object on it (which is not the same as a Date --- it's a\n  // combination of time and an incrementing counter; see\n  // http://docs.mongodb.org/manual/reference/bson-types/#timestamps).\n  //\n  // _catchingUpFutures is an array of {ts: MongoTimestamp, future: Future}\n  // objects, sorted by ascending timestamp. _lastProcessedTS is the\n  // MongoTimestamp of the last oplog entry we've processed.\n  //\n  // Each time we call waitUntilCaughtUp, we take a peek at the final oplog\n  // entry in the db.  If we've already processed it (ie, it is not greater than\n  // _lastProcessedTS), waitUntilCaughtUp immediately returns. Otherwise,\n  // waitUntilCaughtUp makes a new Future and inserts it along with the final\n  // timestamp entry that it read, into _catchingUpFutures. waitUntilCaughtUp\n  // then waits on that future, which is resolved once _lastProcessedTS is\n  // incremented to be past its timestamp by the worker fiber.\n  //\n  // XXX use a priority queue or something else that's faster than an array\n  self._catchingUpResolvers = [];\n  self._lastProcessedTS = null;\n\n  self._onSkippedEntriesHook = new Hook({\n    debugPrintExceptions: \"onSkippedEntries callback\"\n  });\n\n  self._entryQueue = new Meteor._DoubleEndedQueue();\n  self._workerActive = false;\n\n  self._startTrailingPromise = self._startTailing();\n  //TODO[fibers] Why wait?\n};\n\nMongoInternals.OplogHandle = OplogHandle;\n\nObject.assign(OplogHandle.prototype, {\n  stop: async function () {\n    var self = this;\n    if (self._stopped)\n      return;\n    self._stopped = true;\n    if (self._tailHandle)\n      await self._tailHandle.stop();\n    // XXX should close connections too\n  },\n  _onOplogEntry: async function(trigger, callback) {\n    var self = this;\n    if (self._stopped)\n      throw new Error(\"Called onOplogEntry on stopped handle!\");\n\n    // Calling onOplogEntry requires us to wait for the tailing to be ready.\n    await self._readyPromise;\n\n    var originalCallback = callback;\n    callback = Meteor.bindEnvironment(function (notification) {\n      originalCallback(notification);\n    }, function (err) {\n      Meteor._debug(\"Error in oplog callback\", err);\n    });\n    var listenHandle = self._crossbar.listen(trigger, callback);\n    return {\n      stop: async function () {\n        await listenHandle.stop();\n      }\n    };\n  },\n  onOplogEntry: function (trigger, callback) {\n    return this._onOplogEntry(trigger, callback);\n  },\n  // Register a callback to be invoked any time we skip oplog entries (eg,\n  // because we are too far behind).\n  onSkippedEntries: function (callback) {\n    var self = this;\n    if (self._stopped)\n      throw new Error(\"Called onSkippedEntries on stopped handle!\");\n    return self._onSkippedEntriesHook.register(callback);\n  },\n\n  async _waitUntilCaughtUp() {\n    var self = this;\n    if (self._stopped)\n      throw new Error(\"Called waitUntilCaughtUp on stopped handle!\");\n\n    // Calling waitUntilCaughtUp requries us to wait for the oplog connection to\n    // be ready.\n    await self._readyPromise;\n    var lastEntry;\n\n    while (!self._stopped) {\n      // We need to make the selector at least as restrictive as the actual\n      // tailing selector (ie, we need to specify the DB name) or else we might\n      // find a TS that won't show up in the actual tail stream.\n      try {\n        lastEntry = await self._oplogLastEntryConnection.findOneAsync(\n          OPLOG_COLLECTION,\n          self._baseOplogSelector,\n          { projection: { ts: 1 }, sort: { $natural: -1 } }\n        );\n        break;\n      } catch (e) {\n        // During failover (eg) if we get an exception we should log and retry\n        // instead of crashing.\n        Meteor._debug(\"Got exception while reading last entry\", e);\n        await Meteor._sleepForMs(100);\n      }\n    }\n\n    if (self._stopped)\n      return;\n\n    if (!lastEntry) {\n      // Really, nothing in the oplog? Well, we've processed everything.\n      return;\n    }\n\n    var ts = lastEntry.ts;\n    if (!ts)\n      throw Error(\"oplog entry without ts: \" + EJSON.stringify(lastEntry));\n\n    if (self._lastProcessedTS && ts.lessThanOrEqual(self._lastProcessedTS)) {\n      // We've already caught up to here.\n      return;\n    }\n\n\n    // Insert the future into our list. Almost always, this will be at the end,\n    // but it's conceivable that if we fail over from one primary to another,\n    // the oplog entries we see will go backwards.\n    var insertAfter = self._catchingUpResolvers.length;\n    while (insertAfter - 1 > 0 && self._catchingUpResolvers[insertAfter - 1].ts.greaterThan(ts)) {\n      insertAfter--;\n    }\n    let promiseResolver = null;\n    const promiseToAwait = new Promise(r => promiseResolver = r);\n    self._catchingUpResolvers.splice(insertAfter, 0, {ts: ts, resolver: promiseResolver});\n    await promiseToAwait;\n  },\n\n  // Calls `callback` once the oplog has been processed up to a point that is\n  // roughly \"now\": specifically, once we've processed all ops that are\n  // currently visible.\n  // XXX become convinced that this is actually safe even if oplogConnection\n  // is some kind of pool\n  waitUntilCaughtUp: async function () {\n    return this._waitUntilCaughtUp();\n  },\n\n  _startTailing: async function () {\n    var self = this;\n    // First, make sure that we're talking to the local database.\n    var mongodbUri = Npm.require('mongodb-uri');\n    if (mongodbUri.parse(self._oplogUrl).database !== 'local') {\n      throw Error(\"$MONGO_OPLOG_URL must be set to the 'local' database of \" +\n          \"a Mongo replica set\");\n    }\n\n    // We make two separate connections to Mongo. The Node Mongo driver\n    // implements a naive round-robin connection pool: each \"connection\" is a\n    // pool of several (5 by default) TCP connections, and each request is\n    // rotated through the pools. Tailable cursor queries block on the server\n    // until there is some data to return (or until a few seconds have\n    // passed). So if the connection pool used for tailing cursors is the same\n    // pool used for other queries, the other queries will be delayed by seconds\n    // 1/5 of the time.\n    //\n    // The tail connection will only ever be running a single tail command, so\n    // it only needs to make one underlying TCP connection.\n    self._oplogTailConnection = new MongoConnection(\n        self._oplogUrl, {maxPoolSize: 1, minPoolSize: 1});\n    // XXX better docs, but: it's to get monotonic results\n    // XXX is it safe to say \"if there's an in flight query, just use its\n    //     results\"? I don't think so but should consider that\n    self._oplogLastEntryConnection = new MongoConnection(\n        self._oplogUrl, {maxPoolSize: 1, minPoolSize: 1});\n\n\n    // Now, make sure that there actually is a repl set here. If not, oplog\n    // tailing won't ever find anything!\n    // More on the isMasterDoc\n    // https://docs.mongodb.com/manual/reference/command/isMaster/\n    const isMasterDoc = await new Promise(function (resolve, reject) {\n      self._oplogLastEntryConnection.db\n        .admin()\n        .command({ ismaster: 1 }, function (err, result) {\n          if (err) reject(err);\n          else resolve(result);\n        });\n    });\n\n    if (!(isMasterDoc && isMasterDoc.setName)) {\n      throw Error(\"$MONGO_OPLOG_URL must be set to the 'local' database of \" +\n          \"a Mongo replica set\");\n    }\n\n    // Find the last oplog entry.\n    var lastOplogEntry = await self._oplogLastEntryConnection.findOneAsync(\n      OPLOG_COLLECTION,\n      {},\n      { sort: { $natural: -1 }, projection: { ts: 1 } }\n    );\n\n    var oplogSelector = Object.assign({}, self._baseOplogSelector);\n    if (lastOplogEntry) {\n      // Start after the last entry that currently exists.\n      oplogSelector.ts = {$gt: lastOplogEntry.ts};\n      // If there are any calls to callWhenProcessedLatest before any other\n      // oplog entries show up, allow callWhenProcessedLatest to call its\n      // callback immediately.\n      self._lastProcessedTS = lastOplogEntry.ts;\n    }\n\n    // These 2 settings allow you to either only watch certain collections (oplogIncludeCollections), or exclude some collections you don't want to watch for oplog updates (oplogExcludeCollections)\n    // Usage:\n    // settings.json = {\n    //   \"packages\": {\n    //     \"mongo\": {\n    //       \"oplogExcludeCollections\": [\"products\", \"prices\"] // This would exclude both collections \"products\" and \"prices\" from any oplog tailing. \n    //                                                            Beware! This means, that no subscriptions on these 2 collections will update anymore!\n    //     }\n    //   }\n    // }\n    const includeCollections = Meteor.settings?.packages?.mongo?.oplogIncludeCollections;\n    const excludeCollections = Meteor.settings?.packages?.mongo?.oplogExcludeCollections;\n    if (includeCollections?.length && excludeCollections?.length) {\n      throw new Error(\"Can't use both mongo oplog settings oplogIncludeCollections and oplogExcludeCollections at the same time.\");\n    }\n    if (excludeCollections?.length) {\n      oplogSelector.ns = {\n        $regex: oplogSelector.ns,\n        $nin: excludeCollections.map((collName) => `${self._dbName}.${collName}`)\n      }\n      self._oplogOptions = { excludeCollections };\n    }\n    else if (includeCollections?.length) {\n      oplogSelector = { $and: [\n        { $or: [\n          { ns: /^admin\\.\\$cmd/ },\n          { ns: { $in: includeCollections.map((collName) => `${self._dbName}.${collName}`) } }\n        ] },\n        { $or: oplogSelector.$or }, // the initial $or to select only certain operations (op)\n        { ts: oplogSelector.ts }\n      ] };\n      self._oplogOptions = { includeCollections };\n    }\n\n    var cursorDescription = new CursorDescription(\n        OPLOG_COLLECTION, oplogSelector, {tailable: true});\n\n    // Start tailing the oplog.\n    //\n    // We restart the low-level oplog query every 30 seconds if we didn't get a\n    // doc. This is a workaround for #8598: the Node Mongo driver has at least\n    // one bug that can lead to query callbacks never getting called (even with\n    // an error) when leadership failover occur.\n    self._tailHandle = self._oplogTailConnection.tail(\n        cursorDescription,\n        function (doc) {\n          self._entryQueue.push(doc);\n          self._maybeStartWorker();\n        },\n        TAIL_TIMEOUT\n    );\n\n    self._readyPromiseResolver();\n  },\n\n  _maybeStartWorker: function () {\n    var self = this;\n    if (self._workerActive) return;\n    self._workerActive = true;\n\n    Meteor.defer(async function () {\n      // May be called recursively in case of transactions.\n      async function handleDoc(doc) {\n        if (doc.ns === \"admin.$cmd\") {\n          if (doc.o.applyOps) {\n            // This was a successful transaction, so we need to apply the\n            // operations that were involved.\n            let nextTimestamp = doc.ts;\n            for (const op of doc.o.applyOps) {\n              // See https://github.com/meteor/meteor/issues/10420.\n              if (!op.ts) {\n                op.ts = nextTimestamp;\n                nextTimestamp = nextTimestamp.add(Long.ONE);\n              }\n              await handleDoc(op);\n            }\n            return;\n          }\n          throw new Error(\"Unknown command \" + EJSON.stringify(doc));\n        }\n\n        const trigger = {\n          dropCollection: false,\n          dropDatabase: false,\n          op: doc,\n        };\n\n        if (typeof doc.ns === \"string\" &&\n            doc.ns.startsWith(self._dbName + \".\")) {\n          trigger.collection = doc.ns.slice(self._dbName.length + 1);\n        }\n\n        // Is it a special command and the collection name is hidden\n        // somewhere in operator?\n        if (trigger.collection === \"$cmd\") {\n          if (doc.o.dropDatabase) {\n            delete trigger.collection;\n            trigger.dropDatabase = true;\n          } else if (has(doc.o, \"drop\")) {\n            trigger.collection = doc.o.drop;\n            trigger.dropCollection = true;\n            trigger.id = null;\n          } else if (\"create\" in doc.o && \"idIndex\" in doc.o) {\n            // A collection got implicitly created within a transaction. There's\n            // no need to do anything about it.\n          } else {\n            throw Error(\"Unknown command \" + EJSON.stringify(doc));\n          }\n\n        } else {\n          // All other ops have an id.\n          trigger.id = idForOp(doc);\n        }\n\n        await self._crossbar.fire(trigger);\n      }\n\n      try {\n        while (! self._stopped &&\n               ! self._entryQueue.isEmpty()) {\n          // Are we too far behind? Just tell our observers that they need to\n          // repoll, and drop our queue.\n          if (self._entryQueue.length > TOO_FAR_BEHIND) {\n            var lastEntry = self._entryQueue.pop();\n            self._entryQueue.clear();\n\n            self._onSkippedEntriesHook.each(function (callback) {\n              callback();\n              return true;\n            });\n\n            // Free any waitUntilCaughtUp() calls that were waiting for us to\n            // pass something that we just skipped.\n            self._setLastProcessedTS(lastEntry.ts);\n            continue;\n          }\n\n          const doc = self._entryQueue.shift();\n\n          // Fire trigger(s) for this doc.\n          await handleDoc(doc);\n\n          // Now that we've processed this operation, process pending\n          // sequencers.\n          if (doc.ts) {\n            self._setLastProcessedTS(doc.ts);\n          } else {\n            throw Error(\"oplog entry without ts: \" + EJSON.stringify(doc));\n          }\n        }\n      } finally {\n        self._workerActive = false;\n      }\n    });\n  },\n\n  _setLastProcessedTS: function (ts) {\n    var self = this;\n    self._lastProcessedTS = ts;\n    while (!isEmpty(self._catchingUpResolvers) && self._catchingUpResolvers[0].ts.lessThanOrEqual(self._lastProcessedTS)) {\n      var sequencer = self._catchingUpResolvers.shift();\n      sequencer.resolver();\n    }\n  },\n\n  //Methods used on tests to dinamically change TOO_FAR_BEHIND\n  _defineTooFarBehind: function(value) {\n    TOO_FAR_BEHIND = value;\n  },\n  _resetTooFarBehind: function() {\n    TOO_FAR_BEHIND = process.env.METEOR_OPLOG_TOO_FAR_BEHIND || 2000;\n  }\n});"],"mappings":"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","ignoreList":[]},"sourceType":"module","externalDependencies":{},"hash":"877e0a4aa30a38579a95c217bb00c5007585a46a"}
