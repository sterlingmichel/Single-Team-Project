{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/Users/smichel/Projects/Team-5-Project/database/packages/minimongo/local_collection.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","topLevelAwait","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"web.browser.legacy"},"sourceFileName":"packages/minimongo/local_collection.js","filename":"/Users/smichel/Projects/Team-5-Project/database/packages/minimongo/local_collection.js","targets":{},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"/Users/smichel/Projects/Team-5-Project/database","root":"/Users/smichel/Projects/Team-5-Project/database","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":true,"enforceStrictMode":false,"dynamicImport":true},"externalDependencies":[]},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"version":"7.17.2","helpers":true,"useESModules":false,"corejs":false},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true},"externalDependencies":[]},{"key":"base$0$3","visitor":{"FunctionExpression":{"exit":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"base$0$4","visitor":{"ForInStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-react-jsx","visitor":{"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXFragment":{"exit":[null]},"JSXElement":{"exit":[null]},"JSXAttribute":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false},"externalDependencies":[]},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-nullish-coalescing-operator","visitor":{"LogicalExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-chaining","visitor":{"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-catch-binding","visitor":{"CatchClause":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-logical-assignment-operators","visitor":{"AssignmentExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-arrow-functions","visitor":{"ArrowFunctionExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-block-scoped-functions","visitor":{"BlockStatement":{"enter":[null]},"SwitchCase":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-block-scoping","visitor":{"VariableDeclaration":{"enter":[null,null]},"BlockStatement":{"enter":[null]},"SwitchCase":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"DoWhileStatement":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForStatement":{"enter":[null]},"WhileStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-classes","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-computed-properties","visitor":{"ObjectExpression":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-destructuring","visitor":{"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"VariableDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-for-of","visitor":{"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-object-super","visitor":{"ObjectExpression":{"enter":[null]},"_exploded":true,"_verified":true,"DoWhileStatement":{"exit":[null]},"ForInStatement":{"exit":[null]},"ForStatement":{"exit":[null]},"WhileStatement":{"exit":[null]},"ForOfStatement":{"exit":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-shorthand-properties","visitor":{"ObjectMethod":{"enter":[null]},"ObjectProperty":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-spread","visitor":{"ArrayExpression":{"enter":[null]},"CallExpression":{"enter":[null]},"NewExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-sticky-regex","visitor":{"RegExpLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-typeof-symbol","visitor":{"UnaryExpression":{"enter":[null]},"_exploded":true,"_verified":true,"BlockStatement":{"enter":[null]},"CatchClause":{"enter":[null]},"DoWhileStatement":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForStatement":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"Program":{"enter":[null]},"ObjectMethod":{"enter":[null]},"SwitchStatement":{"enter":[null]},"WhileStatement":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ForOfStatement":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"StaticBlock":{"enter":[null]},"TSModuleBlock":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectPattern":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-unicode-regex","visitor":{"RegExpLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-property-literals","visitor":{"ObjectProperty":{"exit":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-regenerator","visitor":{"ObjectMethod":{"enter":[null],"exit":[null]},"ClassMethod":{"enter":[null],"exit":[null]},"ClassPrivateMethod":{"enter":[null],"exit":[null]},"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]}],"presets":[],"generatorOpts":{"filename":"/Users/smichel/Projects/Team-5-Project/database/packages/minimongo/local_collection.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/minimongo/local_collection.js"}},"code":"var _toConsumableArray;\nmodule.link(\"@babel/runtime/helpers/toConsumableArray\", {\n  default: function (v) {\n    _toConsumableArray = v;\n  }\n}, 0);\nvar _typeof;\nmodule.link(\"@babel/runtime/helpers/typeof\", {\n  default: function (v) {\n    _typeof = v;\n  }\n}, 1);\nvar _inheritsLoose;\nmodule.link(\"@babel/runtime/helpers/inheritsLoose\", {\n  default: function (v) {\n    _inheritsLoose = v;\n  }\n}, 2);\nvar _objectSpread;\nmodule.link(\"@babel/runtime/helpers/objectSpread2\", {\n  default: function (v) {\n    _objectSpread = v;\n  }\n}, 3);\nvar _createForOfIteratorHelperLoose;\nmodule.link(\"@babel/runtime/helpers/createForOfIteratorHelperLoose\", {\n  default: function (v) {\n    _createForOfIteratorHelperLoose = v;\n  }\n}, 4);\nvar _regeneratorRuntime;\nmodule.link(\"@babel/runtime/regenerator\", {\n  default: function (v) {\n    _regeneratorRuntime = v;\n  }\n}, 5);\nmodule.export({\n  \"default\": function () {\n    return LocalCollection;\n  }\n});\nvar Cursor;\nmodule.link(\"./cursor.js\", {\n  \"default\": function (v) {\n    Cursor = v;\n  }\n}, 0);\nvar ObserveHandle;\nmodule.link(\"./observe_handle.js\", {\n  \"default\": function (v) {\n    ObserveHandle = v;\n  }\n}, 1);\nvar hasOwn, isIndexable, isNumericKey, isOperatorObject, populateDocumentWithQueryFields, projectionDetails;\nmodule.link(\"./common.js\", {\n  hasOwn: function (v) {\n    hasOwn = v;\n  },\n  isIndexable: function (v) {\n    isIndexable = v;\n  },\n  isNumericKey: function (v) {\n    isNumericKey = v;\n  },\n  isOperatorObject: function (v) {\n    isOperatorObject = v;\n  },\n  populateDocumentWithQueryFields: function (v) {\n    populateDocumentWithQueryFields = v;\n  },\n  projectionDetails: function (v) {\n    projectionDetails = v;\n  }\n}, 2);\nvar getAsyncMethodName;\nmodule.link(\"./constants\", {\n  getAsyncMethodName: function (v) {\n    getAsyncMethodName = v;\n  }\n}, 3);\nvar LocalCollection = /*#__PURE__*/function () {\n  function LocalCollection(name) {\n    this.name = name;\n    // _id -> document (also containing id)\n    this._docs = new LocalCollection._IdMap();\n    this._observeQueue = Meteor.isClient ? new Meteor._SynchronousQueue() : new Meteor._AsynchronousQueue();\n    this.next_qid = 1; // live query id generator\n\n    // qid -> live query object. keys:\n    //  ordered: bool. ordered queries have addedBefore/movedBefore callbacks.\n    //  results: array (ordered) or object (unordered) of current results\n    //    (aliased with this._docs!)\n    //  resultsSnapshot: snapshot of results. null if not paused.\n    //  cursor: Cursor object for the query.\n    //  selector, sorter, (callbacks): functions\n    this.queries = Object.create(null);\n\n    // null if not saving originals; an IdMap from id to original document value\n    // if saving originals. See comments before saveOriginals().\n    this._savedOriginals = null;\n\n    // True when observers are paused and we should not send callbacks.\n    this.paused = false;\n  }\n  var _proto = LocalCollection.prototype;\n  _proto.countDocuments = function () {\n    function countDocuments(selector, options) {\n      return this.find(selector !== null && selector !== void 0 ? selector : {}, options).countAsync();\n    }\n    return countDocuments;\n  }();\n  _proto.estimatedDocumentCount = function () {\n    function estimatedDocumentCount(options) {\n      return this.find({}, options).countAsync();\n    }\n    return estimatedDocumentCount;\n  }() // options may include sort, skip, limit, reactive\n  // sort may be any of these forms:\n  //     {a: 1, b: -1}\n  //     [[\"a\", \"asc\"], [\"b\", \"desc\"]]\n  //     [\"a\", [\"b\", \"desc\"]]\n  //   (in the first form you're beholden to key enumeration order in\n  //   your javascript VM)\n  //\n  // reactive: if given, and false, don't register with Tracker (default\n  // is true)\n  //\n  // XXX possibly should support retrieving a subset of fields? and\n  // have it be a hint (ignored on the client, when not copying the\n  // doc?)\n  //\n  // XXX sort does not yet support subkeys ('a.b') .. fix that!\n  // XXX add one more sort form: \"key\"\n  // XXX tests\n  ;\n  _proto.find = function () {\n    function find(selector, options) {\n      // default syntax for everything is to omit the selector argument.\n      // but if selector is explicitly passed in as false or undefined, we\n      // want a selector that matches nothing.\n      if (arguments.length === 0) {\n        selector = {};\n      }\n      return new LocalCollection.Cursor(this, selector, options);\n    }\n    return find;\n  }();\n  _proto.findOne = function () {\n    function findOne(selector) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      if (arguments.length === 0) {\n        selector = {};\n      }\n\n      // NOTE: by setting limit 1 here, we end up using very inefficient\n      // code that recomputes the whole query on each update. The upside is\n      // that when you reactively depend on a findOne you only get\n      // invalidated when the found object changes, not any object in the\n      // collection. Most findOne will be by id, which has a fast path, so\n      // this might not be a big deal. In most cases, invalidation causes\n      // the called to re-query anyway, so this should be a net performance\n      // improvement.\n      options.limit = 1;\n      return this.find(selector, options).fetch()[0];\n    }\n    return findOne;\n  }();\n  _proto.findOneAsync = function () {\n    function findOneAsync(selector) {\n      var options,\n        _args = arguments;\n      return _regeneratorRuntime.async(function () {\n        function findOneAsync$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              options = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};\n              if (_args.length === 0) {\n                selector = {};\n              }\n              options.limit = 1;\n              _context.next = 5;\n              return _regeneratorRuntime.awrap(this.find(selector, options).fetchAsync());\n            case 5:\n              return _context.abrupt(\"return\", _context.sent[0]);\n            case 6:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n        return findOneAsync$;\n      }(), null, this, null, Promise);\n    }\n    return findOneAsync;\n  }();\n  _proto.prepareInsert = function () {\n    function prepareInsert(doc) {\n      assertHasValidFieldNames(doc);\n\n      // if you really want to use ObjectIDs, set this global.\n      // Mongo.Collection specifies its own ids and does not use this code.\n      if (!hasOwn.call(doc, '_id')) {\n        doc._id = LocalCollection._useOID ? new MongoID.ObjectID() : Random.id();\n      }\n      var id = doc._id;\n      if (this._docs.has(id)) {\n        throw MinimongoError(\"Duplicate _id '\" + id + \"'\");\n      }\n      this._saveOriginal(id, undefined);\n      this._docs.set(id, doc);\n      return id;\n    }\n    return prepareInsert;\n  }() // XXX possibly enforce that 'undefined' does not appear (we assume\n  // this in our handling of null and $exists)\n  ;\n  _proto.insert = function () {\n    function insert(doc, callback) {\n      var _this = this;\n      doc = EJSON.clone(doc);\n      var id = this.prepareInsert(doc);\n      var queriesToRecompute = [];\n\n      // trigger live queries that match\n      for (var _i = 0, _Object$keys = Object.keys(this.queries); _i < _Object$keys.length; _i++) {\n        var qid = _Object$keys[_i];\n        var query = this.queries[qid];\n        if (query.dirty) {\n          continue;\n        }\n        var matchResult = query.matcher.documentMatches(doc);\n        if (matchResult.result) {\n          if (query.distances && matchResult.distance !== undefined) {\n            query.distances.set(id, matchResult.distance);\n          }\n          if (query.cursor.skip || query.cursor.limit) {\n            queriesToRecompute.push(qid);\n          } else {\n            LocalCollection._insertInResultsSync(query, doc);\n          }\n        }\n      }\n      queriesToRecompute.forEach(function (qid) {\n        if (_this.queries[qid]) {\n          _this._recomputeResults(_this.queries[qid]);\n        }\n      });\n      this._observeQueue.drain();\n      if (callback) {\n        Meteor.defer(function () {\n          callback(null, id);\n        });\n      }\n      return id;\n    }\n    return insert;\n  }();\n  _proto.insertAsync = function () {\n    function insertAsync(doc, callback) {\n      var _this2 = this;\n      var id, queriesToRecompute, _i2, _Object$keys2, qid, query, matchResult;\n      return _regeneratorRuntime.async(function () {\n        function insertAsync$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              doc = EJSON.clone(doc);\n              id = this.prepareInsert(doc);\n              queriesToRecompute = []; // trigger live queries that match\n              _i2 = 0, _Object$keys2 = Object.keys(this.queries);\n            case 4:\n              if (!(_i2 < _Object$keys2.length)) {\n                _context2.next = 21;\n                break;\n              }\n              qid = _Object$keys2[_i2];\n              query = this.queries[qid];\n              if (!query.dirty) {\n                _context2.next = 9;\n                break;\n              }\n              return _context2.abrupt(\"continue\", 18);\n            case 9:\n              matchResult = query.matcher.documentMatches(doc);\n              if (!matchResult.result) {\n                _context2.next = 18;\n                break;\n              }\n              if (query.distances && matchResult.distance !== undefined) {\n                query.distances.set(id, matchResult.distance);\n              }\n              if (!(query.cursor.skip || query.cursor.limit)) {\n                _context2.next = 16;\n                break;\n              }\n              queriesToRecompute.push(qid);\n              _context2.next = 18;\n              break;\n            case 16:\n              _context2.next = 18;\n              return _regeneratorRuntime.awrap(LocalCollection._insertInResultsAsync(query, doc));\n            case 18:\n              _i2++;\n              _context2.next = 4;\n              break;\n            case 21:\n              queriesToRecompute.forEach(function (qid) {\n                if (_this2.queries[qid]) {\n                  _this2._recomputeResults(_this2.queries[qid]);\n                }\n              });\n              _context2.next = 24;\n              return _regeneratorRuntime.awrap(this._observeQueue.drain());\n            case 24:\n              if (callback) {\n                Meteor.defer(function () {\n                  callback(null, id);\n                });\n              }\n              return _context2.abrupt(\"return\", id);\n            case 26:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n        return insertAsync$;\n      }(), null, this, null, Promise);\n    }\n    return insertAsync;\n  }() // Pause the observers. No callbacks from observers will fire until\n  // 'resumeObservers' is called.\n  ;\n  _proto.pauseObservers = function () {\n    function pauseObservers() {\n      var _this3 = this;\n      // No-op if already paused.\n      if (this.paused) {\n        return;\n      }\n\n      // Set the 'paused' flag such that new observer messages don't fire.\n      this.paused = true;\n\n      // Take a snapshot of the query results for each query.\n      Object.keys(this.queries).forEach(function (qid) {\n        var query = _this3.queries[qid];\n        query.resultsSnapshot = EJSON.clone(query.results);\n      });\n    }\n    return pauseObservers;\n  }();\n  _proto.clearResultQueries = function () {\n    function clearResultQueries(callback) {\n      var _this4 = this;\n      var result = this._docs.size();\n      this._docs.clear();\n      Object.keys(this.queries).forEach(function (qid) {\n        var query = _this4.queries[qid];\n        if (query.ordered) {\n          query.results = [];\n        } else {\n          query.results.clear();\n        }\n      });\n      if (callback) {\n        Meteor.defer(function () {\n          callback(null, result);\n        });\n      }\n      return result;\n    }\n    return clearResultQueries;\n  }();\n  _proto.prepareRemove = function () {\n    function prepareRemove(selector) {\n      var _this5 = this;\n      var matcher = new Minimongo.Matcher(selector);\n      var remove = [];\n      this._eachPossiblyMatchingDocSync(selector, function (doc, id) {\n        if (matcher.documentMatches(doc).result) {\n          remove.push(id);\n        }\n      });\n      var queriesToRecompute = [];\n      var queryRemove = [];\n      var _loop = function () {\n        var removeId = remove[i];\n        var removeDoc = _this5._docs.get(removeId);\n        Object.keys(_this5.queries).forEach(function (qid) {\n          var query = _this5.queries[qid];\n          if (query.dirty) {\n            return;\n          }\n          if (query.matcher.documentMatches(removeDoc).result) {\n            if (query.cursor.skip || query.cursor.limit) {\n              queriesToRecompute.push(qid);\n            } else {\n              queryRemove.push({\n                qid: qid,\n                doc: removeDoc\n              });\n            }\n          }\n        });\n        _this5._saveOriginal(removeId, removeDoc);\n        _this5._docs.remove(removeId);\n      };\n      for (var i = 0; i < remove.length; i++) {\n        _loop();\n      }\n      return {\n        queriesToRecompute: queriesToRecompute,\n        queryRemove: queryRemove,\n        remove: remove\n      };\n    }\n    return prepareRemove;\n  }();\n  _proto.remove = function () {\n    function remove(selector, callback) {\n      var _this6 = this;\n      // Easy special case: if we're not calling observeChanges callbacks and\n      // we're not saving originals and we got asked to remove everything, then\n      // just empty everything directly.\n      if (this.paused && !this._savedOriginals && EJSON.equals(selector, {})) {\n        return this.clearResultQueries(callback);\n      }\n      var _this$prepareRemove = this.prepareRemove(selector),\n        queriesToRecompute = _this$prepareRemove.queriesToRecompute,\n        queryRemove = _this$prepareRemove.queryRemove,\n        remove = _this$prepareRemove.remove;\n\n      // run live query callbacks _after_ we've removed the documents.\n      queryRemove.forEach(function (remove) {\n        var query = _this6.queries[remove.qid];\n        if (query) {\n          query.distances && query.distances.remove(remove.doc._id);\n          LocalCollection._removeFromResultsSync(query, remove.doc);\n        }\n      });\n      queriesToRecompute.forEach(function (qid) {\n        var query = _this6.queries[qid];\n        if (query) {\n          _this6._recomputeResults(query);\n        }\n      });\n      this._observeQueue.drain();\n      var result = remove.length;\n      if (callback) {\n        Meteor.defer(function () {\n          callback(null, result);\n        });\n      }\n      return result;\n    }\n    return remove;\n  }();\n  _proto.removeAsync = function () {\n    function removeAsync(selector, callback) {\n      var _this7 = this;\n      var _this$prepareRemove2, queriesToRecompute, queryRemove, remove, _iterator, _step, _remove, query, result;\n      return _regeneratorRuntime.async(function () {\n        function removeAsync$(_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n              if (!(this.paused && !this._savedOriginals && EJSON.equals(selector, {}))) {\n                _context3.next = 2;\n                break;\n              }\n              return _context3.abrupt(\"return\", this.clearResultQueries(callback));\n            case 2:\n              _this$prepareRemove2 = this.prepareRemove(selector), queriesToRecompute = _this$prepareRemove2.queriesToRecompute, queryRemove = _this$prepareRemove2.queryRemove, remove = _this$prepareRemove2.remove; // run live query callbacks _after_ we've removed the documents.\n              _iterator = _createForOfIteratorHelperLoose(queryRemove);\n            case 4:\n              if ((_step = _iterator()).done) {\n                _context3.next = 13;\n                break;\n              }\n              _remove = _step.value;\n              query = this.queries[_remove.qid];\n              if (!query) {\n                _context3.next = 11;\n                break;\n              }\n              query.distances && query.distances.remove(_remove.doc._id);\n              _context3.next = 11;\n              return _regeneratorRuntime.awrap(LocalCollection._removeFromResultsAsync(query, _remove.doc));\n            case 11:\n              _context3.next = 4;\n              break;\n            case 13:\n              queriesToRecompute.forEach(function (qid) {\n                var query = _this7.queries[qid];\n                if (query) {\n                  _this7._recomputeResults(query);\n                }\n              });\n              _context3.next = 16;\n              return _regeneratorRuntime.awrap(this._observeQueue.drain());\n            case 16:\n              result = remove.length;\n              if (callback) {\n                Meteor.defer(function () {\n                  callback(null, result);\n                });\n              }\n              return _context3.abrupt(\"return\", result);\n            case 19:\n            case \"end\":\n              return _context3.stop();\n          }\n        }\n        return removeAsync$;\n      }(), null, this, null, Promise);\n    }\n    return removeAsync;\n  }() // Resume the observers. Observers immediately receive change\n  // notifications to bring them to the current state of the\n  // database. Note that this is not just replaying all the changes that\n  // happened during the pause, it is a smarter 'coalesced' diff.\n  ;\n  _proto._resumeObservers = function () {\n    function _resumeObservers() {\n      var _this8 = this;\n      // No-op if not paused.\n      if (!this.paused) {\n        return;\n      }\n\n      // Unset the 'paused' flag. Make sure to do this first, otherwise\n      // observer methods won't actually fire when we trigger them.\n      this.paused = false;\n      Object.keys(this.queries).forEach(function (qid) {\n        var query = _this8.queries[qid];\n        if (query.dirty) {\n          query.dirty = false;\n\n          // re-compute results will perform `LocalCollection._diffQueryChanges`\n          // automatically.\n          _this8._recomputeResults(query, query.resultsSnapshot);\n        } else {\n          // Diff the current results against the snapshot and send to observers.\n          // pass the query object for its observer callbacks.\n          LocalCollection._diffQueryChanges(query.ordered, query.resultsSnapshot, query.results, query, {\n            projectionFn: query.projectionFn\n          });\n        }\n        query.resultsSnapshot = null;\n      });\n    }\n    return _resumeObservers;\n  }();\n  _proto.resumeObserversServer = function () {\n    function resumeObserversServer() {\n      return _regeneratorRuntime.async(function () {\n        function resumeObserversServer$(_context4) {\n          while (1) switch (_context4.prev = _context4.next) {\n            case 0:\n              this._resumeObservers();\n              _context4.next = 3;\n              return _regeneratorRuntime.awrap(this._observeQueue.drain());\n            case 3:\n            case \"end\":\n              return _context4.stop();\n          }\n        }\n        return resumeObserversServer$;\n      }(), null, this, null, Promise);\n    }\n    return resumeObserversServer;\n  }();\n  _proto.resumeObserversClient = function () {\n    function resumeObserversClient() {\n      this._resumeObservers();\n      this._observeQueue.drain();\n    }\n    return resumeObserversClient;\n  }();\n  _proto.retrieveOriginals = function () {\n    function retrieveOriginals() {\n      if (!this._savedOriginals) {\n        throw new Error('Called retrieveOriginals without saveOriginals');\n      }\n      var originals = this._savedOriginals;\n      this._savedOriginals = null;\n      return originals;\n    }\n    return retrieveOriginals;\n  }() // To track what documents are affected by a piece of code, call\n  // saveOriginals() before it and retrieveOriginals() after it.\n  // retrieveOriginals returns an object whose keys are the ids of the documents\n  // that were affected since the call to saveOriginals(), and the values are\n  // equal to the document's contents at the time of saveOriginals. (In the case\n  // of an inserted document, undefined is the value.) You must alternate\n  // between calls to saveOriginals() and retrieveOriginals().\n  ;\n  _proto.saveOriginals = function () {\n    function saveOriginals() {\n      if (this._savedOriginals) {\n        throw new Error('Called saveOriginals twice without retrieveOriginals');\n      }\n      this._savedOriginals = new LocalCollection._IdMap();\n    }\n    return saveOriginals;\n  }();\n  _proto.prepareUpdate = function () {\n    function prepareUpdate(selector) {\n      var _this9 = this;\n      // Save the original results of any query that we might need to\n      // _recomputeResults on, because _modifyAndNotify will mutate the objects in\n      // it. (We don't need to save the original results of paused queries because\n      // they already have a resultsSnapshot and we won't be diffing in\n      // _recomputeResults.)\n      var qidToOriginalResults = {};\n\n      // We should only clone each document once, even if it appears in multiple\n      // queries\n      var docMap = new LocalCollection._IdMap();\n      var idsMatched = LocalCollection._idsMatchedBySelector(selector);\n      Object.keys(this.queries).forEach(function (qid) {\n        var query = _this9.queries[qid];\n        if ((query.cursor.skip || query.cursor.limit) && !_this9.paused) {\n          // Catch the case of a reactive `count()` on a cursor with skip\n          // or limit, which registers an unordered observe. This is a\n          // pretty rare case, so we just clone the entire result set with\n          // no optimizations for documents that appear in these result\n          // sets and other queries.\n          if (query.results instanceof LocalCollection._IdMap) {\n            qidToOriginalResults[qid] = query.results.clone();\n            return;\n          }\n          if (!(query.results instanceof Array)) {\n            throw new Error('Assertion failed: query.results not an array');\n          }\n\n          // Clones a document to be stored in `qidToOriginalResults`\n          // because it may be modified before the new and old result sets\n          // are diffed. But if we know exactly which document IDs we're\n          // going to modify, then we only need to clone those.\n          var memoizedCloneIfNeeded = function (doc) {\n            if (docMap.has(doc._id)) {\n              return docMap.get(doc._id);\n            }\n            var docToMemoize = idsMatched && !idsMatched.some(function (id) {\n              return EJSON.equals(id, doc._id);\n            }) ? doc : EJSON.clone(doc);\n            docMap.set(doc._id, docToMemoize);\n            return docToMemoize;\n          };\n          qidToOriginalResults[qid] = query.results.map(memoizedCloneIfNeeded);\n        }\n      });\n      return qidToOriginalResults;\n    }\n    return prepareUpdate;\n  }();\n  _proto.finishUpdate = function () {\n    function finishUpdate(_ref) {\n      var options = _ref.options,\n        updateCount = _ref.updateCount,\n        callback = _ref.callback,\n        insertedId = _ref.insertedId;\n      // Return the number of affected documents, or in the upsert case, an object\n      // containing the number of affected docs and the id of the doc that was\n      // inserted, if any.\n      var result;\n      if (options._returnObject) {\n        result = {\n          numberAffected: updateCount\n        };\n        if (insertedId !== undefined) {\n          result.insertedId = insertedId;\n        }\n      } else {\n        result = updateCount;\n      }\n      if (callback) {\n        Meteor.defer(function () {\n          callback(null, result);\n        });\n      }\n      return result;\n    }\n    return finishUpdate;\n  }() // XXX atomicity: if multi is true, and one modification fails, do\n  // we rollback the whole operation, or what?\n  ;\n  _proto.updateAsync = function () {\n    function updateAsync(selector, mod, options, callback) {\n      var _this10 = this;\n      var matcher, qidToOriginalResults, recomputeQids, updateCount, insertedId, doc;\n      return _regeneratorRuntime.async(function () {\n        function updateAsync$(_context6) {\n          while (1) switch (_context6.prev = _context6.next) {\n            case 0:\n              if (!callback && options instanceof Function) {\n                callback = options;\n                options = null;\n              }\n              if (!options) {\n                options = {};\n              }\n              matcher = new Minimongo.Matcher(selector, true);\n              qidToOriginalResults = this.prepareUpdate(selector);\n              recomputeQids = {};\n              updateCount = 0;\n              _context6.next = 8;\n              return _regeneratorRuntime.awrap(this._eachPossiblyMatchingDocAsync(selector, function () {\n                function _callee(doc, id) {\n                  var queryResult;\n                  return _regeneratorRuntime.async(function () {\n                    function _callee$(_context5) {\n                      while (1) switch (_context5.prev = _context5.next) {\n                        case 0:\n                          queryResult = matcher.documentMatches(doc);\n                          if (!queryResult.result) {\n                            _context5.next = 9;\n                            break;\n                          }\n                          // XXX Should we save the original even if mod ends up being a no-op?\n                          _this10._saveOriginal(id, doc);\n                          _context5.next = 5;\n                          return _regeneratorRuntime.awrap(_this10._modifyAndNotifyAsync(doc, mod, queryResult.arrayIndices));\n                        case 5:\n                          recomputeQids = _context5.sent;\n                          ++updateCount;\n                          if (options.multi) {\n                            _context5.next = 9;\n                            break;\n                          }\n                          return _context5.abrupt(\"return\", false);\n                        case 9:\n                          return _context5.abrupt(\"return\", true);\n                        case 10:\n                        case \"end\":\n                          return _context5.stop();\n                      }\n                    }\n                    return _callee$;\n                  }(), null, null, null, Promise);\n                }\n                return _callee;\n              }()));\n            case 8:\n              Object.keys(recomputeQids).forEach(function (qid) {\n                var query = _this10.queries[qid];\n                if (query) {\n                  _this10._recomputeResults(query, qidToOriginalResults[qid]);\n                }\n              });\n              _context6.next = 11;\n              return _regeneratorRuntime.awrap(this._observeQueue.drain());\n            case 11:\n              if (!(updateCount === 0 && options.upsert)) {\n                _context6.next = 18;\n                break;\n              }\n              doc = LocalCollection._createUpsertDocument(selector, mod);\n              if (!doc._id && options.insertedId) {\n                doc._id = options.insertedId;\n              }\n              _context6.next = 16;\n              return _regeneratorRuntime.awrap(this.insertAsync(doc));\n            case 16:\n              insertedId = _context6.sent;\n              updateCount = 1;\n            case 18:\n              return _context6.abrupt(\"return\", this.finishUpdate({\n                options: options,\n                insertedId: insertedId,\n                updateCount: updateCount,\n                callback: callback\n              }));\n            case 19:\n            case \"end\":\n              return _context6.stop();\n          }\n        }\n        return updateAsync$;\n      }(), null, this, null, Promise);\n    }\n    return updateAsync;\n  }() // XXX atomicity: if multi is true, and one modification fails, do\n  // we rollback the whole operation, or what?\n  ;\n  _proto.update = function () {\n    function update(selector, mod, options, callback) {\n      var _this11 = this;\n      if (!callback && options instanceof Function) {\n        callback = options;\n        options = null;\n      }\n      if (!options) {\n        options = {};\n      }\n      var matcher = new Minimongo.Matcher(selector, true);\n      var qidToOriginalResults = this.prepareUpdate(selector);\n      var recomputeQids = {};\n      var updateCount = 0;\n      this._eachPossiblyMatchingDocSync(selector, function (doc, id) {\n        var queryResult = matcher.documentMatches(doc);\n        if (queryResult.result) {\n          // XXX Should we save the original even if mod ends up being a no-op?\n          _this11._saveOriginal(id, doc);\n          recomputeQids = _this11._modifyAndNotifySync(doc, mod, queryResult.arrayIndices);\n          ++updateCount;\n          if (!options.multi) {\n            return false; // break\n          }\n        }\n        return true;\n      });\n      Object.keys(recomputeQids).forEach(function (qid) {\n        var query = _this11.queries[qid];\n        if (query) {\n          _this11._recomputeResults(query, qidToOriginalResults[qid]);\n        }\n      });\n      this._observeQueue.drain();\n\n      // If we are doing an upsert, and we didn't modify any documents yet, then\n      // it's time to do an insert. Figure out what document we are inserting, and\n      // generate an id for it.\n      var insertedId;\n      if (updateCount === 0 && options.upsert) {\n        var doc = LocalCollection._createUpsertDocument(selector, mod);\n        if (!doc._id && options.insertedId) {\n          doc._id = options.insertedId;\n        }\n        insertedId = this.insert(doc);\n        updateCount = 1;\n      }\n      return this.finishUpdate({\n        options: options,\n        updateCount: updateCount,\n        callback: callback,\n        selector: selector,\n        mod: mod\n      });\n    }\n    return update;\n  }() // A convenience wrapper on update. LocalCollection.upsert(sel, mod) is\n  // equivalent to LocalCollection.update(sel, mod, {upsert: true,\n  // _returnObject: true}).\n  ;\n  _proto.upsert = function () {\n    function upsert(selector, mod, options, callback) {\n      if (!callback && typeof options === 'function') {\n        callback = options;\n        options = {};\n      }\n      return this.update(selector, mod, Object.assign({}, options, {\n        upsert: true,\n        _returnObject: true\n      }), callback);\n    }\n    return upsert;\n  }();\n  _proto.upsertAsync = function () {\n    function upsertAsync(selector, mod, options, callback) {\n      if (!callback && typeof options === 'function') {\n        callback = options;\n        options = {};\n      }\n      return this.updateAsync(selector, mod, Object.assign({}, options, {\n        upsert: true,\n        _returnObject: true\n      }), callback);\n    }\n    return upsertAsync;\n  }() // Iterates over a subset of documents that could match selector; calls\n  // fn(doc, id) on each of them.  Specifically, if selector specifies\n  // specific _id's, it only looks at those.  doc is *not* cloned: it is the\n  // same object that is in _docs.\n  ;\n  _proto._eachPossiblyMatchingDocAsync = function () {\n    function _eachPossiblyMatchingDocAsync(selector, fn) {\n      var specificIds, _iterator2, _step2, id, doc;\n      return _regeneratorRuntime.async(function () {\n        function _eachPossiblyMatchingDocAsync$(_context7) {\n          while (1) switch (_context7.prev = _context7.next) {\n            case 0:\n              specificIds = LocalCollection._idsMatchedBySelector(selector);\n              if (!specificIds) {\n                _context7.next = 17;\n                break;\n              }\n              _iterator2 = _createForOfIteratorHelperLoose(specificIds);\n            case 3:\n              if ((_step2 = _iterator2()).done) {\n                _context7.next = 15;\n                break;\n              }\n              id = _step2.value;\n              doc = this._docs.get(id);\n              _context7.t0 = doc;\n              if (!_context7.t0) {\n                _context7.next = 11;\n                break;\n              }\n              _context7.next = 10;\n              return _regeneratorRuntime.awrap(fn(doc, id));\n            case 10:\n              _context7.t0 = !_context7.sent;\n            case 11:\n              if (!_context7.t0) {\n                _context7.next = 13;\n                break;\n              }\n              return _context7.abrupt(\"break\", 15);\n            case 13:\n              _context7.next = 3;\n              break;\n            case 15:\n              _context7.next = 19;\n              break;\n            case 17:\n              _context7.next = 19;\n              return _regeneratorRuntime.awrap(this._docs.forEachAsync(fn));\n            case 19:\n            case \"end\":\n              return _context7.stop();\n          }\n        }\n        return _eachPossiblyMatchingDocAsync$;\n      }(), null, this, null, Promise);\n    }\n    return _eachPossiblyMatchingDocAsync;\n  }();\n  _proto._eachPossiblyMatchingDocSync = function () {\n    function _eachPossiblyMatchingDocSync(selector, fn) {\n      var specificIds = LocalCollection._idsMatchedBySelector(selector);\n      if (specificIds) {\n        for (var _iterator3 = _createForOfIteratorHelperLoose(specificIds), _step3; !(_step3 = _iterator3()).done;) {\n          var id = _step3.value;\n          var doc = this._docs.get(id);\n          if (doc && !fn(doc, id)) {\n            break;\n          }\n        }\n      } else {\n        this._docs.forEach(fn);\n      }\n    }\n    return _eachPossiblyMatchingDocSync;\n  }();\n  _proto._getMatchedDocAndModify = function () {\n    function _getMatchedDocAndModify(doc, mod, arrayIndices) {\n      var _this12 = this;\n      var matched_before = {};\n      Object.keys(this.queries).forEach(function (qid) {\n        var query = _this12.queries[qid];\n        if (query.dirty) {\n          return;\n        }\n        if (query.ordered) {\n          matched_before[qid] = query.matcher.documentMatches(doc).result;\n        } else {\n          // Because we don't support skip or limit (yet) in unordered queries, we\n          // can just do a direct lookup.\n          matched_before[qid] = query.results.has(doc._id);\n        }\n      });\n      return matched_before;\n    }\n    return _getMatchedDocAndModify;\n  }();\n  _proto._modifyAndNotifySync = function () {\n    function _modifyAndNotifySync(doc, mod, arrayIndices) {\n      var matched_before = this._getMatchedDocAndModify(doc, mod, arrayIndices);\n      var old_doc = EJSON.clone(doc);\n      LocalCollection._modify(doc, mod, {\n        arrayIndices: arrayIndices\n      });\n      var recomputeQids = {};\n      for (var _i3 = 0, _Object$keys3 = Object.keys(this.queries); _i3 < _Object$keys3.length; _i3++) {\n        var qid = _Object$keys3[_i3];\n        var query = this.queries[qid];\n        if (query.dirty) {\n          continue;\n        }\n        var afterMatch = query.matcher.documentMatches(doc);\n        var after = afterMatch.result;\n        var before = matched_before[qid];\n        if (after && query.distances && afterMatch.distance !== undefined) {\n          query.distances.set(doc._id, afterMatch.distance);\n        }\n        if (query.cursor.skip || query.cursor.limit) {\n          // We need to recompute any query where the doc may have been in the\n          // cursor's window either before or after the update. (Note that if skip\n          // or limit is set, \"before\" and \"after\" being true do not necessarily\n          // mean that the document is in the cursor's output after skip/limit is\n          // applied... but if they are false, then the document definitely is NOT\n          // in the output. So it's safe to skip recompute if neither before or\n          // after are true.)\n          if (before || after) {\n            recomputeQids[qid] = true;\n          }\n        } else if (before && !after) {\n          LocalCollection._removeFromResultsSync(query, doc);\n        } else if (!before && after) {\n          LocalCollection._insertInResultsSync(query, doc);\n        } else if (before && after) {\n          LocalCollection._updateInResultsSync(query, doc, old_doc);\n        }\n      }\n      return recomputeQids;\n    }\n    return _modifyAndNotifySync;\n  }();\n  _proto._modifyAndNotifyAsync = function () {\n    function _modifyAndNotifyAsync(doc, mod, arrayIndices) {\n      var matched_before, old_doc, recomputeQids, _i4, _Object$keys4, qid, query, afterMatch, after, before;\n      return _regeneratorRuntime.async(function () {\n        function _modifyAndNotifyAsync$(_context8) {\n          while (1) switch (_context8.prev = _context8.next) {\n            case 0:\n              matched_before = this._getMatchedDocAndModify(doc, mod, arrayIndices);\n              old_doc = EJSON.clone(doc);\n              LocalCollection._modify(doc, mod, {\n                arrayIndices: arrayIndices\n              });\n              recomputeQids = {};\n              _i4 = 0, _Object$keys4 = Object.keys(this.queries);\n            case 5:\n              if (!(_i4 < _Object$keys4.length)) {\n                _context8.next = 34;\n                break;\n              }\n              qid = _Object$keys4[_i4];\n              query = this.queries[qid];\n              if (!query.dirty) {\n                _context8.next = 10;\n                break;\n              }\n              return _context8.abrupt(\"continue\", 31);\n            case 10:\n              afterMatch = query.matcher.documentMatches(doc);\n              after = afterMatch.result;\n              before = matched_before[qid];\n              if (after && query.distances && afterMatch.distance !== undefined) {\n                query.distances.set(doc._id, afterMatch.distance);\n              }\n              if (!(query.cursor.skip || query.cursor.limit)) {\n                _context8.next = 18;\n                break;\n              }\n              // We need to recompute any query where the doc may have been in the\n              // cursor's window either before or after the update. (Note that if skip\n              // or limit is set, \"before\" and \"after\" being true do not necessarily\n              // mean that the document is in the cursor's output after skip/limit is\n              // applied... but if they are false, then the document definitely is NOT\n              // in the output. So it's safe to skip recompute if neither before or\n              // after are true.)\n              if (before || after) {\n                recomputeQids[qid] = true;\n              }\n              _context8.next = 31;\n              break;\n            case 18:\n              if (!(before && !after)) {\n                _context8.next = 23;\n                break;\n              }\n              _context8.next = 21;\n              return _regeneratorRuntime.awrap(LocalCollection._removeFromResultsAsync(query, doc));\n            case 21:\n              _context8.next = 31;\n              break;\n            case 23:\n              if (!(!before && after)) {\n                _context8.next = 28;\n                break;\n              }\n              _context8.next = 26;\n              return _regeneratorRuntime.awrap(LocalCollection._insertInResultsAsync(query, doc));\n            case 26:\n              _context8.next = 31;\n              break;\n            case 28:\n              if (!(before && after)) {\n                _context8.next = 31;\n                break;\n              }\n              _context8.next = 31;\n              return _regeneratorRuntime.awrap(LocalCollection._updateInResultsAsync(query, doc, old_doc));\n            case 31:\n              _i4++;\n              _context8.next = 5;\n              break;\n            case 34:\n              return _context8.abrupt(\"return\", recomputeQids);\n            case 35:\n            case \"end\":\n              return _context8.stop();\n          }\n        }\n        return _modifyAndNotifyAsync$;\n      }(), null, this, null, Promise);\n    }\n    return _modifyAndNotifyAsync;\n  }() // Recomputes the results of a query and runs observe callbacks for the\n  // difference between the previous results and the current results (unless\n  // paused). Used for skip/limit queries.\n  //\n  // When this is used by insert or remove, it can just use query.results for\n  // the old results (and there's no need to pass in oldResults), because these\n  // operations don't mutate the documents in the collection. Update needs to\n  // pass in an oldResults which was deep-copied before the modifier was\n  // applied.\n  //\n  // oldResults is guaranteed to be ignored if the query is not paused.\n  ;\n  _proto._recomputeResults = function () {\n    function _recomputeResults(query, oldResults) {\n      if (this.paused) {\n        // There's no reason to recompute the results now as we're still paused.\n        // By flagging the query as \"dirty\", the recompute will be performed\n        // when resumeObservers is called.\n        query.dirty = true;\n        return;\n      }\n      if (!this.paused && !oldResults) {\n        oldResults = query.results;\n      }\n      if (query.distances) {\n        query.distances.clear();\n      }\n      query.results = query.cursor._getRawObjects({\n        distances: query.distances,\n        ordered: query.ordered\n      });\n      if (!this.paused) {\n        LocalCollection._diffQueryChanges(query.ordered, oldResults, query.results, query, {\n          projectionFn: query.projectionFn\n        });\n      }\n    }\n    return _recomputeResults;\n  }();\n  _proto._saveOriginal = function () {\n    function _saveOriginal(id, doc) {\n      // Are we even trying to save originals?\n      if (!this._savedOriginals) {\n        return;\n      }\n\n      // Have we previously mutated the original (and so 'doc' is not actually\n      // original)?  (Note the 'has' check rather than truth: we store undefined\n      // here for inserted docs!)\n      if (this._savedOriginals.has(id)) {\n        return;\n      }\n      this._savedOriginals.set(id, EJSON.clone(doc));\n    }\n    return _saveOriginal;\n  }();\n  return LocalCollection;\n}();\nLocalCollection.Cursor = Cursor;\nLocalCollection.ObserveHandle = ObserveHandle;\n\n// XXX maybe move these into another ObserveHelpers package or something\n\n// _CachingChangeObserver is an object which receives observeChanges callbacks\n// and keeps a cache of the current cursor state up to date in this.docs. Users\n// of this class should read the docs field but not modify it. You should pass\n// the \"applyChange\" field as the callbacks to the underlying observeChanges\n// call. Optionally, you can specify your own observeChanges callbacks which are\n// invoked immediately before the docs field is updated; this object is made\n// available as `this` to those callbacks.\nLocalCollection._CachingChangeObserver = function () {\n  function _CachingChangeObserver() {\n    var _this13 = this;\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var orderedFromCallbacks = options.callbacks && LocalCollection._observeChangesCallbacksAreOrdered(options.callbacks);\n    if (hasOwn.call(options, 'ordered')) {\n      this.ordered = options.ordered;\n      if (options.callbacks && options.ordered !== orderedFromCallbacks) {\n        throw Error('ordered option doesn\\'t match callbacks');\n      }\n    } else if (options.callbacks) {\n      this.ordered = orderedFromCallbacks;\n    } else {\n      throw Error('must provide ordered or callbacks');\n    }\n    var callbacks = options.callbacks || {};\n    if (this.ordered) {\n      this.docs = new OrderedDict(MongoID.idStringify);\n      this.applyChange = {\n        addedBefore: function (id, fields, before) {\n          // Take a shallow copy since the top-level properties can be changed\n          var doc = _objectSpread({}, fields);\n          doc._id = id;\n          if (callbacks.addedBefore) {\n            callbacks.addedBefore.call(_this13, id, EJSON.clone(fields), before);\n          }\n\n          // This line triggers if we provide added with movedBefore.\n          if (callbacks.added) {\n            callbacks.added.call(_this13, id, EJSON.clone(fields));\n          }\n\n          // XXX could `before` be a falsy ID?  Technically\n          // idStringify seems to allow for them -- though\n          // OrderedDict won't call stringify on a falsy arg.\n          _this13.docs.putBefore(id, doc, before || null);\n        },\n        movedBefore: function (id, before) {\n          if (callbacks.movedBefore) {\n            callbacks.movedBefore.call(_this13, id, before);\n          }\n          _this13.docs.moveBefore(id, before || null);\n        }\n      };\n    } else {\n      this.docs = new LocalCollection._IdMap();\n      this.applyChange = {\n        added: function (id, fields) {\n          // Take a shallow copy since the top-level properties can be changed\n          var doc = _objectSpread({}, fields);\n          if (callbacks.added) {\n            callbacks.added.call(_this13, id, EJSON.clone(fields));\n          }\n          doc._id = id;\n          _this13.docs.set(id, doc);\n        }\n      };\n    }\n\n    // The methods in _IdMap and OrderedDict used by these callbacks are\n    // identical.\n    this.applyChange.changed = function (id, fields) {\n      var doc = _this13.docs.get(id);\n      if (!doc) {\n        throw new Error(\"Unknown id for changed: \" + id);\n      }\n      if (callbacks.changed) {\n        callbacks.changed.call(_this13, id, EJSON.clone(fields));\n      }\n      DiffSequence.applyChanges(doc, fields);\n    };\n    this.applyChange.removed = function (id) {\n      if (callbacks.removed) {\n        callbacks.removed.call(_this13, id);\n      }\n      _this13.docs.remove(id);\n    };\n  }\n  return _CachingChangeObserver;\n}();\nLocalCollection._IdMap = /*#__PURE__*/function (_IdMap2) {\n  function _IdMap() {\n    return _IdMap2.call(this, MongoID.idStringify, MongoID.idParse) || this;\n  }\n  _inheritsLoose(_IdMap, _IdMap2);\n  return _IdMap;\n}(IdMap);\n\n// Wrap a transform function to return objects that have the _id field\n// of the untransformed document. This ensures that subsystems such as\n// the observe-sequence package that call `observe` can keep track of\n// the documents identities.\n//\n// - Require that it returns objects\n// - If the return value has an _id field, verify that it matches the\n//   original _id field\n// - If the return value doesn't have an _id field, add it back.\nLocalCollection.wrapTransform = function (transform) {\n  if (!transform) {\n    return null;\n  }\n\n  // No need to doubly-wrap transforms.\n  if (transform.__wrappedTransform__) {\n    return transform;\n  }\n  var wrapped = function (doc) {\n    if (!hasOwn.call(doc, '_id')) {\n      // XXX do we ever have a transform on the oplog's collection? because that\n      // collection has no _id.\n      throw new Error('can only transform documents with _id');\n    }\n    var id = doc._id;\n\n    // XXX consider making tracker a weak dependency and checking\n    // Package.tracker here\n    var transformed = Tracker.nonreactive(function () {\n      return transform(doc);\n    });\n    if (!LocalCollection._isPlainObject(transformed)) {\n      throw new Error('transform must return object');\n    }\n    if (hasOwn.call(transformed, '_id')) {\n      if (!EJSON.equals(transformed._id, id)) {\n        throw new Error('transformed document can\\'t have different _id');\n      }\n    } else {\n      transformed._id = id;\n    }\n    return transformed;\n  };\n  wrapped.__wrappedTransform__ = true;\n  return wrapped;\n};\n\n// XXX the sorted-query logic below is laughably inefficient. we'll\n// need to come up with a better datastructure for this.\n//\n// XXX the logic for observing with a skip or a limit is even more\n// laughably inefficient. we recompute the whole results every time!\n\n// This binary search puts a value between any equal values, and the first\n// lesser value.\nLocalCollection._binarySearch = function (cmp, array, value) {\n  var first = 0;\n  var range = array.length;\n  while (range > 0) {\n    var halfRange = Math.floor(range / 2);\n    if (cmp(value, array[first + halfRange]) >= 0) {\n      first += halfRange + 1;\n      range -= halfRange + 1;\n    } else {\n      range = halfRange;\n    }\n  }\n  return first;\n};\nLocalCollection._checkSupportedProjection = function (fields) {\n  if (fields !== Object(fields) || Array.isArray(fields)) {\n    throw MinimongoError('fields option must be an object');\n  }\n  Object.keys(fields).forEach(function (keyPath) {\n    if (keyPath.split('.').includes('$')) {\n      throw MinimongoError('Minimongo doesn\\'t support $ operator in projections yet.');\n    }\n    var value = fields[keyPath];\n    if (_typeof(value) === 'object' && ['$elemMatch', '$meta', '$slice'].some(function (key) {\n      return hasOwn.call(value, key);\n    })) {\n      throw MinimongoError('Minimongo doesn\\'t support operators in projections yet.');\n    }\n    if (![1, 0, true, false].includes(value)) {\n      throw MinimongoError('Projection values should be one of 1, 0, true, or false');\n    }\n  });\n};\n\n// Knows how to compile a fields projection to a predicate function.\n// @returns - Function: a closure that filters out an object according to the\n//            fields projection rules:\n//            @param obj - Object: MongoDB-styled document\n//            @returns - Object: a document with the fields filtered out\n//                       according to projection rules. Doesn't retain subfields\n//                       of passed argument.\nLocalCollection._compileProjection = function (fields) {\n  LocalCollection._checkSupportedProjection(fields);\n  var _idProjection = fields._id === undefined ? true : fields._id;\n  var details = projectionDetails(fields);\n\n  // returns transformed doc according to ruleTree\n  var transform = function (doc, ruleTree) {\n    // Special case for \"sets\"\n    if (Array.isArray(doc)) {\n      return doc.map(function (subdoc) {\n        return transform(subdoc, ruleTree);\n      });\n    }\n    var result = details.including ? {} : EJSON.clone(doc);\n    Object.keys(ruleTree).forEach(function (key) {\n      if (doc == null || !hasOwn.call(doc, key)) {\n        return;\n      }\n      var rule = ruleTree[key];\n      if (rule === Object(rule)) {\n        // For sub-objects/subsets we branch\n        if (doc[key] === Object(doc[key])) {\n          result[key] = transform(doc[key], rule);\n        }\n      } else if (details.including) {\n        // Otherwise we don't even touch this subfield\n        result[key] = EJSON.clone(doc[key]);\n      } else {\n        delete result[key];\n      }\n    });\n    return doc != null ? result : doc;\n  };\n  return function (doc) {\n    var result = transform(doc, details.tree);\n    if (_idProjection && hasOwn.call(doc, '_id')) {\n      result._id = doc._id;\n    }\n    if (!_idProjection && hasOwn.call(result, '_id')) {\n      delete result._id;\n    }\n    return result;\n  };\n};\n\n// Calculates the document to insert in case we're doing an upsert and the\n// selector does not match any elements\nLocalCollection._createUpsertDocument = function (selector, modifier) {\n  var selectorDocument = populateDocumentWithQueryFields(selector);\n  var isModify = LocalCollection._isModificationMod(modifier);\n  var newDoc = {};\n  if (selectorDocument._id) {\n    newDoc._id = selectorDocument._id;\n    delete selectorDocument._id;\n  }\n\n  // This double _modify call is made to help with nested properties (see issue\n  // #8631). We do this even if it's a replacement for validation purposes (e.g.\n  // ambiguous id's)\n  LocalCollection._modify(newDoc, {\n    $set: selectorDocument\n  });\n  LocalCollection._modify(newDoc, modifier, {\n    isInsert: true\n  });\n  if (isModify) {\n    return newDoc;\n  }\n\n  // Replacement can take _id from query document\n  var replacement = Object.assign({}, modifier);\n  if (newDoc._id) {\n    replacement._id = newDoc._id;\n  }\n  return replacement;\n};\nLocalCollection._diffObjects = function (left, right, callbacks) {\n  return DiffSequence.diffObjects(left, right, callbacks);\n};\n\n// ordered: bool.\n// old_results and new_results: collections of documents.\n//    if ordered, they are arrays.\n//    if unordered, they are IdMaps\nLocalCollection._diffQueryChanges = function (ordered, oldResults, newResults, observer, options) {\n  return DiffSequence.diffQueryChanges(ordered, oldResults, newResults, observer, options);\n};\nLocalCollection._diffQueryOrderedChanges = function (oldResults, newResults, observer, options) {\n  return DiffSequence.diffQueryOrderedChanges(oldResults, newResults, observer, options);\n};\nLocalCollection._diffQueryUnorderedChanges = function (oldResults, newResults, observer, options) {\n  return DiffSequence.diffQueryUnorderedChanges(oldResults, newResults, observer, options);\n};\nLocalCollection._findInOrderedResults = function (query, doc) {\n  if (!query.ordered) {\n    throw new Error('Can\\'t call _findInOrderedResults on unordered query');\n  }\n  for (var i = 0; i < query.results.length; i++) {\n    if (query.results[i] === doc) {\n      return i;\n    }\n  }\n  throw Error('object missing from query');\n};\n\n// If this is a selector which explicitly constrains the match by ID to a finite\n// number of documents, returns a list of their IDs.  Otherwise returns\n// null. Note that the selector may have other restrictions so it may not even\n// match those document!  We care about $in and $and since those are generated\n// access-controlled update and remove.\nLocalCollection._idsMatchedBySelector = function (selector) {\n  // Is the selector just an ID?\n  if (LocalCollection._selectorIsId(selector)) {\n    return [selector];\n  }\n  if (!selector) {\n    return null;\n  }\n\n  // Do we have an _id clause?\n  if (hasOwn.call(selector, '_id')) {\n    // Is the _id clause just an ID?\n    if (LocalCollection._selectorIsId(selector._id)) {\n      return [selector._id];\n    }\n\n    // Is the _id clause {_id: {$in: [\"x\", \"y\", \"z\"]}}?\n    if (selector._id && Array.isArray(selector._id.$in) && selector._id.$in.length && selector._id.$in.every(LocalCollection._selectorIsId)) {\n      return selector._id.$in;\n    }\n    return null;\n  }\n\n  // If this is a top-level $and, and any of the clauses constrain their\n  // documents, then the whole selector is constrained by any one clause's\n  // constraint. (Well, by their intersection, but that seems unlikely.)\n  if (Array.isArray(selector.$and)) {\n    for (var i = 0; i < selector.$and.length; ++i) {\n      var subIds = LocalCollection._idsMatchedBySelector(selector.$and[i]);\n      if (subIds) {\n        return subIds;\n      }\n    }\n  }\n  return null;\n};\nLocalCollection._insertInResultsSync = function (query, doc) {\n  var fields = EJSON.clone(doc);\n  delete fields._id;\n  if (query.ordered) {\n    if (!query.sorter) {\n      query.addedBefore(doc._id, query.projectionFn(fields), null);\n      query.results.push(doc);\n    } else {\n      var i = LocalCollection._insertInSortedList(query.sorter.getComparator({\n        distances: query.distances\n      }), query.results, doc);\n      var next = query.results[i + 1];\n      if (next) {\n        next = next._id;\n      } else {\n        next = null;\n      }\n      query.addedBefore(doc._id, query.projectionFn(fields), next);\n    }\n    query.added(doc._id, query.projectionFn(fields));\n  } else {\n    query.added(doc._id, query.projectionFn(fields));\n    query.results.set(doc._id, doc);\n  }\n};\nLocalCollection._insertInResultsAsync = function () {\n  function _callee2(query, doc) {\n    var fields, i, next;\n    return _regeneratorRuntime.async(function () {\n      function _callee2$(_context9) {\n        while (1) switch (_context9.prev = _context9.next) {\n          case 0:\n            fields = EJSON.clone(doc);\n            delete fields._id;\n            if (!query.ordered) {\n              _context9.next = 18;\n              break;\n            }\n            if (query.sorter) {\n              _context9.next = 9;\n              break;\n            }\n            _context9.next = 6;\n            return _regeneratorRuntime.awrap(query.addedBefore(doc._id, query.projectionFn(fields), null));\n          case 6:\n            query.results.push(doc);\n            _context9.next = 14;\n            break;\n          case 9:\n            i = LocalCollection._insertInSortedList(query.sorter.getComparator({\n              distances: query.distances\n            }), query.results, doc);\n            next = query.results[i + 1];\n            if (next) {\n              next = next._id;\n            } else {\n              next = null;\n            }\n            _context9.next = 14;\n            return _regeneratorRuntime.awrap(query.addedBefore(doc._id, query.projectionFn(fields), next));\n          case 14:\n            _context9.next = 16;\n            return _regeneratorRuntime.awrap(query.added(doc._id, query.projectionFn(fields)));\n          case 16:\n            _context9.next = 21;\n            break;\n          case 18:\n            _context9.next = 20;\n            return _regeneratorRuntime.awrap(query.added(doc._id, query.projectionFn(fields)));\n          case 20:\n            query.results.set(doc._id, doc);\n          case 21:\n          case \"end\":\n            return _context9.stop();\n        }\n      }\n      return _callee2$;\n    }(), null, null, null, Promise);\n  }\n  return _callee2;\n}();\nLocalCollection._insertInSortedList = function (cmp, array, value) {\n  if (array.length === 0) {\n    array.push(value);\n    return 0;\n  }\n  var i = LocalCollection._binarySearch(cmp, array, value);\n  array.splice(i, 0, value);\n  return i;\n};\nLocalCollection._isModificationMod = function (mod) {\n  var isModify = false;\n  var isReplace = false;\n  Object.keys(mod).forEach(function (key) {\n    if (key.substr(0, 1) === '$') {\n      isModify = true;\n    } else {\n      isReplace = true;\n    }\n  });\n  if (isModify && isReplace) {\n    throw new Error('Update parameter cannot have both modifier and non-modifier fields.');\n  }\n  return isModify;\n};\n\n// XXX maybe this should be EJSON.isObject, though EJSON doesn't know about\n// RegExp\n// XXX note that _type(undefined) === 3!!!!\nLocalCollection._isPlainObject = function (x) {\n  return x && LocalCollection._f._type(x) === 3;\n};\n\n// XXX need a strategy for passing the binding of $ into this\n// function, from the compiled selector\n//\n// maybe just {key.up.to.just.before.dollarsign: array_index}\n//\n// XXX atomicity: if one modification fails, do we roll back the whole\n// change?\n//\n// options:\n//   - isInsert is set when _modify is being called to compute the document to\n//     insert as part of an upsert operation. We use this primarily to figure\n//     out when to set the fields in $setOnInsert, if present.\nLocalCollection._modify = function (doc, modifier) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  if (!LocalCollection._isPlainObject(modifier)) {\n    throw MinimongoError('Modifier must be an object');\n  }\n\n  // Make sure the caller can't mutate our data structures.\n  modifier = EJSON.clone(modifier);\n  var isModifier = isOperatorObject(modifier);\n  var newDoc = isModifier ? EJSON.clone(doc) : modifier;\n  if (isModifier) {\n    // apply modifiers to the doc.\n    Object.keys(modifier).forEach(function (operator) {\n      // Treat $setOnInsert as $set if this is an insert.\n      var setOnInsert = options.isInsert && operator === '$setOnInsert';\n      var modFunc = MODIFIERS[setOnInsert ? '$set' : operator];\n      var operand = modifier[operator];\n      if (!modFunc) {\n        throw MinimongoError(\"Invalid modifier specified \" + operator);\n      }\n      Object.keys(operand).forEach(function (keypath) {\n        var arg = operand[keypath];\n        if (keypath === '') {\n          throw MinimongoError('An empty update path is not valid.');\n        }\n        var keyparts = keypath.split('.');\n        if (!keyparts.every(Boolean)) {\n          throw MinimongoError(\"The update path '\" + keypath + \"' contains an empty field name, \" + 'which is not allowed.');\n        }\n        var target = findModTarget(newDoc, keyparts, {\n          arrayIndices: options.arrayIndices,\n          forbidArray: operator === '$rename',\n          noCreate: NO_CREATE_MODIFIERS[operator]\n        });\n        modFunc(target, keyparts.pop(), arg, keypath, newDoc);\n      });\n    });\n    if (doc._id && !EJSON.equals(doc._id, newDoc._id)) {\n      throw MinimongoError(\"After applying the update to the document {_id: \\\"\" + doc._id + \"\\\", ...},\" + ' the (immutable) field \\'_id\\' was found to have been altered to ' + (\"_id: \\\"\" + newDoc._id + \"\\\"\"));\n    }\n  } else {\n    if (doc._id && modifier._id && !EJSON.equals(doc._id, modifier._id)) {\n      throw MinimongoError(\"The _id field cannot be changed from {_id: \\\"\" + doc._id + \"\\\"} to \" + (\"{_id: \\\"\" + modifier._id + \"\\\"}\"));\n    }\n\n    // replace the whole document\n    assertHasValidFieldNames(modifier);\n  }\n\n  // move new document into place.\n  Object.keys(doc).forEach(function (key) {\n    // Note: this used to be for (var key in doc) however, this does not\n    // work right in Opera. Deleting from a doc while iterating over it\n    // would sometimes cause opera to skip some keys.\n    if (key !== '_id') {\n      delete doc[key];\n    }\n  });\n  Object.keys(newDoc).forEach(function (key) {\n    doc[key] = newDoc[key];\n  });\n};\nLocalCollection._observeFromObserveChanges = function (cursor, observeCallbacks) {\n  var transform = cursor.getTransform() || function (doc) {\n    return doc;\n  };\n  var suppressed = !!observeCallbacks._suppress_initial;\n  var observeChangesCallbacks;\n  if (LocalCollection._observeCallbacksAreOrdered(observeCallbacks)) {\n    // The \"_no_indices\" option sets all index arguments to -1 and skips the\n    // linear scans required to generate them.  This lets observers that don't\n    // need absolute indices benefit from the other features of this API --\n    // relative order, transforms, and applyChanges -- without the speed hit.\n    var indices = !observeCallbacks._no_indices;\n    observeChangesCallbacks = {\n      addedBefore: function (id, fields, before) {\n        var check = suppressed || !(observeCallbacks.addedAt || observeCallbacks.added);\n        if (check) {\n          return;\n        }\n        var doc = transform(Object.assign(fields, {\n          _id: id\n        }));\n        if (observeCallbacks.addedAt) {\n          observeCallbacks.addedAt(doc, indices ? before ? this.docs.indexOf(before) : this.docs.size() : -1, before);\n        } else {\n          observeCallbacks.added(doc);\n        }\n      },\n      changed: function (id, fields) {\n        if (!(observeCallbacks.changedAt || observeCallbacks.changed)) {\n          return;\n        }\n        var doc = EJSON.clone(this.docs.get(id));\n        if (!doc) {\n          throw new Error(\"Unknown id for changed: \" + id);\n        }\n        var oldDoc = transform(EJSON.clone(doc));\n        DiffSequence.applyChanges(doc, fields);\n        if (observeCallbacks.changedAt) {\n          observeCallbacks.changedAt(transform(doc), oldDoc, indices ? this.docs.indexOf(id) : -1);\n        } else {\n          observeCallbacks.changed(transform(doc), oldDoc);\n        }\n      },\n      movedBefore: function (id, before) {\n        if (!observeCallbacks.movedTo) {\n          return;\n        }\n        var from = indices ? this.docs.indexOf(id) : -1;\n        var to = indices ? before ? this.docs.indexOf(before) : this.docs.size() : -1;\n\n        // When not moving backwards, adjust for the fact that removing the\n        // document slides everything back one slot.\n        if (to > from) {\n          --to;\n        }\n        observeCallbacks.movedTo(transform(EJSON.clone(this.docs.get(id))), from, to, before || null);\n      },\n      removed: function (id) {\n        if (!(observeCallbacks.removedAt || observeCallbacks.removed)) {\n          return;\n        }\n\n        // technically maybe there should be an EJSON.clone here, but it's about\n        // to be removed from this.docs!\n        var doc = transform(this.docs.get(id));\n        if (observeCallbacks.removedAt) {\n          observeCallbacks.removedAt(doc, indices ? this.docs.indexOf(id) : -1);\n        } else {\n          observeCallbacks.removed(doc);\n        }\n      }\n    };\n  } else {\n    observeChangesCallbacks = {\n      added: function (id, fields) {\n        if (!suppressed && observeCallbacks.added) {\n          observeCallbacks.added(transform(Object.assign(fields, {\n            _id: id\n          })));\n        }\n      },\n      changed: function (id, fields) {\n        if (observeCallbacks.changed) {\n          var oldDoc = this.docs.get(id);\n          var doc = EJSON.clone(oldDoc);\n          DiffSequence.applyChanges(doc, fields);\n          observeCallbacks.changed(transform(doc), transform(EJSON.clone(oldDoc)));\n        }\n      },\n      removed: function (id) {\n        if (observeCallbacks.removed) {\n          observeCallbacks.removed(transform(this.docs.get(id)));\n        }\n      }\n    };\n  }\n  var changeObserver = new LocalCollection._CachingChangeObserver({\n    callbacks: observeChangesCallbacks\n  });\n\n  // CachingChangeObserver clones all received input on its callbacks\n  // So we can mark it as safe to reduce the ejson clones.\n  // This is tested by the `mongo-livedata - (extended) scribbling` tests\n  changeObserver.applyChange._fromObserve = true;\n  var handle = cursor.observeChanges(changeObserver.applyChange, {\n    nonMutatingCallbacks: true\n  });\n\n  // If needed, re-enable callbacks as soon as the initial batch is ready.\n  var setSuppressed = function (h) {\n    var _h$isReadyPromise;\n    if (h.isReady) suppressed = false;else (_h$isReadyPromise = h.isReadyPromise) === null || _h$isReadyPromise === void 0 ? void 0 : _h$isReadyPromise.then(function () {\n      return suppressed = false;\n    });\n  };\n  // When we call cursor.observeChanges() it can be the on from\n  // the mongo package (instead of the minimongo one) and it doesn't have isReady and isReadyPromise\n  if (Meteor._isPromise(handle)) {\n    handle.then(setSuppressed);\n  } else {\n    setSuppressed(handle);\n  }\n  return handle;\n};\nLocalCollection._observeCallbacksAreOrdered = function (callbacks) {\n  if (callbacks.added && callbacks.addedAt) {\n    throw new Error('Please specify only one of added() and addedAt()');\n  }\n  if (callbacks.changed && callbacks.changedAt) {\n    throw new Error('Please specify only one of changed() and changedAt()');\n  }\n  if (callbacks.removed && callbacks.removedAt) {\n    throw new Error('Please specify only one of removed() and removedAt()');\n  }\n  return !!(callbacks.addedAt || callbacks.changedAt || callbacks.movedTo || callbacks.removedAt);\n};\nLocalCollection._observeChangesCallbacksAreOrdered = function (callbacks) {\n  if (callbacks.added && callbacks.addedBefore) {\n    throw new Error('Please specify only one of added() and addedBefore()');\n  }\n  return !!(callbacks.addedBefore || callbacks.movedBefore);\n};\nLocalCollection._removeFromResultsSync = function (query, doc) {\n  if (query.ordered) {\n    var i = LocalCollection._findInOrderedResults(query, doc);\n    query.removed(doc._id);\n    query.results.splice(i, 1);\n  } else {\n    var id = doc._id; // in case callback mutates doc\n\n    query.removed(doc._id);\n    query.results.remove(id);\n  }\n};\nLocalCollection._removeFromResultsAsync = function () {\n  function _callee3(query, doc) {\n    var i, id;\n    return _regeneratorRuntime.async(function () {\n      function _callee3$(_context10) {\n        while (1) switch (_context10.prev = _context10.next) {\n          case 0:\n            if (!query.ordered) {\n              _context10.next = 7;\n              break;\n            }\n            i = LocalCollection._findInOrderedResults(query, doc);\n            _context10.next = 4;\n            return _regeneratorRuntime.awrap(query.removed(doc._id));\n          case 4:\n            query.results.splice(i, 1);\n            _context10.next = 11;\n            break;\n          case 7:\n            id = doc._id; // in case callback mutates doc\n            _context10.next = 10;\n            return _regeneratorRuntime.awrap(query.removed(doc._id));\n          case 10:\n            query.results.remove(id);\n          case 11:\n          case \"end\":\n            return _context10.stop();\n        }\n      }\n      return _callee3$;\n    }(), null, null, null, Promise);\n  }\n  return _callee3;\n}();\n\n// Is this selector just shorthand for lookup by _id?\nLocalCollection._selectorIsId = function (selector) {\n  return typeof selector === 'number' || typeof selector === 'string' || selector instanceof MongoID.ObjectID;\n};\n\n// Is the selector just lookup by _id (shorthand or not)?\nLocalCollection._selectorIsIdPerhapsAsObject = function (selector) {\n  return LocalCollection._selectorIsId(selector) || LocalCollection._selectorIsId(selector && selector._id) && Object.keys(selector).length === 1;\n};\nLocalCollection._updateInResultsSync = function (query, doc, old_doc) {\n  if (!EJSON.equals(doc._id, old_doc._id)) {\n    throw new Error('Can\\'t change a doc\\'s _id while updating');\n  }\n  var projectionFn = query.projectionFn;\n  var changedFields = DiffSequence.makeChangedFields(projectionFn(doc), projectionFn(old_doc));\n  if (!query.ordered) {\n    if (Object.keys(changedFields).length) {\n      query.changed(doc._id, changedFields);\n      query.results.set(doc._id, doc);\n    }\n    return;\n  }\n  var old_idx = LocalCollection._findInOrderedResults(query, doc);\n  if (Object.keys(changedFields).length) {\n    query.changed(doc._id, changedFields);\n  }\n  if (!query.sorter) {\n    return;\n  }\n\n  // just take it out and put it back in again, and see if the index changes\n  query.results.splice(old_idx, 1);\n  var new_idx = LocalCollection._insertInSortedList(query.sorter.getComparator({\n    distances: query.distances\n  }), query.results, doc);\n  if (old_idx !== new_idx) {\n    var next = query.results[new_idx + 1];\n    if (next) {\n      next = next._id;\n    } else {\n      next = null;\n    }\n    query.movedBefore && query.movedBefore(doc._id, next);\n  }\n};\nLocalCollection._updateInResultsAsync = function () {\n  function _callee4(query, doc, old_doc) {\n    var projectionFn, changedFields, old_idx, new_idx, next;\n    return _regeneratorRuntime.async(function () {\n      function _callee4$(_context11) {\n        while (1) switch (_context11.prev = _context11.next) {\n          case 0:\n            if (EJSON.equals(doc._id, old_doc._id)) {\n              _context11.next = 2;\n              break;\n            }\n            throw new Error('Can\\'t change a doc\\'s _id while updating');\n          case 2:\n            projectionFn = query.projectionFn;\n            changedFields = DiffSequence.makeChangedFields(projectionFn(doc), projectionFn(old_doc));\n            if (query.ordered) {\n              _context11.next = 10;\n              break;\n            }\n            if (!Object.keys(changedFields).length) {\n              _context11.next = 9;\n              break;\n            }\n            _context11.next = 8;\n            return _regeneratorRuntime.awrap(query.changed(doc._id, changedFields));\n          case 8:\n            query.results.set(doc._id, doc);\n          case 9:\n            return _context11.abrupt(\"return\");\n          case 10:\n            old_idx = LocalCollection._findInOrderedResults(query, doc);\n            if (!Object.keys(changedFields).length) {\n              _context11.next = 14;\n              break;\n            }\n            _context11.next = 14;\n            return _regeneratorRuntime.awrap(query.changed(doc._id, changedFields));\n          case 14:\n            if (query.sorter) {\n              _context11.next = 16;\n              break;\n            }\n            return _context11.abrupt(\"return\");\n          case 16:\n            // just take it out and put it back in again, and see if the index changes\n            query.results.splice(old_idx, 1);\n            new_idx = LocalCollection._insertInSortedList(query.sorter.getComparator({\n              distances: query.distances\n            }), query.results, doc);\n            if (!(old_idx !== new_idx)) {\n              _context11.next = 25;\n              break;\n            }\n            next = query.results[new_idx + 1];\n            if (next) {\n              next = next._id;\n            } else {\n              next = null;\n            }\n            _context11.t0 = query.movedBefore;\n            if (!_context11.t0) {\n              _context11.next = 25;\n              break;\n            }\n            _context11.next = 25;\n            return _regeneratorRuntime.awrap(query.movedBefore(doc._id, next));\n          case 25:\n          case \"end\":\n            return _context11.stop();\n        }\n      }\n      return _callee4$;\n    }(), null, null, null, Promise);\n  }\n  return _callee4;\n}();\nvar MODIFIERS = {\n  $currentDate: function (target, field, arg) {\n    if (_typeof(arg) === 'object' && hasOwn.call(arg, '$type')) {\n      if (arg.$type !== 'date') {\n        throw MinimongoError('Minimongo does currently only support the date type in ' + '$currentDate modifiers', {\n          field: field\n        });\n      }\n    } else if (arg !== true) {\n      throw MinimongoError('Invalid $currentDate modifier', {\n        field: field\n      });\n    }\n    target[field] = new Date();\n  },\n  $inc: function (target, field, arg) {\n    if (typeof arg !== 'number') {\n      throw MinimongoError('Modifier $inc allowed for numbers only', {\n        field: field\n      });\n    }\n    if (field in target) {\n      if (typeof target[field] !== 'number') {\n        throw MinimongoError('Cannot apply $inc modifier to non-number', {\n          field: field\n        });\n      }\n      target[field] += arg;\n    } else {\n      target[field] = arg;\n    }\n  },\n  $min: function (target, field, arg) {\n    if (typeof arg !== 'number') {\n      throw MinimongoError('Modifier $min allowed for numbers only', {\n        field: field\n      });\n    }\n    if (field in target) {\n      if (typeof target[field] !== 'number') {\n        throw MinimongoError('Cannot apply $min modifier to non-number', {\n          field: field\n        });\n      }\n      if (target[field] > arg) {\n        target[field] = arg;\n      }\n    } else {\n      target[field] = arg;\n    }\n  },\n  $max: function (target, field, arg) {\n    if (typeof arg !== 'number') {\n      throw MinimongoError('Modifier $max allowed for numbers only', {\n        field: field\n      });\n    }\n    if (field in target) {\n      if (typeof target[field] !== 'number') {\n        throw MinimongoError('Cannot apply $max modifier to non-number', {\n          field: field\n        });\n      }\n      if (target[field] < arg) {\n        target[field] = arg;\n      }\n    } else {\n      target[field] = arg;\n    }\n  },\n  $mul: function (target, field, arg) {\n    if (typeof arg !== 'number') {\n      throw MinimongoError('Modifier $mul allowed for numbers only', {\n        field: field\n      });\n    }\n    if (field in target) {\n      if (typeof target[field] !== 'number') {\n        throw MinimongoError('Cannot apply $mul modifier to non-number', {\n          field: field\n        });\n      }\n      target[field] *= arg;\n    } else {\n      target[field] = 0;\n    }\n  },\n  $rename: function (target, field, arg, keypath, doc) {\n    // no idea why mongo has this restriction..\n    if (keypath === arg) {\n      throw MinimongoError('$rename source must differ from target', {\n        field: field\n      });\n    }\n    if (target === null) {\n      throw MinimongoError('$rename source field invalid', {\n        field: field\n      });\n    }\n    if (typeof arg !== 'string') {\n      throw MinimongoError('$rename target must be a string', {\n        field: field\n      });\n    }\n    if (arg.includes('\\0')) {\n      // Null bytes are not allowed in Mongo field names\n      // https://docs.mongodb.com/manual/reference/limits/#Restrictions-on-Field-Names\n      throw MinimongoError('The \\'to\\' field for $rename cannot contain an embedded null byte', {\n        field: field\n      });\n    }\n    if (target === undefined) {\n      return;\n    }\n    var object = target[field];\n    delete target[field];\n    var keyparts = arg.split('.');\n    var target2 = findModTarget(doc, keyparts, {\n      forbidArray: true\n    });\n    if (target2 === null) {\n      throw MinimongoError('$rename target field invalid', {\n        field: field\n      });\n    }\n    target2[keyparts.pop()] = object;\n  },\n  $set: function (target, field, arg) {\n    if (target !== Object(target)) {\n      // not an array or an object\n      var error = MinimongoError('Cannot set property on non-object field', {\n        field: field\n      });\n      error.setPropertyError = true;\n      throw error;\n    }\n    if (target === null) {\n      var _error = MinimongoError('Cannot set property on null', {\n        field: field\n      });\n      _error.setPropertyError = true;\n      throw _error;\n    }\n    assertHasValidFieldNames(arg);\n    target[field] = arg;\n  },\n  $setOnInsert: function (target, field, arg) {\n    // converted to `$set` in `_modify`\n  },\n  $unset: function (target, field, arg) {\n    if (target !== undefined) {\n      if (target instanceof Array) {\n        if (field in target) {\n          target[field] = null;\n        }\n      } else {\n        delete target[field];\n      }\n    }\n  },\n  $push: function (target, field, arg) {\n    if (target[field] === undefined) {\n      target[field] = [];\n    }\n    if (!(target[field] instanceof Array)) {\n      throw MinimongoError('Cannot apply $push modifier to non-array', {\n        field: field\n      });\n    }\n    if (!(arg && arg.$each)) {\n      // Simple mode: not $each\n      assertHasValidFieldNames(arg);\n      target[field].push(arg);\n      return;\n    }\n\n    // Fancy mode: $each (and maybe $slice and $sort and $position)\n    var toPush = arg.$each;\n    if (!(toPush instanceof Array)) {\n      throw MinimongoError('$each must be an array', {\n        field: field\n      });\n    }\n    assertHasValidFieldNames(toPush);\n\n    // Parse $position\n    var position = undefined;\n    if ('$position' in arg) {\n      if (typeof arg.$position !== 'number') {\n        throw MinimongoError('$position must be a numeric value', {\n          field: field\n        });\n      }\n\n      // XXX should check to make sure integer\n      if (arg.$position < 0) {\n        throw MinimongoError('$position in $push must be zero or positive', {\n          field: field\n        });\n      }\n      position = arg.$position;\n    }\n\n    // Parse $slice.\n    var slice = undefined;\n    if ('$slice' in arg) {\n      if (typeof arg.$slice !== 'number') {\n        throw MinimongoError('$slice must be a numeric value', {\n          field: field\n        });\n      }\n\n      // XXX should check to make sure integer\n      slice = arg.$slice;\n    }\n\n    // Parse $sort.\n    var sortFunction = undefined;\n    if (arg.$sort) {\n      if (slice === undefined) {\n        throw MinimongoError('$sort requires $slice to be present', {\n          field: field\n        });\n      }\n\n      // XXX this allows us to use a $sort whose value is an array, but that's\n      // actually an extension of the Node driver, so it won't work\n      // server-side. Could be confusing!\n      // XXX is it correct that we don't do geo-stuff here?\n      sortFunction = new Minimongo.Sorter(arg.$sort).getComparator();\n      toPush.forEach(function (element) {\n        if (LocalCollection._f._type(element) !== 3) {\n          throw MinimongoError('$push like modifiers using $sort require all elements to be ' + 'objects', {\n            field: field\n          });\n        }\n      });\n    }\n\n    // Actually push.\n    if (position === undefined) {\n      toPush.forEach(function (element) {\n        target[field].push(element);\n      });\n    } else {\n      var _target$field;\n      var spliceArguments = [position, 0];\n      toPush.forEach(function (element) {\n        spliceArguments.push(element);\n      });\n      (_target$field = target[field]).splice.apply(_target$field, spliceArguments);\n    }\n\n    // Actually sort.\n    if (sortFunction) {\n      target[field].sort(sortFunction);\n    }\n\n    // Actually slice.\n    if (slice !== undefined) {\n      if (slice === 0) {\n        target[field] = []; // differs from Array.slice!\n      } else if (slice < 0) {\n        target[field] = target[field].slice(slice);\n      } else {\n        target[field] = target[field].slice(0, slice);\n      }\n    }\n  },\n  $pushAll: function (target, field, arg) {\n    if (!(_typeof(arg) === 'object' && arg instanceof Array)) {\n      throw MinimongoError('Modifier $pushAll/pullAll allowed for arrays only');\n    }\n    assertHasValidFieldNames(arg);\n    var toPush = target[field];\n    if (toPush === undefined) {\n      target[field] = arg;\n    } else if (!(toPush instanceof Array)) {\n      throw MinimongoError('Cannot apply $pushAll modifier to non-array', {\n        field: field\n      });\n    } else {\n      toPush.push.apply(toPush, _toConsumableArray(arg));\n    }\n  },\n  $addToSet: function (target, field, arg) {\n    var isEach = false;\n    if (_typeof(arg) === 'object') {\n      // check if first key is '$each'\n      var keys = Object.keys(arg);\n      if (keys[0] === '$each') {\n        isEach = true;\n      }\n    }\n    var values = isEach ? arg.$each : [arg];\n    assertHasValidFieldNames(values);\n    var toAdd = target[field];\n    if (toAdd === undefined) {\n      target[field] = values;\n    } else if (!(toAdd instanceof Array)) {\n      throw MinimongoError('Cannot apply $addToSet modifier to non-array', {\n        field: field\n      });\n    } else {\n      values.forEach(function (value) {\n        if (toAdd.some(function (element) {\n          return LocalCollection._f._equal(value, element);\n        })) {\n          return;\n        }\n        toAdd.push(value);\n      });\n    }\n  },\n  $pop: function (target, field, arg) {\n    if (target === undefined) {\n      return;\n    }\n    var toPop = target[field];\n    if (toPop === undefined) {\n      return;\n    }\n    if (!(toPop instanceof Array)) {\n      throw MinimongoError('Cannot apply $pop modifier to non-array', {\n        field: field\n      });\n    }\n    if (typeof arg === 'number' && arg < 0) {\n      toPop.splice(0, 1);\n    } else {\n      toPop.pop();\n    }\n  },\n  $pull: function (target, field, arg) {\n    if (target === undefined) {\n      return;\n    }\n    var toPull = target[field];\n    if (toPull === undefined) {\n      return;\n    }\n    if (!(toPull instanceof Array)) {\n      throw MinimongoError('Cannot apply $pull/pullAll modifier to non-array', {\n        field: field\n      });\n    }\n    var out;\n    if (arg != null && _typeof(arg) === 'object' && !(arg instanceof Array)) {\n      // XXX would be much nicer to compile this once, rather than\n      // for each document we modify.. but usually we're not\n      // modifying that many documents, so we'll let it slide for\n      // now\n\n      // XXX Minimongo.Matcher isn't up for the job, because we need\n      // to permit stuff like {$pull: {a: {$gt: 4}}}.. something\n      // like {$gt: 4} is not normally a complete selector.\n      // same issue as $elemMatch possibly?\n      var matcher = new Minimongo.Matcher(arg);\n      out = toPull.filter(function (element) {\n        return !matcher.documentMatches(element).result;\n      });\n    } else {\n      out = toPull.filter(function (element) {\n        return !LocalCollection._f._equal(element, arg);\n      });\n    }\n    target[field] = out;\n  },\n  $pullAll: function (target, field, arg) {\n    if (!(_typeof(arg) === 'object' && arg instanceof Array)) {\n      throw MinimongoError('Modifier $pushAll/pullAll allowed for arrays only', {\n        field: field\n      });\n    }\n    if (target === undefined) {\n      return;\n    }\n    var toPull = target[field];\n    if (toPull === undefined) {\n      return;\n    }\n    if (!(toPull instanceof Array)) {\n      throw MinimongoError('Cannot apply $pull/pullAll modifier to non-array', {\n        field: field\n      });\n    }\n    target[field] = toPull.filter(function (object) {\n      return !arg.some(function (element) {\n        return LocalCollection._f._equal(object, element);\n      });\n    });\n  },\n  $bit: function (target, field, arg) {\n    // XXX mongo only supports $bit on integers, and we only support\n    // native javascript numbers (doubles) so far, so we can't support $bit\n    throw MinimongoError('$bit is not supported', {\n      field: field\n    });\n  },\n  $v: function () {\n    // As discussed in https://github.com/meteor/meteor/issues/9623,\n    // the `$v` operator is not needed by Meteor, but problems can occur if\n    // it's not at least callable (as of Mongo >= 3.6). It's defined here as\n    // a no-op to work around these problems.\n  }\n};\nvar NO_CREATE_MODIFIERS = {\n  $pop: true,\n  $pull: true,\n  $pullAll: true,\n  $rename: true,\n  $unset: true\n};\n\n// Make sure field names do not contain Mongo restricted\n// characters ('.', '$', '\\0').\n// https://docs.mongodb.com/manual/reference/limits/#Restrictions-on-Field-Names\nvar invalidCharMsg = {\n  $: 'start with \\'$\\'',\n  '.': 'contain \\'.\\'',\n  '\\0': 'contain null bytes'\n};\n\n// checks if all field names in an object are valid\nfunction assertHasValidFieldNames(doc) {\n  if (doc && _typeof(doc) === 'object') {\n    JSON.stringify(doc, function (key, value) {\n      assertIsValidFieldName(key);\n      return value;\n    });\n  }\n}\nfunction assertIsValidFieldName(key) {\n  var match;\n  if (typeof key === 'string' && (match = key.match(/^\\$|\\.|\\0/))) {\n    throw MinimongoError(\"Key \" + key + \" must not \" + invalidCharMsg[match[0]]);\n  }\n}\n\n// for a.b.c.2.d.e, keyparts should be ['a', 'b', 'c', '2', 'd', 'e'],\n// and then you would operate on the 'e' property of the returned\n// object.\n//\n// if options.noCreate is falsey, creates intermediate levels of\n// structure as necessary, like mkdir -p (and raises an exception if\n// that would mean giving a non-numeric property to an array.) if\n// options.noCreate is true, return undefined instead.\n//\n// may modify the last element of keyparts to signal to the caller that it needs\n// to use a different value to index into the returned object (for example,\n// ['a', '01'] -> ['a', 1]).\n//\n// if forbidArray is true, return null if the keypath goes through an array.\n//\n// if options.arrayIndices is set, use its first element for the (first) '$' in\n// the path.\nfunction findModTarget(doc, keyparts) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var usedArrayIndex = false;\n  for (var i = 0; i < keyparts.length; i++) {\n    var last = i === keyparts.length - 1;\n    var keypart = keyparts[i];\n    if (!isIndexable(doc)) {\n      if (options.noCreate) {\n        return undefined;\n      }\n      var error = MinimongoError(\"cannot use the part '\" + keypart + \"' to traverse \" + doc);\n      error.setPropertyError = true;\n      throw error;\n    }\n    if (doc instanceof Array) {\n      if (options.forbidArray) {\n        return null;\n      }\n      if (keypart === '$') {\n        if (usedArrayIndex) {\n          throw MinimongoError('Too many positional (i.e. \\'$\\') elements');\n        }\n        if (!options.arrayIndices || !options.arrayIndices.length) {\n          throw MinimongoError('The positional operator did not find the match needed from the ' + 'query');\n        }\n        keypart = options.arrayIndices[0];\n        usedArrayIndex = true;\n      } else if (isNumericKey(keypart)) {\n        keypart = parseInt(keypart);\n      } else {\n        if (options.noCreate) {\n          return undefined;\n        }\n        throw MinimongoError(\"can't append to array using string field name [\" + keypart + \"]\");\n      }\n      if (last) {\n        keyparts[i] = keypart; // handle 'a.01'\n      }\n      if (options.noCreate && keypart >= doc.length) {\n        return undefined;\n      }\n      while (doc.length < keypart) {\n        doc.push(null);\n      }\n      if (!last) {\n        if (doc.length === keypart) {\n          doc.push({});\n        } else if (_typeof(doc[keypart]) !== 'object') {\n          throw MinimongoError(\"can't modify field '\" + keyparts[i + 1] + \"' of list value \" + JSON.stringify(doc[keypart]));\n        }\n      }\n    } else {\n      assertIsValidFieldName(keypart);\n      if (!(keypart in doc)) {\n        if (options.noCreate) {\n          return undefined;\n        }\n        if (!last) {\n          doc[keypart] = {};\n        }\n      }\n    }\n    if (last) {\n      return doc;\n    }\n    doc = doc[keypart];\n  }\n\n  // notreached\n}","map":{"version":3,"names":["_toConsumableArray","module","link","default","v","_typeof","_inheritsLoose","_objectSpread","_createForOfIteratorHelperLoose","_regeneratorRuntime","export","LocalCollection","Cursor","ObserveHandle","hasOwn","isIndexable","isNumericKey","isOperatorObject","populateDocumentWithQueryFields","projectionDetails","getAsyncMethodName","name","_docs","_IdMap","_observeQueue","Meteor","isClient","_SynchronousQueue","_AsynchronousQueue","next_qid","queries","Object","create","_savedOriginals","paused","_proto","prototype","countDocuments","selector","options","find","countAsync","estimatedDocumentCount","arguments","length","findOne","undefined","limit","fetch","findOneAsync","_args","async","findOneAsync$","_context","prev","next","awrap","fetchAsync","abrupt","sent","stop","Promise","prepareInsert","doc","assertHasValidFieldNames","call","_id","_useOID","MongoID","ObjectID","Random","id","has","MinimongoError","_saveOriginal","set","insert","callback","_this","EJSON","clone","queriesToRecompute","_i","_Object$keys","keys","qid","query","dirty","matchResult","matcher","documentMatches","result","distances","distance","cursor","skip","push","_insertInResultsSync","forEach","_recomputeResults","drain","defer","insertAsync","_this2","_i2","_Object$keys2","insertAsync$","_context2","_insertInResultsAsync","pauseObservers","_this3","resultsSnapshot","results","clearResultQueries","_this4","size","clear","ordered","prepareRemove","_this5","Minimongo","Matcher","remove","_eachPossiblyMatchingDocSync","queryRemove","_loop","removeId","i","removeDoc","get","_this6","equals","_this$prepareRemove","_removeFromResultsSync","removeAsync","_this7","_this$prepareRemove2","_iterator","_step","_remove","removeAsync$","_context3","done","value","_removeFromResultsAsync","_resumeObservers","_this8","_diffQueryChanges","projectionFn","resumeObserversServer","resumeObserversServer$","_context4","resumeObserversClient","retrieveOriginals","Error","originals","saveOriginals","prepareUpdate","_this9","qidToOriginalResults","docMap","idsMatched","_idsMatchedBySelector","Array","memoizedCloneIfNeeded","docToMemoize","some","map","finishUpdate","_ref","updateCount","insertedId","_returnObject","numberAffected","updateAsync","mod","_this10","recomputeQids","updateAsync$","_context6","Function","_eachPossiblyMatchingDocAsync","_callee","queryResult","_callee$","_context5","_modifyAndNotifyAsync","arrayIndices","multi","upsert","_createUpsertDocument","update","_this11","_modifyAndNotifySync","assign","upsertAsync","fn","specificIds","_iterator2","_step2","_eachPossiblyMatchingDocAsync$","_context7","t0","forEachAsync","_iterator3","_step3","_getMatchedDocAndModify","_this12","matched_before","old_doc","_modify","_i3","_Object$keys3","afterMatch","after","before","_updateInResultsSync","_i4","_Object$keys4","_modifyAndNotifyAsync$","_context8","_updateInResultsAsync","oldResults","_getRawObjects","_CachingChangeObserver","_this13","orderedFromCallbacks","callbacks","_observeChangesCallbacksAreOrdered","docs","OrderedDict","idStringify","applyChange","addedBefore","fields","added","putBefore","movedBefore","moveBefore","changed","DiffSequence","applyChanges","removed","_IdMap2","idParse","IdMap","wrapTransform","transform","__wrappedTransform__","wrapped","transformed","Tracker","nonreactive","_isPlainObject","_binarySearch","cmp","array","first","range","halfRange","Math","floor","_checkSupportedProjection","isArray","keyPath","split","includes","key","_compileProjection","_idProjection","details","ruleTree","subdoc","including","rule","tree","modifier","selectorDocument","isModify","_isModificationMod","newDoc","$set","isInsert","replacement","_diffObjects","left","right","diffObjects","newResults","observer","diffQueryChanges","_diffQueryOrderedChanges","diffQueryOrderedChanges","_diffQueryUnorderedChanges","diffQueryUnorderedChanges","_findInOrderedResults","_selectorIsId","$in","every","$and","subIds","sorter","_insertInSortedList","getComparator","_callee2","_callee2$","_context9","splice","isReplace","substr","x","_f","_type","isModifier","operator","setOnInsert","modFunc","MODIFIERS","operand","keypath","arg","keyparts","Boolean","target","findModTarget","forbidArray","noCreate","NO_CREATE_MODIFIERS","pop","_observeFromObserveChanges","observeCallbacks","getTransform","suppressed","_suppress_initial","observeChangesCallbacks","_observeCallbacksAreOrdered","indices","_no_indices","check","addedAt","indexOf","changedAt","oldDoc","movedTo","from","to","removedAt","changeObserver","_fromObserve","handle","observeChanges","nonMutatingCallbacks","setSuppressed","h","_h$isReadyPromise","isReady","isReadyPromise","then","_isPromise","_callee3","_callee3$","_context10","_selectorIsIdPerhapsAsObject","changedFields","makeChangedFields","old_idx","new_idx","_callee4","_callee4$","_context11","$currentDate","field","$type","Date","$inc","$min","$max","$mul","$rename","object","target2","error","setPropertyError","$setOnInsert","$unset","$push","$each","toPush","position","$position","slice","$slice","sortFunction","$sort","Sorter","element","_target$field","spliceArguments","apply","sort","$pushAll","$addToSet","isEach","values","toAdd","_equal","$pop","toPop","$pull","toPull","out","filter","$pullAll","$bit","$v","invalidCharMsg","$","JSON","stringify","assertIsValidFieldName","match","usedArrayIndex","last","keypart","parseInt"],"sources":["packages/minimongo/local_collection.js"],"sourcesContent":["import Cursor from './cursor.js';\nimport ObserveHandle from './observe_handle.js';\nimport {\n  hasOwn,\n  isIndexable,\n  isNumericKey,\n  isOperatorObject,\n  populateDocumentWithQueryFields,\n  projectionDetails,\n} from './common.js';\n\nimport { getAsyncMethodName } from './constants';\n\n// XXX type checking on selectors (graceful error if malformed)\n\n// LocalCollection: a set of documents that supports queries and modifiers.\nexport default class LocalCollection {\n  constructor(name) {\n    this.name = name;\n    // _id -> document (also containing id)\n    this._docs = new LocalCollection._IdMap;\n\n    this._observeQueue = Meteor.isClient\n      ? new Meteor._SynchronousQueue()\n      : new Meteor._AsynchronousQueue();\n\n    this.next_qid = 1; // live query id generator\n\n    // qid -> live query object. keys:\n    //  ordered: bool. ordered queries have addedBefore/movedBefore callbacks.\n    //  results: array (ordered) or object (unordered) of current results\n    //    (aliased with this._docs!)\n    //  resultsSnapshot: snapshot of results. null if not paused.\n    //  cursor: Cursor object for the query.\n    //  selector, sorter, (callbacks): functions\n    this.queries = Object.create(null);\n\n    // null if not saving originals; an IdMap from id to original document value\n    // if saving originals. See comments before saveOriginals().\n    this._savedOriginals = null;\n\n    // True when observers are paused and we should not send callbacks.\n    this.paused = false;\n  }\n\n  countDocuments(selector, options) {\n    return this.find(selector ?? {}, options).countAsync();\n  }\n\n  estimatedDocumentCount(options) {\n    return this.find({}, options).countAsync();\n  }\n\n  // options may include sort, skip, limit, reactive\n  // sort may be any of these forms:\n  //     {a: 1, b: -1}\n  //     [[\"a\", \"asc\"], [\"b\", \"desc\"]]\n  //     [\"a\", [\"b\", \"desc\"]]\n  //   (in the first form you're beholden to key enumeration order in\n  //   your javascript VM)\n  //\n  // reactive: if given, and false, don't register with Tracker (default\n  // is true)\n  //\n  // XXX possibly should support retrieving a subset of fields? and\n  // have it be a hint (ignored on the client, when not copying the\n  // doc?)\n  //\n  // XXX sort does not yet support subkeys ('a.b') .. fix that!\n  // XXX add one more sort form: \"key\"\n  // XXX tests\n  find(selector, options) {\n    // default syntax for everything is to omit the selector argument.\n    // but if selector is explicitly passed in as false or undefined, we\n    // want a selector that matches nothing.\n    if (arguments.length === 0) {\n      selector = {};\n    }\n\n    return new LocalCollection.Cursor(this, selector, options);\n  }\n\n  findOne(selector, options = {}) {\n    if (arguments.length === 0) {\n      selector = {};\n    }\n\n    // NOTE: by setting limit 1 here, we end up using very inefficient\n    // code that recomputes the whole query on each update. The upside is\n    // that when you reactively depend on a findOne you only get\n    // invalidated when the found object changes, not any object in the\n    // collection. Most findOne will be by id, which has a fast path, so\n    // this might not be a big deal. In most cases, invalidation causes\n    // the called to re-query anyway, so this should be a net performance\n    // improvement.\n    options.limit = 1;\n\n    return this.find(selector, options).fetch()[0];\n  }\n  async findOneAsync(selector, options = {}) {\n    if (arguments.length === 0) {\n      selector = {};\n    }\n    options.limit = 1;\n    return (await this.find(selector, options).fetchAsync())[0];\n  }\n  prepareInsert(doc) {\n    assertHasValidFieldNames(doc);\n\n    // if you really want to use ObjectIDs, set this global.\n    // Mongo.Collection specifies its own ids and does not use this code.\n    if (!hasOwn.call(doc, '_id')) {\n      doc._id = LocalCollection._useOID ? new MongoID.ObjectID() : Random.id();\n    }\n\n    const id = doc._id;\n\n    if (this._docs.has(id)) {\n      throw MinimongoError(`Duplicate _id '${id}'`);\n    }\n\n    this._saveOriginal(id, undefined);\n    this._docs.set(id, doc);\n\n    return id;\n  }\n\n  // XXX possibly enforce that 'undefined' does not appear (we assume\n  // this in our handling of null and $exists)\n  insert(doc, callback) {\n    doc = EJSON.clone(doc);\n    const id = this.prepareInsert(doc);\n    const queriesToRecompute = [];\n\n    // trigger live queries that match\n    for (const qid of Object.keys(this.queries)) {\n      const query = this.queries[qid];\n\n      if (query.dirty) {\n        continue;\n      }\n\n      const matchResult = query.matcher.documentMatches(doc);\n\n      if (matchResult.result) {\n        if (query.distances && matchResult.distance !== undefined) {\n          query.distances.set(id, matchResult.distance);\n        }\n\n        if (query.cursor.skip || query.cursor.limit) {\n          queriesToRecompute.push(qid);\n        } else {\n          LocalCollection._insertInResultsSync(query, doc);\n        }\n      }\n    }\n\n    queriesToRecompute.forEach(qid => {\n      if (this.queries[qid]) {\n        this._recomputeResults(this.queries[qid]);\n      }\n    });\n\n    this._observeQueue.drain();\n    if (callback) {\n      Meteor.defer(() => {\n        callback(null, id);\n      });\n    }\n\n    return id;\n  }\n  async insertAsync(doc, callback) {\n    doc = EJSON.clone(doc);\n    const id = this.prepareInsert(doc);\n    const queriesToRecompute = [];\n\n    // trigger live queries that match\n    for (const qid of Object.keys(this.queries)) {\n      const query = this.queries[qid];\n\n      if (query.dirty) {\n        continue;\n      }\n\n      const matchResult = query.matcher.documentMatches(doc);\n\n      if (matchResult.result) {\n        if (query.distances && matchResult.distance !== undefined) {\n          query.distances.set(id, matchResult.distance);\n        }\n\n        if (query.cursor.skip || query.cursor.limit) {\n          queriesToRecompute.push(qid);\n        } else {\n          await LocalCollection._insertInResultsAsync(query, doc);\n        }\n      }\n    }\n\n    queriesToRecompute.forEach(qid => {\n      if (this.queries[qid]) {\n        this._recomputeResults(this.queries[qid]);\n      }\n    });\n\n    await this._observeQueue.drain();\n    if (callback) {\n      Meteor.defer(() => {\n        callback(null, id);\n      });\n    }\n\n    return id;\n  }\n\n  // Pause the observers. No callbacks from observers will fire until\n  // 'resumeObservers' is called.\n  pauseObservers() {\n    // No-op if already paused.\n    if (this.paused) {\n      return;\n    }\n\n    // Set the 'paused' flag such that new observer messages don't fire.\n    this.paused = true;\n\n    // Take a snapshot of the query results for each query.\n    Object.keys(this.queries).forEach(qid => {\n      const query = this.queries[qid];\n      query.resultsSnapshot = EJSON.clone(query.results);\n    });\n  }\n\n  clearResultQueries(callback) {\n    const result = this._docs.size();\n\n    this._docs.clear();\n\n    Object.keys(this.queries).forEach(qid => {\n      const query = this.queries[qid];\n\n      if (query.ordered) {\n        query.results = [];\n      } else {\n        query.results.clear();\n      }\n    });\n\n    if (callback) {\n      Meteor.defer(() => {\n        callback(null, result);\n      });\n    }\n\n    return result;\n  }\n\n\n  prepareRemove(selector) {\n    const matcher = new Minimongo.Matcher(selector);\n    const remove = [];\n\n    this._eachPossiblyMatchingDocSync(selector, (doc, id) => {\n      if (matcher.documentMatches(doc).result) {\n        remove.push(id);\n      }\n    });\n\n    const queriesToRecompute = [];\n    const queryRemove = [];\n\n    for (let i = 0; i < remove.length; i++) {\n      const removeId = remove[i];\n      const removeDoc = this._docs.get(removeId);\n\n      Object.keys(this.queries).forEach(qid => {\n        const query = this.queries[qid];\n\n        if (query.dirty) {\n          return;\n        }\n\n        if (query.matcher.documentMatches(removeDoc).result) {\n          if (query.cursor.skip || query.cursor.limit) {\n            queriesToRecompute.push(qid);\n          } else {\n            queryRemove.push({qid, doc: removeDoc});\n          }\n        }\n      });\n\n      this._saveOriginal(removeId, removeDoc);\n      this._docs.remove(removeId);\n    }\n\n    return { queriesToRecompute, queryRemove, remove };\n  }\n\n  remove(selector, callback) {\n    // Easy special case: if we're not calling observeChanges callbacks and\n    // we're not saving originals and we got asked to remove everything, then\n    // just empty everything directly.\n    if (this.paused && !this._savedOriginals && EJSON.equals(selector, {})) {\n      return this.clearResultQueries(callback);\n    }\n\n    const { queriesToRecompute, queryRemove, remove } = this.prepareRemove(selector);\n\n    // run live query callbacks _after_ we've removed the documents.\n    queryRemove.forEach(remove => {\n      const query = this.queries[remove.qid];\n\n      if (query) {\n        query.distances && query.distances.remove(remove.doc._id);\n        LocalCollection._removeFromResultsSync(query, remove.doc);\n      }\n    });\n\n    queriesToRecompute.forEach(qid => {\n      const query = this.queries[qid];\n\n      if (query) {\n        this._recomputeResults(query);\n      }\n    });\n\n    this._observeQueue.drain();\n\n    const result = remove.length;\n\n    if (callback) {\n      Meteor.defer(() => {\n        callback(null, result);\n      });\n    }\n\n    return result;\n  }\n\n  async removeAsync(selector, callback) {\n    // Easy special case: if we're not calling observeChanges callbacks and\n    // we're not saving originals and we got asked to remove everything, then\n    // just empty everything directly.\n    if (this.paused && !this._savedOriginals && EJSON.equals(selector, {})) {\n      return this.clearResultQueries(callback);\n    }\n\n    const { queriesToRecompute, queryRemove, remove } = this.prepareRemove(selector);\n\n    // run live query callbacks _after_ we've removed the documents.\n    for (const remove of queryRemove) {\n      const query = this.queries[remove.qid];\n\n      if (query) {\n        query.distances && query.distances.remove(remove.doc._id);\n        await LocalCollection._removeFromResultsAsync(query, remove.doc);\n      }\n    }\n    queriesToRecompute.forEach(qid => {\n      const query = this.queries[qid];\n\n      if (query) {\n        this._recomputeResults(query);\n      }\n    });\n\n    await this._observeQueue.drain();\n\n    const result = remove.length;\n\n    if (callback) {\n      Meteor.defer(() => {\n        callback(null, result);\n      });\n    }\n\n    return result;\n  }\n\n  // Resume the observers. Observers immediately receive change\n  // notifications to bring them to the current state of the\n  // database. Note that this is not just replaying all the changes that\n  // happened during the pause, it is a smarter 'coalesced' diff.\n  _resumeObservers() {\n    // No-op if not paused.\n    if (!this.paused) {\n      return;\n    }\n\n    // Unset the 'paused' flag. Make sure to do this first, otherwise\n    // observer methods won't actually fire when we trigger them.\n    this.paused = false;\n\n    Object.keys(this.queries).forEach(qid => {\n      const query = this.queries[qid];\n\n      if (query.dirty) {\n        query.dirty = false;\n\n        // re-compute results will perform `LocalCollection._diffQueryChanges`\n        // automatically.\n        this._recomputeResults(query, query.resultsSnapshot);\n      } else {\n        // Diff the current results against the snapshot and send to observers.\n        // pass the query object for its observer callbacks.\n        LocalCollection._diffQueryChanges(\n          query.ordered,\n          query.resultsSnapshot,\n          query.results,\n          query,\n          {projectionFn: query.projectionFn}\n        );\n      }\n\n      query.resultsSnapshot = null;\n    });\n  }\n\n  async resumeObserversServer() {\n    this._resumeObservers();\n    await this._observeQueue.drain();\n  }\n  resumeObserversClient() {\n    this._resumeObservers();\n    this._observeQueue.drain();\n  }\n\n  retrieveOriginals() {\n    if (!this._savedOriginals) {\n      throw new Error('Called retrieveOriginals without saveOriginals');\n    }\n\n    const originals = this._savedOriginals;\n\n    this._savedOriginals = null;\n\n    return originals;\n  }\n\n  // To track what documents are affected by a piece of code, call\n  // saveOriginals() before it and retrieveOriginals() after it.\n  // retrieveOriginals returns an object whose keys are the ids of the documents\n  // that were affected since the call to saveOriginals(), and the values are\n  // equal to the document's contents at the time of saveOriginals. (In the case\n  // of an inserted document, undefined is the value.) You must alternate\n  // between calls to saveOriginals() and retrieveOriginals().\n  saveOriginals() {\n    if (this._savedOriginals) {\n      throw new Error('Called saveOriginals twice without retrieveOriginals');\n    }\n\n    this._savedOriginals = new LocalCollection._IdMap;\n  }\n\n  prepareUpdate(selector) {\n    // Save the original results of any query that we might need to\n    // _recomputeResults on, because _modifyAndNotify will mutate the objects in\n    // it. (We don't need to save the original results of paused queries because\n    // they already have a resultsSnapshot and we won't be diffing in\n    // _recomputeResults.)\n    const qidToOriginalResults = {};\n\n    // We should only clone each document once, even if it appears in multiple\n    // queries\n    const docMap = new LocalCollection._IdMap;\n    const idsMatched = LocalCollection._idsMatchedBySelector(selector);\n\n    Object.keys(this.queries).forEach(qid => {\n      const query = this.queries[qid];\n\n      if ((query.cursor.skip || query.cursor.limit) && ! this.paused) {\n        // Catch the case of a reactive `count()` on a cursor with skip\n        // or limit, which registers an unordered observe. This is a\n        // pretty rare case, so we just clone the entire result set with\n        // no optimizations for documents that appear in these result\n        // sets and other queries.\n        if (query.results instanceof LocalCollection._IdMap) {\n          qidToOriginalResults[qid] = query.results.clone();\n          return;\n        }\n\n        if (!(query.results instanceof Array)) {\n          throw new Error('Assertion failed: query.results not an array');\n        }\n\n        // Clones a document to be stored in `qidToOriginalResults`\n        // because it may be modified before the new and old result sets\n        // are diffed. But if we know exactly which document IDs we're\n        // going to modify, then we only need to clone those.\n        const memoizedCloneIfNeeded = doc => {\n          if (docMap.has(doc._id)) {\n            return docMap.get(doc._id);\n          }\n\n          const docToMemoize = (\n            idsMatched &&\n            !idsMatched.some(id => EJSON.equals(id, doc._id))\n          ) ? doc : EJSON.clone(doc);\n\n          docMap.set(doc._id, docToMemoize);\n\n          return docToMemoize;\n        };\n\n        qidToOriginalResults[qid] = query.results.map(memoizedCloneIfNeeded);\n      }\n    });\n\n    return qidToOriginalResults;\n  }\n\n  finishUpdate({ options, updateCount, callback, insertedId }) {\n\n\n    // Return the number of affected documents, or in the upsert case, an object\n    // containing the number of affected docs and the id of the doc that was\n    // inserted, if any.\n    let result;\n    if (options._returnObject) {\n      result = { numberAffected: updateCount };\n\n      if (insertedId !== undefined) {\n        result.insertedId = insertedId;\n      }\n    } else {\n      result = updateCount;\n    }\n\n    if (callback) {\n      Meteor.defer(() => {\n        callback(null, result);\n      });\n    }\n\n    return result;\n  }\n\n  // XXX atomicity: if multi is true, and one modification fails, do\n  // we rollback the whole operation, or what?\n  async updateAsync(selector, mod, options, callback) {\n    if (! callback && options instanceof Function) {\n      callback = options;\n      options = null;\n    }\n\n    if (!options) {\n      options = {};\n    }\n\n    const matcher = new Minimongo.Matcher(selector, true);\n\n    const qidToOriginalResults = this.prepareUpdate(selector);\n\n    let recomputeQids = {};\n\n    let updateCount = 0;\n\n    await this._eachPossiblyMatchingDocAsync(selector, async (doc, id) => {\n      const queryResult = matcher.documentMatches(doc);\n\n      if (queryResult.result) {\n        // XXX Should we save the original even if mod ends up being a no-op?\n        this._saveOriginal(id, doc);\n        recomputeQids = await this._modifyAndNotifyAsync(\n          doc,\n          mod,\n          queryResult.arrayIndices\n        );\n\n        ++updateCount;\n\n        if (!options.multi) {\n          return false; // break\n        }\n      }\n\n      return true;\n    });\n\n    Object.keys(recomputeQids).forEach(qid => {\n      const query = this.queries[qid];\n\n      if (query) {\n        this._recomputeResults(query, qidToOriginalResults[qid]);\n      }\n    });\n\n    await this._observeQueue.drain();\n\n    // If we are doing an upsert, and we didn't modify any documents yet, then\n    // it's time to do an insert. Figure out what document we are inserting, and\n    // generate an id for it.\n    let insertedId;\n    if (updateCount === 0 && options.upsert) {\n      const doc = LocalCollection._createUpsertDocument(selector, mod);\n      if (!doc._id && options.insertedId) {\n        doc._id = options.insertedId;\n      }\n\n      insertedId = await this.insertAsync(doc);\n      updateCount = 1;\n    }\n\n    return this.finishUpdate({\n      options,\n      insertedId,\n      updateCount,\n      callback,\n    });\n  }\n  // XXX atomicity: if multi is true, and one modification fails, do\n  // we rollback the whole operation, or what?\n  update(selector, mod, options, callback) {\n    if (! callback && options instanceof Function) {\n      callback = options;\n      options = null;\n    }\n\n    if (!options) {\n      options = {};\n    }\n\n    const matcher = new Minimongo.Matcher(selector, true);\n\n    const qidToOriginalResults = this.prepareUpdate(selector);\n\n    let recomputeQids = {};\n\n    let updateCount = 0;\n\n    this._eachPossiblyMatchingDocSync(selector, (doc, id) => {\n      const queryResult = matcher.documentMatches(doc);\n\n      if (queryResult.result) {\n        // XXX Should we save the original even if mod ends up being a no-op?\n        this._saveOriginal(id, doc);\n        recomputeQids = this._modifyAndNotifySync(\n          doc,\n          mod,\n          queryResult.arrayIndices\n        );\n\n        ++updateCount;\n\n        if (!options.multi) {\n          return false; // break\n        }\n      }\n\n      return true;\n    });\n\n    Object.keys(recomputeQids).forEach(qid => {\n      const query = this.queries[qid];\n      if (query) {\n        this._recomputeResults(query, qidToOriginalResults[qid]);\n      }\n    });\n\n    this._observeQueue.drain();\n\n\n    // If we are doing an upsert, and we didn't modify any documents yet, then\n    // it's time to do an insert. Figure out what document we are inserting, and\n    // generate an id for it.\n    let insertedId;\n    if (updateCount === 0 && options.upsert) {\n      const doc = LocalCollection._createUpsertDocument(selector, mod);\n      if (!doc._id && options.insertedId) {\n        doc._id = options.insertedId;\n      }\n\n      insertedId = this.insert(doc);\n      updateCount = 1;\n    }\n\n\n    return this.finishUpdate({\n      options,\n      updateCount,\n      callback,\n      selector,\n      mod,\n    });\n  }\n\n  // A convenience wrapper on update. LocalCollection.upsert(sel, mod) is\n  // equivalent to LocalCollection.update(sel, mod, {upsert: true,\n  // _returnObject: true}).\n  upsert(selector, mod, options, callback) {\n    if (!callback && typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n\n    return this.update(\n      selector,\n      mod,\n      Object.assign({}, options, {upsert: true, _returnObject: true}),\n      callback\n    );\n  }\n\n  upsertAsync(selector, mod, options, callback) {\n    if (!callback && typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n\n    return this.updateAsync(\n      selector,\n      mod,\n      Object.assign({}, options, {upsert: true, _returnObject: true}),\n      callback\n    );\n  }\n\n  // Iterates over a subset of documents that could match selector; calls\n  // fn(doc, id) on each of them.  Specifically, if selector specifies\n  // specific _id's, it only looks at those.  doc is *not* cloned: it is the\n  // same object that is in _docs.\n  async _eachPossiblyMatchingDocAsync(selector, fn) {\n    const specificIds = LocalCollection._idsMatchedBySelector(selector);\n\n    if (specificIds) {\n      for (const id of specificIds) {\n        const doc = this._docs.get(id);\n\n        if (doc && ! (await fn(doc, id))) {\n          break\n        }\n      }\n    } else {\n      await this._docs.forEachAsync(fn);\n    }\n  }\n  _eachPossiblyMatchingDocSync(selector, fn) {\n    const specificIds = LocalCollection._idsMatchedBySelector(selector);\n\n    if (specificIds) {\n      for (const id of specificIds) {\n        const doc = this._docs.get(id);\n\n        if (doc && !fn(doc, id)) {\n          break\n        }\n      }\n    } else {\n      this._docs.forEach(fn);\n    }\n  }\n\n  _getMatchedDocAndModify(doc, mod, arrayIndices) {\n    const matched_before = {};\n\n    Object.keys(this.queries).forEach(qid => {\n      const query = this.queries[qid];\n\n      if (query.dirty) {\n        return;\n      }\n\n      if (query.ordered) {\n        matched_before[qid] = query.matcher.documentMatches(doc).result;\n      } else {\n        // Because we don't support skip or limit (yet) in unordered queries, we\n        // can just do a direct lookup.\n        matched_before[qid] = query.results.has(doc._id);\n      }\n    });\n\n    return matched_before;\n  }\n\n  _modifyAndNotifySync(doc, mod, arrayIndices) {\n\n    const matched_before = this._getMatchedDocAndModify(doc, mod, arrayIndices);\n\n    const old_doc = EJSON.clone(doc);\n    LocalCollection._modify(doc, mod, {arrayIndices});\n\n    const recomputeQids = {};\n\n    for (const qid of Object.keys(this.queries)) {\n      const query = this.queries[qid];\n\n      if (query.dirty) {\n        continue;\n      }\n\n      const afterMatch = query.matcher.documentMatches(doc);\n      const after = afterMatch.result;\n      const before = matched_before[qid];\n\n      if (after && query.distances && afterMatch.distance !== undefined) {\n        query.distances.set(doc._id, afterMatch.distance);\n      }\n\n      if (query.cursor.skip || query.cursor.limit) {\n        // We need to recompute any query where the doc may have been in the\n        // cursor's window either before or after the update. (Note that if skip\n        // or limit is set, \"before\" and \"after\" being true do not necessarily\n        // mean that the document is in the cursor's output after skip/limit is\n        // applied... but if they are false, then the document definitely is NOT\n        // in the output. So it's safe to skip recompute if neither before or\n        // after are true.)\n        if (before || after) {\n          recomputeQids[qid] = true;\n        }\n      } else if (before && !after) {\n        LocalCollection._removeFromResultsSync(query, doc);\n      } else if (!before && after) {\n        LocalCollection._insertInResultsSync(query, doc);\n      } else if (before && after) {\n        LocalCollection._updateInResultsSync(query, doc, old_doc);\n      }\n    }\n    return recomputeQids;\n  }\n\n  async _modifyAndNotifyAsync(doc, mod, arrayIndices) {\n\n    const matched_before = this._getMatchedDocAndModify(doc, mod, arrayIndices);\n\n    const old_doc = EJSON.clone(doc);\n    LocalCollection._modify(doc, mod, {arrayIndices});\n\n    const recomputeQids = {};\n    for (const qid of Object.keys(this.queries)) {\n      const query = this.queries[qid];\n\n      if (query.dirty) {\n        continue;\n      }\n\n      const afterMatch = query.matcher.documentMatches(doc);\n      const after = afterMatch.result;\n      const before = matched_before[qid];\n\n      if (after && query.distances && afterMatch.distance !== undefined) {\n        query.distances.set(doc._id, afterMatch.distance);\n      }\n\n      if (query.cursor.skip || query.cursor.limit) {\n        // We need to recompute any query where the doc may have been in the\n        // cursor's window either before or after the update. (Note that if skip\n        // or limit is set, \"before\" and \"after\" being true do not necessarily\n        // mean that the document is in the cursor's output after skip/limit is\n        // applied... but if they are false, then the document definitely is NOT\n        // in the output. So it's safe to skip recompute if neither before or\n        // after are true.)\n        if (before || after) {\n          recomputeQids[qid] = true;\n        }\n      } else if (before && !after) {\n        await LocalCollection._removeFromResultsAsync(query, doc);\n      } else if (!before && after) {\n        await LocalCollection._insertInResultsAsync(query, doc);\n      } else if (before && after) {\n        await LocalCollection._updateInResultsAsync(query, doc, old_doc);\n      }\n    }\n    return recomputeQids;\n  }\n\n  // Recomputes the results of a query and runs observe callbacks for the\n  // difference between the previous results and the current results (unless\n  // paused). Used for skip/limit queries.\n  //\n  // When this is used by insert or remove, it can just use query.results for\n  // the old results (and there's no need to pass in oldResults), because these\n  // operations don't mutate the documents in the collection. Update needs to\n  // pass in an oldResults which was deep-copied before the modifier was\n  // applied.\n  //\n  // oldResults is guaranteed to be ignored if the query is not paused.\n  _recomputeResults(query, oldResults) {\n    if (this.paused) {\n      // There's no reason to recompute the results now as we're still paused.\n      // By flagging the query as \"dirty\", the recompute will be performed\n      // when resumeObservers is called.\n      query.dirty = true;\n      return;\n    }\n\n    if (!this.paused && !oldResults) {\n      oldResults = query.results;\n    }\n\n    if (query.distances) {\n      query.distances.clear();\n    }\n\n    query.results = query.cursor._getRawObjects({\n      distances: query.distances,\n      ordered: query.ordered\n    });\n\n    if (!this.paused) {\n      LocalCollection._diffQueryChanges(\n        query.ordered,\n        oldResults,\n        query.results,\n        query,\n        {projectionFn: query.projectionFn}\n      );\n    }\n  }\n\n  _saveOriginal(id, doc) {\n    // Are we even trying to save originals?\n    if (!this._savedOriginals) {\n      return;\n    }\n\n    // Have we previously mutated the original (and so 'doc' is not actually\n    // original)?  (Note the 'has' check rather than truth: we store undefined\n    // here for inserted docs!)\n    if (this._savedOriginals.has(id)) {\n      return;\n    }\n\n    this._savedOriginals.set(id, EJSON.clone(doc));\n  }\n}\n\nLocalCollection.Cursor = Cursor;\n\nLocalCollection.ObserveHandle = ObserveHandle;\n\n// XXX maybe move these into another ObserveHelpers package or something\n\n// _CachingChangeObserver is an object which receives observeChanges callbacks\n// and keeps a cache of the current cursor state up to date in this.docs. Users\n// of this class should read the docs field but not modify it. You should pass\n// the \"applyChange\" field as the callbacks to the underlying observeChanges\n// call. Optionally, you can specify your own observeChanges callbacks which are\n// invoked immediately before the docs field is updated; this object is made\n// available as `this` to those callbacks.\nLocalCollection._CachingChangeObserver = class _CachingChangeObserver {\n  constructor(options = {}) {\n    const orderedFromCallbacks = (\n      options.callbacks &&\n      LocalCollection._observeChangesCallbacksAreOrdered(options.callbacks)\n    );\n\n    if (hasOwn.call(options, 'ordered')) {\n      this.ordered = options.ordered;\n\n      if (options.callbacks && options.ordered !== orderedFromCallbacks) {\n        throw Error('ordered option doesn\\'t match callbacks');\n      }\n    } else if (options.callbacks) {\n      this.ordered = orderedFromCallbacks;\n    } else {\n      throw Error('must provide ordered or callbacks');\n    }\n\n    const callbacks = options.callbacks || {};\n\n    if (this.ordered) {\n      this.docs = new OrderedDict(MongoID.idStringify);\n      this.applyChange = {\n        addedBefore: (id, fields, before) => {\n          // Take a shallow copy since the top-level properties can be changed\n          const doc = { ...fields };\n\n          doc._id = id;\n\n          if (callbacks.addedBefore) {\n            callbacks.addedBefore.call(this, id, EJSON.clone(fields), before);\n          }\n\n          // This line triggers if we provide added with movedBefore.\n          if (callbacks.added) {\n            callbacks.added.call(this, id, EJSON.clone(fields));\n          }\n\n          // XXX could `before` be a falsy ID?  Technically\n          // idStringify seems to allow for them -- though\n          // OrderedDict won't call stringify on a falsy arg.\n          this.docs.putBefore(id, doc, before || null);\n        },\n        movedBefore: (id, before) => {\n          if (callbacks.movedBefore) {\n            callbacks.movedBefore.call(this, id, before);\n          }\n\n          this.docs.moveBefore(id, before || null);\n        },\n      };\n    } else {\n      this.docs = new LocalCollection._IdMap;\n      this.applyChange = {\n        added: (id, fields) => {\n          // Take a shallow copy since the top-level properties can be changed\n          const doc = { ...fields };\n\n          if (callbacks.added) {\n            callbacks.added.call(this, id, EJSON.clone(fields));\n          }\n\n          doc._id = id;\n\n          this.docs.set(id,  doc);\n        },\n      };\n    }\n\n    // The methods in _IdMap and OrderedDict used by these callbacks are\n    // identical.\n    this.applyChange.changed = (id, fields) => {\n      const doc = this.docs.get(id);\n\n      if (!doc) {\n        throw new Error(`Unknown id for changed: ${id}`);\n      }\n\n      if (callbacks.changed) {\n        callbacks.changed.call(this, id, EJSON.clone(fields));\n      }\n\n      DiffSequence.applyChanges(doc, fields);\n    };\n\n    this.applyChange.removed = id => {\n      if (callbacks.removed) {\n        callbacks.removed.call(this, id);\n      }\n\n      this.docs.remove(id);\n    };\n  }\n};\n\nLocalCollection._IdMap = class _IdMap extends IdMap {\n  constructor() {\n    super(MongoID.idStringify, MongoID.idParse);\n  }\n};\n\n// Wrap a transform function to return objects that have the _id field\n// of the untransformed document. This ensures that subsystems such as\n// the observe-sequence package that call `observe` can keep track of\n// the documents identities.\n//\n// - Require that it returns objects\n// - If the return value has an _id field, verify that it matches the\n//   original _id field\n// - If the return value doesn't have an _id field, add it back.\nLocalCollection.wrapTransform = transform => {\n  if (!transform) {\n    return null;\n  }\n\n  // No need to doubly-wrap transforms.\n  if (transform.__wrappedTransform__) {\n    return transform;\n  }\n\n  const wrapped = doc => {\n    if (!hasOwn.call(doc, '_id')) {\n      // XXX do we ever have a transform on the oplog's collection? because that\n      // collection has no _id.\n      throw new Error('can only transform documents with _id');\n    }\n\n    const id = doc._id;\n\n    // XXX consider making tracker a weak dependency and checking\n    // Package.tracker here\n    const transformed = Tracker.nonreactive(() => transform(doc));\n\n    if (!LocalCollection._isPlainObject(transformed)) {\n      throw new Error('transform must return object');\n    }\n\n    if (hasOwn.call(transformed, '_id')) {\n      if (!EJSON.equals(transformed._id, id)) {\n        throw new Error('transformed document can\\'t have different _id');\n      }\n    } else {\n      transformed._id = id;\n    }\n\n    return transformed;\n  };\n\n  wrapped.__wrappedTransform__ = true;\n\n  return wrapped;\n};\n\n// XXX the sorted-query logic below is laughably inefficient. we'll\n// need to come up with a better datastructure for this.\n//\n// XXX the logic for observing with a skip or a limit is even more\n// laughably inefficient. we recompute the whole results every time!\n\n// This binary search puts a value between any equal values, and the first\n// lesser value.\nLocalCollection._binarySearch = (cmp, array, value) => {\n  let first = 0;\n  let range = array.length;\n\n  while (range > 0) {\n    const halfRange = Math.floor(range / 2);\n\n    if (cmp(value, array[first + halfRange]) >= 0) {\n      first += halfRange + 1;\n      range -= halfRange + 1;\n    } else {\n      range = halfRange;\n    }\n  }\n\n  return first;\n};\n\nLocalCollection._checkSupportedProjection = fields => {\n  if (fields !== Object(fields) || Array.isArray(fields)) {\n    throw MinimongoError('fields option must be an object');\n  }\n\n  Object.keys(fields).forEach(keyPath => {\n    if (keyPath.split('.').includes('$')) {\n      throw MinimongoError(\n        'Minimongo doesn\\'t support $ operator in projections yet.'\n      );\n    }\n\n    const value = fields[keyPath];\n\n    if (typeof value === 'object' &&\n        ['$elemMatch', '$meta', '$slice'].some(key =>\n          hasOwn.call(value, key)\n        )) {\n      throw MinimongoError(\n        'Minimongo doesn\\'t support operators in projections yet.'\n      );\n    }\n\n    if (![1, 0, true, false].includes(value)) {\n      throw MinimongoError(\n        'Projection values should be one of 1, 0, true, or false'\n      );\n    }\n  });\n};\n\n// Knows how to compile a fields projection to a predicate function.\n// @returns - Function: a closure that filters out an object according to the\n//            fields projection rules:\n//            @param obj - Object: MongoDB-styled document\n//            @returns - Object: a document with the fields filtered out\n//                       according to projection rules. Doesn't retain subfields\n//                       of passed argument.\nLocalCollection._compileProjection = fields => {\n  LocalCollection._checkSupportedProjection(fields);\n\n  const _idProjection = fields._id === undefined ? true : fields._id;\n  const details = projectionDetails(fields);\n\n  // returns transformed doc according to ruleTree\n  const transform = (doc, ruleTree) => {\n    // Special case for \"sets\"\n    if (Array.isArray(doc)) {\n      return doc.map(subdoc => transform(subdoc, ruleTree));\n    }\n\n    const result = details.including ? {} : EJSON.clone(doc);\n\n    Object.keys(ruleTree).forEach(key => {\n      if (doc == null || !hasOwn.call(doc, key)) {\n        return;\n      }\n\n      const rule = ruleTree[key];\n\n      if (rule === Object(rule)) {\n        // For sub-objects/subsets we branch\n        if (doc[key] === Object(doc[key])) {\n          result[key] = transform(doc[key], rule);\n        }\n      } else if (details.including) {\n        // Otherwise we don't even touch this subfield\n        result[key] = EJSON.clone(doc[key]);\n      } else {\n        delete result[key];\n      }\n    });\n\n    return doc != null ? result : doc;\n  };\n\n  return doc => {\n    const result = transform(doc, details.tree);\n\n    if (_idProjection && hasOwn.call(doc, '_id')) {\n      result._id = doc._id;\n    }\n\n    if (!_idProjection && hasOwn.call(result, '_id')) {\n      delete result._id;\n    }\n\n    return result;\n  };\n};\n\n// Calculates the document to insert in case we're doing an upsert and the\n// selector does not match any elements\nLocalCollection._createUpsertDocument = (selector, modifier) => {\n  const selectorDocument = populateDocumentWithQueryFields(selector);\n  const isModify = LocalCollection._isModificationMod(modifier);\n\n  const newDoc = {};\n\n  if (selectorDocument._id) {\n    newDoc._id = selectorDocument._id;\n    delete selectorDocument._id;\n  }\n\n  // This double _modify call is made to help with nested properties (see issue\n  // #8631). We do this even if it's a replacement for validation purposes (e.g.\n  // ambiguous id's)\n  LocalCollection._modify(newDoc, {$set: selectorDocument});\n  LocalCollection._modify(newDoc, modifier, {isInsert: true});\n\n  if (isModify) {\n    return newDoc;\n  }\n\n  // Replacement can take _id from query document\n  const replacement = Object.assign({}, modifier);\n  if (newDoc._id) {\n    replacement._id = newDoc._id;\n  }\n\n  return replacement;\n};\n\nLocalCollection._diffObjects = (left, right, callbacks) => {\n  return DiffSequence.diffObjects(left, right, callbacks);\n};\n\n// ordered: bool.\n// old_results and new_results: collections of documents.\n//    if ordered, they are arrays.\n//    if unordered, they are IdMaps\nLocalCollection._diffQueryChanges = (ordered, oldResults, newResults, observer, options) =>\n  DiffSequence.diffQueryChanges(ordered, oldResults, newResults, observer, options)\n;\n\nLocalCollection._diffQueryOrderedChanges = (oldResults, newResults, observer, options) =>\n  DiffSequence.diffQueryOrderedChanges(oldResults, newResults, observer, options)\n;\n\nLocalCollection._diffQueryUnorderedChanges = (oldResults, newResults, observer, options) =>\n  DiffSequence.diffQueryUnorderedChanges(oldResults, newResults, observer, options)\n;\n\nLocalCollection._findInOrderedResults = (query, doc) => {\n  if (!query.ordered) {\n    throw new Error('Can\\'t call _findInOrderedResults on unordered query');\n  }\n\n  for (let i = 0; i < query.results.length; i++) {\n    if (query.results[i] === doc) {\n      return i;\n    }\n  }\n\n  throw Error('object missing from query');\n};\n\n// If this is a selector which explicitly constrains the match by ID to a finite\n// number of documents, returns a list of their IDs.  Otherwise returns\n// null. Note that the selector may have other restrictions so it may not even\n// match those document!  We care about $in and $and since those are generated\n// access-controlled update and remove.\nLocalCollection._idsMatchedBySelector = selector => {\n  // Is the selector just an ID?\n  if (LocalCollection._selectorIsId(selector)) {\n    return [selector];\n  }\n\n  if (!selector) {\n    return null;\n  }\n\n  // Do we have an _id clause?\n  if (hasOwn.call(selector, '_id')) {\n    // Is the _id clause just an ID?\n    if (LocalCollection._selectorIsId(selector._id)) {\n      return [selector._id];\n    }\n\n    // Is the _id clause {_id: {$in: [\"x\", \"y\", \"z\"]}}?\n    if (selector._id\n        && Array.isArray(selector._id.$in)\n        && selector._id.$in.length\n        && selector._id.$in.every(LocalCollection._selectorIsId)) {\n      return selector._id.$in;\n    }\n\n    return null;\n  }\n\n  // If this is a top-level $and, and any of the clauses constrain their\n  // documents, then the whole selector is constrained by any one clause's\n  // constraint. (Well, by their intersection, but that seems unlikely.)\n  if (Array.isArray(selector.$and)) {\n    for (let i = 0; i < selector.$and.length; ++i) {\n      const subIds = LocalCollection._idsMatchedBySelector(selector.$and[i]);\n\n      if (subIds) {\n        return subIds;\n      }\n    }\n  }\n\n  return null;\n};\n\nLocalCollection._insertInResultsSync = (query, doc) => {\n  const fields = EJSON.clone(doc);\n\n  delete fields._id;\n\n  if (query.ordered) {\n    if (!query.sorter) {\n      query.addedBefore(doc._id, query.projectionFn(fields), null);\n      query.results.push(doc);\n    } else {\n      const i = LocalCollection._insertInSortedList(\n        query.sorter.getComparator({distances: query.distances}),\n        query.results,\n        doc\n      );\n\n      let next = query.results[i + 1];\n      if (next) {\n        next = next._id;\n      } else {\n        next = null;\n      }\n\n      query.addedBefore(doc._id, query.projectionFn(fields), next);\n    }\n\n    query.added(doc._id, query.projectionFn(fields));\n  } else {\n    query.added(doc._id, query.projectionFn(fields));\n    query.results.set(doc._id, doc);\n  }\n};\n\nLocalCollection._insertInResultsAsync = async (query, doc) => {\n  const fields = EJSON.clone(doc);\n\n  delete fields._id;\n\n  if (query.ordered) {\n    if (!query.sorter) {\n      await query.addedBefore(doc._id, query.projectionFn(fields), null);\n      query.results.push(doc);\n    } else {\n      const i = LocalCollection._insertInSortedList(\n        query.sorter.getComparator({distances: query.distances}),\n        query.results,\n        doc\n      );\n\n      let next = query.results[i + 1];\n      if (next) {\n        next = next._id;\n      } else {\n        next = null;\n      }\n\n      await query.addedBefore(doc._id, query.projectionFn(fields), next);\n    }\n\n    await query.added(doc._id, query.projectionFn(fields));\n  } else {\n    await query.added(doc._id, query.projectionFn(fields));\n    query.results.set(doc._id, doc);\n  }\n};\n\nLocalCollection._insertInSortedList = (cmp, array, value) => {\n  if (array.length === 0) {\n    array.push(value);\n    return 0;\n  }\n\n  const i = LocalCollection._binarySearch(cmp, array, value);\n\n  array.splice(i, 0, value);\n\n  return i;\n};\n\nLocalCollection._isModificationMod = mod => {\n  let isModify = false;\n  let isReplace = false;\n\n  Object.keys(mod).forEach(key => {\n    if (key.substr(0, 1) === '$') {\n      isModify = true;\n    } else {\n      isReplace = true;\n    }\n  });\n\n  if (isModify && isReplace) {\n    throw new Error(\n      'Update parameter cannot have both modifier and non-modifier fields.'\n    );\n  }\n\n  return isModify;\n};\n\n// XXX maybe this should be EJSON.isObject, though EJSON doesn't know about\n// RegExp\n// XXX note that _type(undefined) === 3!!!!\nLocalCollection._isPlainObject = x => {\n  return x && LocalCollection._f._type(x) === 3;\n};\n\n// XXX need a strategy for passing the binding of $ into this\n// function, from the compiled selector\n//\n// maybe just {key.up.to.just.before.dollarsign: array_index}\n//\n// XXX atomicity: if one modification fails, do we roll back the whole\n// change?\n//\n// options:\n//   - isInsert is set when _modify is being called to compute the document to\n//     insert as part of an upsert operation. We use this primarily to figure\n//     out when to set the fields in $setOnInsert, if present.\nLocalCollection._modify = (doc, modifier, options = {}) => {\n  if (!LocalCollection._isPlainObject(modifier)) {\n    throw MinimongoError('Modifier must be an object');\n  }\n\n  // Make sure the caller can't mutate our data structures.\n  modifier = EJSON.clone(modifier);\n\n  const isModifier = isOperatorObject(modifier);\n  const newDoc = isModifier ? EJSON.clone(doc) : modifier;\n\n  if (isModifier) {\n    // apply modifiers to the doc.\n    Object.keys(modifier).forEach(operator => {\n      // Treat $setOnInsert as $set if this is an insert.\n      const setOnInsert = options.isInsert && operator === '$setOnInsert';\n      const modFunc = MODIFIERS[setOnInsert ? '$set' : operator];\n      const operand = modifier[operator];\n\n      if (!modFunc) {\n        throw MinimongoError(`Invalid modifier specified ${operator}`);\n      }\n\n      Object.keys(operand).forEach(keypath => {\n        const arg = operand[keypath];\n\n        if (keypath === '') {\n          throw MinimongoError('An empty update path is not valid.');\n        }\n\n        const keyparts = keypath.split('.');\n\n        if (!keyparts.every(Boolean)) {\n          throw MinimongoError(\n            `The update path '${keypath}' contains an empty field name, ` +\n            'which is not allowed.'\n          );\n        }\n\n        const target = findModTarget(newDoc, keyparts, {\n          arrayIndices: options.arrayIndices,\n          forbidArray: operator === '$rename',\n          noCreate: NO_CREATE_MODIFIERS[operator]\n        });\n\n        modFunc(target, keyparts.pop(), arg, keypath, newDoc);\n      });\n    });\n\n    if (doc._id && !EJSON.equals(doc._id, newDoc._id)) {\n      throw MinimongoError(\n        `After applying the update to the document {_id: \"${doc._id}\", ...},` +\n        ' the (immutable) field \\'_id\\' was found to have been altered to ' +\n        `_id: \"${newDoc._id}\"`\n      );\n    }\n  } else {\n    if (doc._id && modifier._id && !EJSON.equals(doc._id, modifier._id)) {\n      throw MinimongoError(\n        `The _id field cannot be changed from {_id: \"${doc._id}\"} to ` +\n        `{_id: \"${modifier._id}\"}`\n      );\n    }\n\n    // replace the whole document\n    assertHasValidFieldNames(modifier);\n  }\n\n  // move new document into place.\n  Object.keys(doc).forEach(key => {\n    // Note: this used to be for (var key in doc) however, this does not\n    // work right in Opera. Deleting from a doc while iterating over it\n    // would sometimes cause opera to skip some keys.\n    if (key !== '_id') {\n      delete doc[key];\n    }\n  });\n\n  Object.keys(newDoc).forEach(key => {\n    doc[key] = newDoc[key];\n  });\n};\n\nLocalCollection._observeFromObserveChanges = (cursor, observeCallbacks) => {\n  const transform = cursor.getTransform() || (doc => doc);\n  let suppressed = !!observeCallbacks._suppress_initial;\n\n  let observeChangesCallbacks;\n  if (LocalCollection._observeCallbacksAreOrdered(observeCallbacks)) {\n    // The \"_no_indices\" option sets all index arguments to -1 and skips the\n    // linear scans required to generate them.  This lets observers that don't\n    // need absolute indices benefit from the other features of this API --\n    // relative order, transforms, and applyChanges -- without the speed hit.\n    const indices = !observeCallbacks._no_indices;\n\n    observeChangesCallbacks = {\n      addedBefore(id, fields, before) {\n        const check = suppressed || !(observeCallbacks.addedAt || observeCallbacks.added)\n        if (check) {\n          return;\n        }\n\n        const doc = transform(Object.assign(fields, {_id: id}));\n\n        if (observeCallbacks.addedAt) {\n          observeCallbacks.addedAt(\n              doc,\n              indices\n                  ? before\n                      ? this.docs.indexOf(before)\n                      : this.docs.size()\n                  : -1,\n              before\n          );\n        } else {\n          observeCallbacks.added(doc);\n        }\n      },\n      changed(id, fields) {\n\n        if (!(observeCallbacks.changedAt || observeCallbacks.changed)) {\n          return;\n        }\n\n        let doc = EJSON.clone(this.docs.get(id));\n        if (!doc) {\n          throw new Error(`Unknown id for changed: ${id}`);\n        }\n\n        const oldDoc = transform(EJSON.clone(doc));\n\n        DiffSequence.applyChanges(doc, fields);\n\n        if (observeCallbacks.changedAt) {\n          observeCallbacks.changedAt(\n              transform(doc),\n              oldDoc,\n              indices ? this.docs.indexOf(id) : -1\n          );\n        } else {\n          observeCallbacks.changed(transform(doc), oldDoc);\n        }\n      },\n      movedBefore(id, before) {\n        if (!observeCallbacks.movedTo) {\n          return;\n        }\n\n        const from = indices ? this.docs.indexOf(id) : -1;\n        let to = indices\n            ? before\n                ? this.docs.indexOf(before)\n                : this.docs.size()\n            : -1;\n\n        // When not moving backwards, adjust for the fact that removing the\n        // document slides everything back one slot.\n        if (to > from) {\n          --to;\n        }\n\n        observeCallbacks.movedTo(\n            transform(EJSON.clone(this.docs.get(id))),\n            from,\n            to,\n            before || null\n        );\n      },\n      removed(id) {\n        if (!(observeCallbacks.removedAt || observeCallbacks.removed)) {\n          return;\n        }\n\n        // technically maybe there should be an EJSON.clone here, but it's about\n        // to be removed from this.docs!\n        const doc = transform(this.docs.get(id));\n\n        if (observeCallbacks.removedAt) {\n          observeCallbacks.removedAt(doc, indices ? this.docs.indexOf(id) : -1);\n        } else {\n          observeCallbacks.removed(doc);\n        }\n      },\n    };\n  } else {\n    observeChangesCallbacks = {\n      added(id, fields) {\n        if (!suppressed && observeCallbacks.added) {\n          observeCallbacks.added(transform(Object.assign(fields, {_id: id})));\n        }\n      },\n      changed(id, fields) {\n        if (observeCallbacks.changed) {\n          const oldDoc = this.docs.get(id);\n          const doc = EJSON.clone(oldDoc);\n\n          DiffSequence.applyChanges(doc, fields);\n\n          observeCallbacks.changed(\n              transform(doc),\n              transform(EJSON.clone(oldDoc))\n          );\n        }\n      },\n      removed(id) {\n        if (observeCallbacks.removed) {\n          observeCallbacks.removed(transform(this.docs.get(id)));\n        }\n      },\n    };\n  }\n\n  const changeObserver = new LocalCollection._CachingChangeObserver({\n    callbacks: observeChangesCallbacks\n  });\n\n  // CachingChangeObserver clones all received input on its callbacks\n  // So we can mark it as safe to reduce the ejson clones.\n  // This is tested by the `mongo-livedata - (extended) scribbling` tests\n  changeObserver.applyChange._fromObserve = true;\n  const handle = cursor.observeChanges(changeObserver.applyChange,\n      { nonMutatingCallbacks: true });\n\n  // If needed, re-enable callbacks as soon as the initial batch is ready.\n  const setSuppressed = (h) => {\n    if (h.isReady) suppressed = false;\n    else h.isReadyPromise?.then(() => (suppressed = false));\n  };\n  // When we call cursor.observeChanges() it can be the on from\n  // the mongo package (instead of the minimongo one) and it doesn't have isReady and isReadyPromise\n  if (Meteor._isPromise(handle)) {\n    handle.then(setSuppressed);\n  } else {\n    setSuppressed(handle);\n  }\n  return handle;\n};\n\nLocalCollection._observeCallbacksAreOrdered = callbacks => {\n  if (callbacks.added && callbacks.addedAt) {\n    throw new Error('Please specify only one of added() and addedAt()');\n  }\n\n  if (callbacks.changed && callbacks.changedAt) {\n    throw new Error('Please specify only one of changed() and changedAt()');\n  }\n\n  if (callbacks.removed && callbacks.removedAt) {\n    throw new Error('Please specify only one of removed() and removedAt()');\n  }\n\n  return !!(\n    callbacks.addedAt ||\n    callbacks.changedAt ||\n    callbacks.movedTo ||\n    callbacks.removedAt\n  );\n};\n\nLocalCollection._observeChangesCallbacksAreOrdered = callbacks => {\n  if (callbacks.added && callbacks.addedBefore) {\n    throw new Error('Please specify only one of added() and addedBefore()');\n  }\n\n  return !!(callbacks.addedBefore || callbacks.movedBefore);\n};\n\nLocalCollection._removeFromResultsSync = (query, doc) => {\n  if (query.ordered) {\n    const i = LocalCollection._findInOrderedResults(query, doc);\n\n    query.removed(doc._id);\n    query.results.splice(i, 1);\n  } else {\n    const id = doc._id;  // in case callback mutates doc\n\n    query.removed(doc._id);\n    query.results.remove(id);\n  }\n};\n\nLocalCollection._removeFromResultsAsync = async (query, doc) => {\n  if (query.ordered) {\n    const i = LocalCollection._findInOrderedResults(query, doc);\n\n    await query.removed(doc._id);\n    query.results.splice(i, 1);\n  } else {\n    const id = doc._id;  // in case callback mutates doc\n\n    await query.removed(doc._id);\n    query.results.remove(id);\n  }\n};\n\n// Is this selector just shorthand for lookup by _id?\nLocalCollection._selectorIsId = selector =>\n  typeof selector === 'number' ||\n  typeof selector === 'string' ||\n  selector instanceof MongoID.ObjectID\n;\n\n// Is the selector just lookup by _id (shorthand or not)?\nLocalCollection._selectorIsIdPerhapsAsObject = selector =>\n  LocalCollection._selectorIsId(selector) ||\n  LocalCollection._selectorIsId(selector && selector._id) &&\n  Object.keys(selector).length === 1\n;\n\nLocalCollection._updateInResultsSync = (query, doc, old_doc) => {\n  if (!EJSON.equals(doc._id, old_doc._id)) {\n    throw new Error('Can\\'t change a doc\\'s _id while updating');\n  }\n\n  const projectionFn = query.projectionFn;\n  const changedFields = DiffSequence.makeChangedFields(\n    projectionFn(doc),\n    projectionFn(old_doc)\n  );\n\n  if (!query.ordered) {\n    if (Object.keys(changedFields).length) {\n      query.changed(doc._id, changedFields);\n      query.results.set(doc._id, doc);\n    }\n\n    return;\n  }\n\n  const old_idx = LocalCollection._findInOrderedResults(query, doc);\n\n  if (Object.keys(changedFields).length) {\n    query.changed(doc._id, changedFields);\n  }\n\n  if (!query.sorter) {\n    return;\n  }\n\n  // just take it out and put it back in again, and see if the index changes\n  query.results.splice(old_idx, 1);\n\n  const new_idx = LocalCollection._insertInSortedList(\n    query.sorter.getComparator({distances: query.distances}),\n    query.results,\n    doc\n  );\n\n  if (old_idx !== new_idx) {\n    let next = query.results[new_idx + 1];\n    if (next) {\n      next = next._id;\n    } else {\n      next = null;\n    }\n\n    query.movedBefore && query.movedBefore(doc._id, next);\n  }\n};\n\nLocalCollection._updateInResultsAsync = async (query, doc, old_doc) => {\n  if (!EJSON.equals(doc._id, old_doc._id)) {\n    throw new Error('Can\\'t change a doc\\'s _id while updating');\n  }\n\n  const projectionFn = query.projectionFn;\n  const changedFields = DiffSequence.makeChangedFields(\n    projectionFn(doc),\n    projectionFn(old_doc)\n  );\n\n  if (!query.ordered) {\n    if (Object.keys(changedFields).length) {\n      await query.changed(doc._id, changedFields);\n      query.results.set(doc._id, doc);\n    }\n\n    return;\n  }\n\n  const old_idx = LocalCollection._findInOrderedResults(query, doc);\n\n  if (Object.keys(changedFields).length) {\n    await query.changed(doc._id, changedFields);\n  }\n\n  if (!query.sorter) {\n    return;\n  }\n\n  // just take it out and put it back in again, and see if the index changes\n  query.results.splice(old_idx, 1);\n\n  const new_idx = LocalCollection._insertInSortedList(\n    query.sorter.getComparator({distances: query.distances}),\n    query.results,\n    doc\n  );\n\n  if (old_idx !== new_idx) {\n    let next = query.results[new_idx + 1];\n    if (next) {\n      next = next._id;\n    } else {\n      next = null;\n    }\n\n    query.movedBefore && await query.movedBefore(doc._id, next);\n  }\n};\n\nconst MODIFIERS = {\n  $currentDate(target, field, arg) {\n    if (typeof arg === 'object' && hasOwn.call(arg, '$type')) {\n      if (arg.$type !== 'date') {\n        throw MinimongoError(\n          'Minimongo does currently only support the date type in ' +\n          '$currentDate modifiers',\n          {field}\n        );\n      }\n    } else if (arg !== true) {\n      throw MinimongoError('Invalid $currentDate modifier', {field});\n    }\n\n    target[field] = new Date();\n  },\n  $inc(target, field, arg) {\n    if (typeof arg !== 'number') {\n      throw MinimongoError('Modifier $inc allowed for numbers only', {field});\n    }\n\n    if (field in target) {\n      if (typeof target[field] !== 'number') {\n        throw MinimongoError(\n          'Cannot apply $inc modifier to non-number',\n          {field}\n        );\n      }\n\n      target[field] += arg;\n    } else {\n      target[field] = arg;\n    }\n  },\n  $min(target, field, arg) {\n    if (typeof arg !== 'number') {\n      throw MinimongoError('Modifier $min allowed for numbers only', {field});\n    }\n\n    if (field in target) {\n      if (typeof target[field] !== 'number') {\n        throw MinimongoError(\n          'Cannot apply $min modifier to non-number',\n          {field}\n        );\n      }\n\n      if (target[field] > arg) {\n        target[field] = arg;\n      }\n    } else {\n      target[field] = arg;\n    }\n  },\n  $max(target, field, arg) {\n    if (typeof arg !== 'number') {\n      throw MinimongoError('Modifier $max allowed for numbers only', {field});\n    }\n\n    if (field in target) {\n      if (typeof target[field] !== 'number') {\n        throw MinimongoError(\n          'Cannot apply $max modifier to non-number',\n          {field}\n        );\n      }\n\n      if (target[field] < arg) {\n        target[field] = arg;\n      }\n    } else {\n      target[field] = arg;\n    }\n  },\n  $mul(target, field, arg) {\n    if (typeof arg !== 'number') {\n      throw MinimongoError('Modifier $mul allowed for numbers only', {field});\n    }\n\n    if (field in target) {\n      if (typeof target[field] !== 'number') {\n        throw MinimongoError(\n          'Cannot apply $mul modifier to non-number',\n          {field}\n        );\n      }\n\n      target[field] *= arg;\n    } else {\n      target[field] = 0;\n    }\n  },\n  $rename(target, field, arg, keypath, doc) {\n    // no idea why mongo has this restriction..\n    if (keypath === arg) {\n      throw MinimongoError('$rename source must differ from target', {field});\n    }\n\n    if (target === null) {\n      throw MinimongoError('$rename source field invalid', {field});\n    }\n\n    if (typeof arg !== 'string') {\n      throw MinimongoError('$rename target must be a string', {field});\n    }\n\n    if (arg.includes('\\0')) {\n      // Null bytes are not allowed in Mongo field names\n      // https://docs.mongodb.com/manual/reference/limits/#Restrictions-on-Field-Names\n      throw MinimongoError(\n        'The \\'to\\' field for $rename cannot contain an embedded null byte',\n        {field}\n      );\n    }\n\n    if (target === undefined) {\n      return;\n    }\n\n    const object = target[field];\n\n    delete target[field];\n\n    const keyparts = arg.split('.');\n    const target2 = findModTarget(doc, keyparts, {forbidArray: true});\n\n    if (target2 === null) {\n      throw MinimongoError('$rename target field invalid', {field});\n    }\n\n    target2[keyparts.pop()] = object;\n  },\n  $set(target, field, arg) {\n    if (target !== Object(target)) { // not an array or an object\n      const error = MinimongoError(\n        'Cannot set property on non-object field',\n        {field}\n      );\n      error.setPropertyError = true;\n      throw error;\n    }\n\n    if (target === null) {\n      const error = MinimongoError('Cannot set property on null', {field});\n      error.setPropertyError = true;\n      throw error;\n    }\n\n    assertHasValidFieldNames(arg);\n\n    target[field] = arg;\n  },\n  $setOnInsert(target, field, arg) {\n    // converted to `$set` in `_modify`\n  },\n  $unset(target, field, arg) {\n    if (target !== undefined) {\n      if (target instanceof Array) {\n        if (field in target) {\n          target[field] = null;\n        }\n      } else {\n        delete target[field];\n      }\n    }\n  },\n  $push(target, field, arg) {\n    if (target[field] === undefined) {\n      target[field] = [];\n    }\n\n    if (!(target[field] instanceof Array)) {\n      throw MinimongoError('Cannot apply $push modifier to non-array', {field});\n    }\n\n    if (!(arg && arg.$each)) {\n      // Simple mode: not $each\n      assertHasValidFieldNames(arg);\n\n      target[field].push(arg);\n\n      return;\n    }\n\n    // Fancy mode: $each (and maybe $slice and $sort and $position)\n    const toPush = arg.$each;\n    if (!(toPush instanceof Array)) {\n      throw MinimongoError('$each must be an array', {field});\n    }\n\n    assertHasValidFieldNames(toPush);\n\n    // Parse $position\n    let position = undefined;\n    if ('$position' in arg) {\n      if (typeof arg.$position !== 'number') {\n        throw MinimongoError('$position must be a numeric value', {field});\n      }\n\n      // XXX should check to make sure integer\n      if (arg.$position < 0) {\n        throw MinimongoError(\n          '$position in $push must be zero or positive',\n          {field}\n        );\n      }\n\n      position = arg.$position;\n    }\n\n    // Parse $slice.\n    let slice = undefined;\n    if ('$slice' in arg) {\n      if (typeof arg.$slice !== 'number') {\n        throw MinimongoError('$slice must be a numeric value', {field});\n      }\n\n      // XXX should check to make sure integer\n      slice = arg.$slice;\n    }\n\n    // Parse $sort.\n    let sortFunction = undefined;\n    if (arg.$sort) {\n      if (slice === undefined) {\n        throw MinimongoError('$sort requires $slice to be present', {field});\n      }\n\n      // XXX this allows us to use a $sort whose value is an array, but that's\n      // actually an extension of the Node driver, so it won't work\n      // server-side. Could be confusing!\n      // XXX is it correct that we don't do geo-stuff here?\n      sortFunction = new Minimongo.Sorter(arg.$sort).getComparator();\n\n      toPush.forEach(element => {\n        if (LocalCollection._f._type(element) !== 3) {\n          throw MinimongoError(\n            '$push like modifiers using $sort require all elements to be ' +\n            'objects',\n            {field}\n          );\n        }\n      });\n    }\n\n    // Actually push.\n    if (position === undefined) {\n      toPush.forEach(element => {\n        target[field].push(element);\n      });\n    } else {\n      const spliceArguments = [position, 0];\n\n      toPush.forEach(element => {\n        spliceArguments.push(element);\n      });\n\n      target[field].splice(...spliceArguments);\n    }\n\n    // Actually sort.\n    if (sortFunction) {\n      target[field].sort(sortFunction);\n    }\n\n    // Actually slice.\n    if (slice !== undefined) {\n      if (slice === 0) {\n        target[field] = []; // differs from Array.slice!\n      } else if (slice < 0) {\n        target[field] = target[field].slice(slice);\n      } else {\n        target[field] = target[field].slice(0, slice);\n      }\n    }\n  },\n  $pushAll(target, field, arg) {\n    if (!(typeof arg === 'object' && arg instanceof Array)) {\n      throw MinimongoError('Modifier $pushAll/pullAll allowed for arrays only');\n    }\n\n    assertHasValidFieldNames(arg);\n\n    const toPush = target[field];\n\n    if (toPush === undefined) {\n      target[field] = arg;\n    } else if (!(toPush instanceof Array)) {\n      throw MinimongoError(\n        'Cannot apply $pushAll modifier to non-array',\n        {field}\n      );\n    } else {\n      toPush.push(...arg);\n    }\n  },\n  $addToSet(target, field, arg) {\n    let isEach = false;\n\n    if (typeof arg === 'object') {\n      // check if first key is '$each'\n      const keys = Object.keys(arg);\n      if (keys[0] === '$each') {\n        isEach = true;\n      }\n    }\n\n    const values = isEach ? arg.$each : [arg];\n\n    assertHasValidFieldNames(values);\n\n    const toAdd = target[field];\n    if (toAdd === undefined) {\n      target[field] = values;\n    } else if (!(toAdd instanceof Array)) {\n      throw MinimongoError(\n        'Cannot apply $addToSet modifier to non-array',\n        {field}\n      );\n    } else {\n      values.forEach(value => {\n        if (toAdd.some(element => LocalCollection._f._equal(value, element))) {\n          return;\n        }\n\n        toAdd.push(value);\n      });\n    }\n  },\n  $pop(target, field, arg) {\n    if (target === undefined) {\n      return;\n    }\n\n    const toPop = target[field];\n\n    if (toPop === undefined) {\n      return;\n    }\n\n    if (!(toPop instanceof Array)) {\n      throw MinimongoError('Cannot apply $pop modifier to non-array', {field});\n    }\n\n    if (typeof arg === 'number' && arg < 0) {\n      toPop.splice(0, 1);\n    } else {\n      toPop.pop();\n    }\n  },\n  $pull(target, field, arg) {\n    if (target === undefined) {\n      return;\n    }\n\n    const toPull = target[field];\n    if (toPull === undefined) {\n      return;\n    }\n\n    if (!(toPull instanceof Array)) {\n      throw MinimongoError(\n        'Cannot apply $pull/pullAll modifier to non-array',\n        {field}\n      );\n    }\n\n    let out;\n    if (arg != null && typeof arg === 'object' && !(arg instanceof Array)) {\n      // XXX would be much nicer to compile this once, rather than\n      // for each document we modify.. but usually we're not\n      // modifying that many documents, so we'll let it slide for\n      // now\n\n      // XXX Minimongo.Matcher isn't up for the job, because we need\n      // to permit stuff like {$pull: {a: {$gt: 4}}}.. something\n      // like {$gt: 4} is not normally a complete selector.\n      // same issue as $elemMatch possibly?\n      const matcher = new Minimongo.Matcher(arg);\n\n      out = toPull.filter(element => !matcher.documentMatches(element).result);\n    } else {\n      out = toPull.filter(element => !LocalCollection._f._equal(element, arg));\n    }\n\n    target[field] = out;\n  },\n  $pullAll(target, field, arg) {\n    if (!(typeof arg === 'object' && arg instanceof Array)) {\n      throw MinimongoError(\n        'Modifier $pushAll/pullAll allowed for arrays only',\n        {field}\n      );\n    }\n\n    if (target === undefined) {\n      return;\n    }\n\n    const toPull = target[field];\n\n    if (toPull === undefined) {\n      return;\n    }\n\n    if (!(toPull instanceof Array)) {\n      throw MinimongoError(\n        'Cannot apply $pull/pullAll modifier to non-array',\n        {field}\n      );\n    }\n\n    target[field] = toPull.filter(object =>\n      !arg.some(element => LocalCollection._f._equal(object, element))\n    );\n  },\n  $bit(target, field, arg) {\n    // XXX mongo only supports $bit on integers, and we only support\n    // native javascript numbers (doubles) so far, so we can't support $bit\n    throw MinimongoError('$bit is not supported', {field});\n  },\n  $v() {\n    // As discussed in https://github.com/meteor/meteor/issues/9623,\n    // the `$v` operator is not needed by Meteor, but problems can occur if\n    // it's not at least callable (as of Mongo >= 3.6). It's defined here as\n    // a no-op to work around these problems.\n  }\n};\n\nconst NO_CREATE_MODIFIERS = {\n  $pop: true,\n  $pull: true,\n  $pullAll: true,\n  $rename: true,\n  $unset: true\n};\n\n// Make sure field names do not contain Mongo restricted\n// characters ('.', '$', '\\0').\n// https://docs.mongodb.com/manual/reference/limits/#Restrictions-on-Field-Names\nconst invalidCharMsg = {\n  $: 'start with \\'$\\'',\n  '.': 'contain \\'.\\'',\n  '\\0': 'contain null bytes'\n};\n\n// checks if all field names in an object are valid\nfunction assertHasValidFieldNames(doc) {\n  if (doc && typeof doc === 'object') {\n    JSON.stringify(doc, (key, value) => {\n      assertIsValidFieldName(key);\n      return value;\n    });\n  }\n}\n\nfunction assertIsValidFieldName(key) {\n  let match;\n  if (typeof key === 'string' && (match = key.match(/^\\$|\\.|\\0/))) {\n    throw MinimongoError(`Key ${key} must not ${invalidCharMsg[match[0]]}`);\n  }\n}\n\n// for a.b.c.2.d.e, keyparts should be ['a', 'b', 'c', '2', 'd', 'e'],\n// and then you would operate on the 'e' property of the returned\n// object.\n//\n// if options.noCreate is falsey, creates intermediate levels of\n// structure as necessary, like mkdir -p (and raises an exception if\n// that would mean giving a non-numeric property to an array.) if\n// options.noCreate is true, return undefined instead.\n//\n// may modify the last element of keyparts to signal to the caller that it needs\n// to use a different value to index into the returned object (for example,\n// ['a', '01'] -> ['a', 1]).\n//\n// if forbidArray is true, return null if the keypath goes through an array.\n//\n// if options.arrayIndices is set, use its first element for the (first) '$' in\n// the path.\nfunction findModTarget(doc, keyparts, options = {}) {\n  let usedArrayIndex = false;\n\n  for (let i = 0; i < keyparts.length; i++) {\n    const last = i === keyparts.length - 1;\n    let keypart = keyparts[i];\n\n    if (!isIndexable(doc)) {\n      if (options.noCreate) {\n        return undefined;\n      }\n\n      const error = MinimongoError(\n        `cannot use the part '${keypart}' to traverse ${doc}`\n      );\n      error.setPropertyError = true;\n      throw error;\n    }\n\n    if (doc instanceof Array) {\n      if (options.forbidArray) {\n        return null;\n      }\n\n      if (keypart === '$') {\n        if (usedArrayIndex) {\n          throw MinimongoError('Too many positional (i.e. \\'$\\') elements');\n        }\n\n        if (!options.arrayIndices || !options.arrayIndices.length) {\n          throw MinimongoError(\n            'The positional operator did not find the match needed from the ' +\n            'query'\n          );\n        }\n\n        keypart = options.arrayIndices[0];\n        usedArrayIndex = true;\n      } else if (isNumericKey(keypart)) {\n        keypart = parseInt(keypart);\n      } else {\n        if (options.noCreate) {\n          return undefined;\n        }\n\n        throw MinimongoError(\n          `can't append to array using string field name [${keypart}]`\n        );\n      }\n\n      if (last) {\n        keyparts[i] = keypart; // handle 'a.01'\n      }\n\n      if (options.noCreate && keypart >= doc.length) {\n        return undefined;\n      }\n\n      while (doc.length < keypart) {\n        doc.push(null);\n      }\n\n      if (!last) {\n        if (doc.length === keypart) {\n          doc.push({});\n        } else if (typeof doc[keypart] !== 'object') {\n          throw MinimongoError(\n            `can't modify field '${keyparts[i + 1]}' of list value ` +\n            JSON.stringify(doc[keypart])\n          );\n        }\n      }\n    } else {\n      assertIsValidFieldName(keypart);\n\n      if (!(keypart in doc)) {\n        if (options.noCreate) {\n          return undefined;\n        }\n\n        if (!last) {\n          doc[keypart] = {};\n        }\n      }\n    }\n\n    if (last) {\n      return doc;\n    }\n\n    doc = doc[keypart];\n  }\n\n  // notreached\n}\n"],"mappings":"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","ignoreList":[]},"sourceType":"module","externalDependencies":{},"hash":"760203d39f02be14fce2462d33296778e7dfee13"}
