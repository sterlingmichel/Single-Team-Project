[{"type":"js","data":"Package[\"core-runtime\"].queue(\"meteor\",function () {/* Package-scope variables */\nvar global, meteorEnv, Meteor, EmitterPromise;\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/meteor/global.js                                                                                           //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n// Export a reliable global object for all Meteor code.\nglobal = this;\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/meteor/server_environment.js                                                                               //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nmeteorEnv = {\n  NODE_ENV: process.env.NODE_ENV || \"production\",\n  TEST_METADATA: process.env.TEST_METADATA || \"{}\"\n};\n\nconst config = typeof __meteor_runtime_config__ === \"object\" &&\n  __meteor_runtime_config__;\n\nif (config) {\n  config.meteorEnv = meteorEnv;\n}\n\nMeteor = {\n  isProduction: meteorEnv.NODE_ENV === \"production\",\n  isDevelopment: meteorEnv.NODE_ENV !== \"production\",\n  isClient: false,\n  isServer: true,\n  isCordova: false,\n  // Server code runs in Node 8+, which is decidedly \"modern\" by any\n  // reasonable definition.\n  isModern: true\n};\n\nMeteor.settings = {};\n\nif (process.env.METEOR_SETTINGS) {\n  try {\n    Meteor.settings = JSON.parse(process.env.METEOR_SETTINGS);\n  } catch (e) {\n    throw new Error(\"METEOR_SETTINGS are not valid JSON.\");\n  }\n}\n\n// Make sure that there is always a public attribute\n// to enable Meteor.settings.public on client\nif (! Meteor.settings.public) {\n    Meteor.settings.public = {};\n}\n\n// Push a subset of settings to the client.  Note that the way this\n// code is written, if the app mutates `Meteor.settings.public` on the\n// server, it also mutates\n// `__meteor_runtime_config__.PUBLIC_SETTINGS`, and the modified\n// settings will be sent to the client.\nif (config) {\n  config.PUBLIC_SETTINGS = Meteor.settings.public;\n}\n\nif (config && config.gitCommitHash) {\n  Meteor.gitCommitHash = config.gitCommitHash;\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/meteor/helpers.js                                                                                          //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nif (typeof __meteor_runtime_config__ === 'object' &&\n    __meteor_runtime_config__.meteorRelease) {\n  /**\n   * @summary `Meteor.release` is a string containing the name of the [release](#meteorupdate) with which the project was built (for example, `\"1.2.3\"`). It is `undefined` if the project was built using a git checkout of Meteor.\n   * @locus Anywhere\n   * @type {String}\n   */\n  Meteor.release = __meteor_runtime_config__.meteorRelease;\n}\n\n// XXX find a better home for these? Ideally they would be _.get,\n// _.ensure, _.delete..\n\n// _get(a,b,c,d) returns a[b][c][d], or else undefined if a[b] or\n// a[b][c] doesn't exist.\n//\nMeteor._get = function (obj /*, arguments */) {\n  for (var i = 1; i < arguments.length; i++) {\n    if (!(arguments[i] in obj))\n      return undefined;\n    obj = obj[arguments[i]];\n  }\n  return obj;\n};\n\n// _ensure(a,b,c,d) ensures that a[b][c][d] exists. If it does not,\n// it is created and set to {}. Either way, it is returned.\n//\nMeteor._ensure = function (obj /*, arguments */) {\n  for (var i = 1; i < arguments.length; i++) {\n    var key = arguments[i];\n    if (!(key in obj))\n      obj[key] = {};\n    obj = obj[key];\n  }\n\n  return obj;\n};\n\n// _delete(a, b, c, d) deletes a[b][c][d], then a[b][c] unless it\n// isn't empty, then a[b] unless it isn't empty.\n//\nMeteor._delete = function (obj /*, arguments */) {\n  var stack = [obj];\n  var leaf = true;\n  for (var i = 1; i < arguments.length - 1; i++) {\n    var key = arguments[i];\n    if (!(key in obj)) {\n      leaf = false;\n      break;\n    }\n    obj = obj[key];\n    if (typeof obj !== \"object\")\n      break;\n    stack.push(obj);\n  }\n\n  for (var i = stack.length - 1; i >= 0; i--) {\n    var key = arguments[i+1];\n\n    if (leaf)\n      leaf = false;\n    else\n      for (var other in stack[i][key])\n        return; // not empty -- we're done\n\n    delete stack[i][key];\n  }\n};\n\n\n/**\n * @memberOf Meteor\n * @locus Anywhere\n * @summary Takes a function that has a callback argument as the last one and promissify it.\n * One option would be to use node utils.promisify, but it won't work on the browser.\n * @param {Function} fn\n * @param {Object} [context]\n * @param {Boolean} [errorFirst] - If the callback follows the errorFirst style, default to true\n * @returns {function(...[*]): Promise<unknown>}\n */\nMeteor.promisify = function (fn, context, errorFirst) {\n  if (errorFirst === undefined) {\n    errorFirst = true;\n  }\n\n  return function () {\n    var self = this;\n    var filteredArgs = Array.prototype.slice.call(arguments)\n      .filter(function (i) { return i !== undefined; });\n\n    return new Promise(function (resolve, reject) {\n      var callback = Meteor.bindEnvironment(function (error, result) {\n        var _error = error, _result = result;\n        if (!errorFirst) {\n          _error = result;\n          _result = error;\n        }\n\n        if (_error) {\n          return reject(_error);\n        }\n\n        resolve(_result);\n      });\n\n      filteredArgs.push(callback);\n\n      return fn.apply(context || self, filteredArgs);\n    });\n  };\n};\n\n// wrapAsync can wrap any function that takes some number of arguments that\n// can't be undefined, followed by some optional arguments, where the callback\n// is the last optional argument.\n// e.g. fs.readFile(pathname, [callback]),\n// fs.open(pathname, flags, [mode], [callback])\n// For maximum effectiveness and least confusion, wrapAsync should be used on\n// functions where the callback is the only argument of type Function.\n\n/**\n * @memberOf Meteor\n * @summary Wrap a function that takes a callback function as its final parameter.\n * The signature of the callback of the wrapped function should be `function(error, result){}`.\n * On the server, the wrapped function can be used either synchronously (without passing a callback) or asynchronously\n * (when a callback is passed). On the client, a callback is always required; errors will be logged if there is no callback.\n * If a callback is provided, the environment captured when the original function was called will be restored in the callback.\n * The parameters of the wrapped function must not contain any optional parameters or be undefined, as the callback function is expected to be the final, non-undefined parameter.\n * @locus Anywhere\n * @param {Function} func A function that takes a callback as its final parameter\n * @param {Object} [context] Optional `this` object against which the original function will be invoked\n */\nMeteor.wrapAsync = function (fn, context) {\n  return function (/* arguments */) {\n    var self = context || this;\n    var newArgs = Array.prototype.slice.call(arguments);\n    var callback;\n\n    for (var i = newArgs.length - 1; i >= 0; --i) {\n      var arg = newArgs[i];\n      var type = typeof arg;\n      if (type !== \"undefined\") {\n        if (type === \"function\") {\n          callback = arg;\n        }\n        break;\n      }\n    }\n\n    if (! callback) {\n      callback = logErr;\n      ++i; // Insert the callback just after arg.\n    }\n\n    newArgs[i] = Meteor.bindEnvironment(callback);\n    return fn.apply(self, newArgs);\n  };\n};\n\nMeteor.wrapFn = function (fn) {\n  return fn;\n};\n\n// Sets child's prototype to a new object whose prototype is parent's\n// prototype. Used as:\n//   Meteor._inherits(ClassB, ClassA).\n//   _.extend(ClassB.prototype, { ... })\n// Inspired by CoffeeScript's `extend` and Google Closure's `goog.inherits`.\nvar hasOwn = Object.prototype.hasOwnProperty;\nMeteor._inherits = function (Child, Parent) {\n  // copy Parent static properties\n  for (var key in Parent) {\n    // make sure we only copy hasOwnProperty properties vs. prototype\n    // properties\n    if (hasOwn.call(Parent, key)) {\n      Child[key] = Parent[key];\n    }\n  }\n\n  // a middle member of prototype chain: takes the prototype from the Parent\n  var Middle = function () {\n    this.constructor = Child;\n  };\n  Middle.prototype = Parent.prototype;\n  Child.prototype = new Middle();\n  Child.__super__ = Parent.prototype;\n  return Child;\n};\n\nvar warnedAboutWrapAsync = false;\n\n/**\n * @deprecated in 0.9.3\n */\nMeteor._wrapAsync = function(fn, context) {\n  if (! warnedAboutWrapAsync) {\n    Meteor._debug(\"Meteor._wrapAsync has been renamed to Meteor.wrapAsync\");\n    warnedAboutWrapAsync = true;\n  }\n  return Meteor.wrapAsync.apply(Meteor, arguments);\n};\n\nfunction logErr(err) {\n  if (err) {\n    return Meteor._debug(\n      \"Exception in callback of async function\",\n      err\n    );\n  }\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/meteor/setimmediate.js                                                                                     //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n// Chooses one of three setImmediate implementations:\n//\n// * Native setImmediate (IE 10, Node 0.9+)\n//\n// * postMessage (many browsers)\n//\n// * setTimeout  (fallback)\n//\n// The postMessage implementation is based on\n// https://github.com/NobleJS/setImmediate/tree/1.0.1\n//\n// Don't use `nextTick` for Node since it runs its callbacks before\n// I/O, which is stricter than we're looking for.\n//\n// Not installed as a polyfill, as our public API is `Meteor.defer`.\n// Since we're not trying to be a polyfill, we have some\n// simplifications:\n//\n// If one invocation of a setImmediate callback pauses itself by a\n// call to alert/prompt/showModelDialog, the NobleJS polyfill\n// implementation ensured that no setImmedate callback would run until\n// the first invocation completed.  While correct per the spec, what it\n// would mean for us in practice is that any reactive updates relying\n// on Meteor.defer would be hung in the main window until the modal\n// dialog was dismissed.  Thus we only ensure that a setImmediate\n// function is called in a later event loop.\n//\n// We don't need to support using a string to be eval'ed for the\n// callback, arguments to the function, or clearImmediate.\n\n\"use strict\";\n\nvar global = this;\n\n\n// IE 10, Node >= 9.1\n\nfunction useSetImmediate() {\n  if (! global.setImmediate)\n    return null;\n  else {\n    var setImmediate = function (fn) {\n      global.setImmediate(fn);\n    };\n    setImmediate.implementation = 'setImmediate';\n    return setImmediate;\n  }\n}\n\n\n// Android 2.3.6, Chrome 26, Firefox 20, IE 8-9, iOS 5.1.1 Safari\n\nfunction usePostMessage() {\n  // The test against `importScripts` prevents this implementation\n  // from being installed inside a web worker, where\n  // `global.postMessage` means something completely different and\n  // can't be used for this purpose.\n\n  if (!global.postMessage || global.importScripts) {\n    return null;\n  }\n\n  // Avoid synchronous post message implementations.\n\n  var postMessageIsAsynchronous = true;\n  var oldOnMessage = global.onmessage;\n  global.onmessage = function () {\n      postMessageIsAsynchronous = false;\n  };\n  global.postMessage(\"\", \"*\");\n  global.onmessage = oldOnMessage;\n\n  if (! postMessageIsAsynchronous)\n    return null;\n\n  var funcIndex = 0;\n  var funcs = {};\n\n  // Installs an event handler on `global` for the `message` event: see\n  // * https://developer.mozilla.org/en/DOM/window.postMessage\n  // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n\n  // XXX use Random.id() here?\n  var MESSAGE_PREFIX = \"Meteor._setImmediate.\" + Math.random() + '.';\n\n  function isStringAndStartsWith(string, putativeStart) {\n    return (typeof string === \"string\" &&\n            string.substring(0, putativeStart.length) === putativeStart);\n  }\n\n  function onGlobalMessage(event) {\n    // This will catch all incoming messages (even from other\n    // windows!), so we need to try reasonably hard to avoid letting\n    // anyone else trick us into firing off. We test the origin is\n    // still this window, and that a (randomly generated)\n    // unpredictable identifying prefix is present.\n    if (event.source === global &&\n        isStringAndStartsWith(event.data, MESSAGE_PREFIX)) {\n      var index = event.data.substring(MESSAGE_PREFIX.length);\n      try {\n        if (funcs[index])\n          funcs[index]();\n      }\n      finally {\n        delete funcs[index];\n      }\n    }\n  }\n\n  if (global.addEventListener) {\n    global.addEventListener(\"message\", onGlobalMessage, false);\n  } else {\n    global.attachEvent(\"onmessage\", onGlobalMessage);\n  }\n\n  var setImmediate = function (fn) {\n    // Make `global` post a message to itself with the handle and\n    // identifying prefix, thus asynchronously invoking our\n    // onGlobalMessage listener above.\n    ++funcIndex;\n    funcs[funcIndex] = fn;\n    global.postMessage(MESSAGE_PREFIX + funcIndex, \"*\");\n  };\n  setImmediate.implementation = 'postMessage';\n  return setImmediate;\n}\n\n\nfunction useTimeout() {\n  var setImmediate = function (fn) {\n    global.setTimeout(fn, 0);\n  };\n  setImmediate.implementation = 'setTimeout';\n  return setImmediate;\n}\n\n\nMeteor._setImmediate =\n  useSetImmediate() ||\n  usePostMessage() ||\n  useTimeout();\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/meteor/timers.js                                                                                           //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nfunction withoutInvocation(f) {\n  if (Package.ddp) {\n    var DDP = Package.ddp.DDP;\n    var CurrentInvocation =\n      DDP._CurrentMethodInvocation ||\n      // For backwards compatibility, as explained in this issue:\n      // https://github.com/meteor/meteor/issues/8947\n      DDP._CurrentInvocation;\n\n    var invocation = CurrentInvocation.get();\n    if (invocation && invocation.isSimulation) {\n      throw new Error(\"Can't set timers inside simulations\");\n    }\n\n    return function () {\n      CurrentInvocation.withValue(null, f);\n    };\n  } else {\n    return f;\n  }\n}\n\nfunction bindAndCatch(context, f) {\n  return Meteor.bindEnvironment(withoutInvocation(f), context);\n}\n\n// Meteor.setTimeout and Meteor.setInterval callbacks scheduled\n// inside a server method are not part of the method invocation and\n// should clear out the CurrentMethodInvocation environment variable.\n\n/**\n * @memberOf Meteor\n * @summary Call a function in the future after waiting for a specified delay.\n * @locus Anywhere\n * @param {Function} func The function to run\n * @param {Number} delay Number of milliseconds to wait before calling function\n */\nMeteor.setTimeout = function (f, duration) {\n  return setTimeout(bindAndCatch(\"setTimeout callback\", f), duration);\n};\n\n/**\n * @memberOf Meteor\n * @summary Call a function repeatedly, with a time delay between calls.\n * @locus Anywhere\n * @param {Function} func The function to run\n * @param {Number} delay Number of milliseconds to wait between each function call.\n */\nMeteor.setInterval = function (f, duration) {\n  return setInterval(bindAndCatch(\"setInterval callback\", f), duration);\n};\n\n/**\n * @memberOf Meteor\n * @summary Cancel a repeating function call scheduled by `Meteor.setInterval`.\n * @locus Anywhere\n * @param {Object} id The handle returned by `Meteor.setInterval`\n */\nMeteor.clearInterval = function(x) {\n  return clearInterval(x);\n};\n\n/**\n * @memberOf Meteor\n * @summary Cancel a function call scheduled by `Meteor.setTimeout`.\n * @locus Anywhere\n * @param {Object} id The handle returned by `Meteor.setTimeout`\n */\nMeteor.clearTimeout = function(x) {\n  return clearTimeout(x);\n};\n\n// XXX consider making this guarantee ordering of defer'd callbacks, like\n// Tracker.afterFlush or Node's nextTick (in practice). Then tests can do:\n//    callSomethingThatDefersSomeWork();\n//    Meteor.defer(expect(somethingThatValidatesThatTheWorkHappened));\n\n/**\n * @memberOf Meteor\n * @summary Defer execution of a function to run asynchronously in the background (similar to `Meteor.setTimeout(func, 0)`.\n * @locus Anywhere\n * @param {Function} func The function to run\n */\nMeteor.defer = function (f) {\n  Meteor._setImmediate(bindAndCatch(\"defer callback\", f));\n};\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/meteor/errors.js                                                                                           //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n// Makes an error subclass which properly contains a stack trace in most\n// environments. constructor can set fields on `this` (and should probably set\n// `message`, which is what gets displayed at the top of a stack trace).\n//\nMeteor.makeErrorType = function (name, constructor) {\n  var errorClass = function (/*arguments*/) {\n    // Ensure we get a proper stack trace in most Javascript environments\n    if (Error.captureStackTrace) {\n      // V8 environments (Chrome and Node.js)\n      Error.captureStackTrace(this, errorClass);\n    } else {\n      // Borrow the .stack property of a native Error object.\n      this.stack = new Error().stack;\n    }\n    // Safari magically works.\n\n    constructor.apply(this, arguments);\n\n    this.errorType = name;\n  };\n\n  Meteor._inherits(errorClass, Error);\n\n  return errorClass;\n};\n\n// This should probably be in the livedata package, but we don't want\n// to require you to use the livedata package to get it. Eventually we\n// should probably rename it to DDP.Error and put it back in the\n// 'livedata' package (which we should rename to 'ddp' also.)\n//\n// Note: The DDP server assumes that Meteor.Error EJSON-serializes as an object\n// containing 'error' and optionally 'reason' and 'details'.\n// The DDP client manually puts these into Meteor.Error objects. (We don't use\n// EJSON.addType here because the type is determined by location in the\n// protocol, not text on the wire.)\n\n/**\n * @summary This class represents a symbolic error thrown by a method.\n * @locus Anywhere\n * @class\n * @param {String} error A string code uniquely identifying this kind of error.\n * This string should be used by callers of the method to determine the\n * appropriate action to take, instead of attempting to parse the reason\n * or details fields.\n *\n * For legacy reasons, some built-in Meteor functions such as `check` throw\n * errors with a number in this field.\n *\n * @param {String} [reason] Optional.  A short human-readable summary of the\n * error, like 'Not Found'.\n * @param {String} [details] Optional.  Additional information about the error,\n * like a textual stack trace.\n */\nMeteor.Error = Meteor.makeErrorType(\n  \"Meteor.Error\",\n  function (error, reason, details) {\n    var self = this;\n\n    // Newer versions of DDP use this property to signify that an error\n    // can be sent back and reconstructed on the calling client.\n    self.isClientSafe = true;\n\n    // String code uniquely identifying this kind of error.\n    self.error = error;\n\n    // Optional: A short human-readable summary of the error. Not\n    // intended to be shown to end users, just developers. (\"Not Found\",\n    // \"Internal Server Error\")\n    self.reason = reason;\n\n    // Optional: Additional information about the error, say for\n    // debugging. It might be a (textual) stack trace if the server is\n    // willing to provide one. The corresponding thing in HTTP would be\n    // the body of a 404 or 500 response. (The difference is that we\n    // never expect this to be shown to end users, only developers, so\n    // it doesn't need to be pretty.)\n    self.details = details;\n\n    // This is what gets displayed at the top of a stack trace. Current\n    // format is \"[404]\" (if no reason is set) or \"File not found [404]\"\n    if (self.reason)\n      self.message = self.reason + ' [' + self.error + ']';\n    else\n      self.message = '[' + self.error + ']';\n  });\n\n// Meteor.Error is basically data and is sent over DDP, so you should be able to\n// properly EJSON-clone it. This is especially important because if a\n// Meteor.Error is thrown through a Future, the error, reason, and details\n// properties become non-enumerable so a standard Object clone won't preserve\n// them and they will be lost from DDP.\nMeteor.Error.prototype.clone = function () {\n  var self = this;\n  return new Meteor.Error(self.error, self.reason, self.details);\n};\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/meteor/asl-helpers.js                                                                                      //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n// In Meteor versions with fibers, __meteor_bootstrap__.isFibersDisabled\n// is always undefined.\nMeteor.isFibersDisabled = typeof __meteor_bootstrap__ === 'object' &&\n  __meteor_bootstrap__.isFibersDisabled !== undefined;\nMeteor._isFibersEnabled = !Meteor.isFibersDisabled;\n\nfunction getAsl() {\n  if (!Meteor.isFibersDisabled) {\n    throw new Error('Can not use async hooks when fibers are enabled');\n  }\n\n  if (!global.__METEOR_ASYNC_LOCAL_STORAGE) {\n    // lazily create __METEOR_ASYNC_LOCAL_STORAGE since this might run in older Meteor\n    // versions that are incompatible with async hooks\n    var AsyncLocalStorage = Npm.require('async_hooks').AsyncLocalStorage;\n    global.__METEOR_ASYNC_LOCAL_STORAGE = new AsyncLocalStorage();\n  }\n\n  return global.__METEOR_ASYNC_LOCAL_STORAGE;\n}\n\nfunction getAslStore() {\n  if (!Meteor.isServer) {\n    return {};\n  }\n\n  var als = getAsl();\n  return als.getStore() || {};\n}\n\nfunction getValueFromAslStore(key) {\n  return getAslStore()[key];\n}\n\nfunction updateAslStore(key, value) {\n  return getAslStore()[key] = value;\n}\n\nfunction runFresh(fn) {\n  var als = getAsl();\n  return als.run({}, fn);\n}\n\nMeteor._getAsl = getAsl;\nMeteor._getAslStore = getAslStore;\nMeteor._getValueFromAslStore = getValueFromAslStore;\nMeteor._updateAslStore = updateAslStore;\nMeteor._runFresh = runFresh;\n\nMeteor._runAsync = function (fn, ctx, store) {\n  if (store === undefined) {\n    store = {};\n  }\n  var als = getAsl();\n\n  return als.run(\n    store || Meteor._getAslStore(),\n    function () {\n      return fn.call(ctx);\n    }\n  );\n};\n\nMeteor._isPromise = function (r) {\n  return r && typeof r.then === 'function';\n};\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/meteor/async_helpers.js                                                                                    //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nMeteor._noYieldsAllowed = function (f) {\n  var result = f();\n  if (Meteor._isPromise(result)) {\n    throw new Error(\"function is a promise when calling Meteor._noYieldsAllowed\");\n  }\n  return result\n};\n\nfunction FakeDoubleEndedQueue () {\n  this.queue = [];\n}\n\nFakeDoubleEndedQueue.prototype.push = function (task) {\n  this.queue.push(task);\n};\n\nFakeDoubleEndedQueue.prototype.shift = function () {\n  return this.queue.shift();\n};\n\nFakeDoubleEndedQueue.prototype.isEmpty = function () {\n  return this.queue.length === 0;\n};\n\nMeteor._DoubleEndedQueue = Meteor.isServer ? Npm.require('denque') : FakeDoubleEndedQueue;\n\n// Meteor._SynchronousQueue is a queue which runs task functions serially.\n// Tasks are assumed to be synchronous: ie, it's assumed that they are\n// done when they return.\n//\n// It has two methods:\n//   - queueTask queues a task to be run, and returns immediately.\n//   - runTask queues a task to be run, and then yields. It returns\n//     when the task finishes running.\n//\n// It's safe to call queueTask from within a task, but not runTask (unless\n// you're calling runTask from a nested Fiber).\n//\n// Somewhat inspired by async.queue, but specific to blocking tasks.\n// XXX break this out into an NPM module?\n// XXX could maybe use the npm 'schlock' module instead, which would\n//     also support multiple concurrent \"read\" tasks\n//\nfunction AsynchronousQueue () {\n  this._taskHandles = new Meteor._DoubleEndedQueue();\n  this._runningOrRunScheduled = false;\n  // This is true if we're currently draining.  While we're draining, a further\n  // drain is a noop, to prevent infinite loops.  \"drain\" is a heuristic type\n  // operation, that has a meaning like unto \"what a naive person would expect\n  // when modifying a table from an observe\"\n  this._draining = false;\n}\nObject.assign(AsynchronousQueue.prototype, {\n  queueTask(task) {\n    const self = this;\n    self._taskHandles.push({\n      task: task,\n      name: task.name\n    });\n    self._scheduleRun();\n  },\n\n  async _scheduleRun() {\n    // Already running or scheduled? Do nothing.\n    if (this._runningOrRunScheduled)\n      return;\n\n    this._runningOrRunScheduled = true;\n\n    let resolve;\n    const promise = new Promise(r => resolve = r);\n    const runImmediateHandle = (fn) => {\n      if (Meteor.isServer) {\n        Meteor._runFresh(() => setImmediate(fn))\n        return;\n      }\n      setTimeout(fn, 0);\n    };\n    runImmediateHandle(() => {\n      this._run().finally(resolve);\n    });\n    return promise;\n  },\n\n  async _run() {\n    if (!this._runningOrRunScheduled)\n      throw new Error(\"expected to be _runningOrRunScheduled\");\n\n    if (this._taskHandles.isEmpty()) {\n      // Done running tasks! Don't immediately schedule another run, but\n      // allow future tasks to do so.\n      this._runningOrRunScheduled = false;\n      return;\n    }\n    const taskHandle = this._taskHandles.shift();\n    let exception;\n    // Run the task.\n    try {\n      await taskHandle.task();\n    } catch (err) {\n      if (taskHandle.resolver) {\n        // We'll throw this exception through runTask.\n        exception = err;\n      } else {\n        Meteor._debug(\"Exception in queued task\", err);\n      }\n    }\n\n    // Soon, run the next task, if there is any.\n    this._runningOrRunScheduled = false;\n    this._scheduleRun();\n\n    if (taskHandle.resolver) {\n      if (exception) {\n        taskHandle.resolver(null, exception);\n      } else {\n        taskHandle.resolver();\n      }\n    }\n  },\n\n  async runTask(task) {\n    let resolver;\n    const promise = new Promise(\n      (resolve, reject) =>\n      (resolver = (res, rej) => {\n        if (rej) {\n          reject(rej);\n          return;\n        }\n        resolve(res);\n      })\n    );\n\n    const handle = {\n      task: Meteor.bindEnvironment(task, function (e) {\n        Meteor._debug('Exception from task', e);\n        throw e;\n      }),\n      name: task.name,\n      resolver,\n    };\n    this._taskHandles.push(handle);\n    await this._scheduleRun();\n    return promise;\n  },\n\n  flush() {\n    return this.runTask(() => { });\n  },\n\n  async drain() {\n    if (this._draining)\n      return;\n\n    this._draining = true;\n    while (!this._taskHandles.isEmpty()) {\n      await this.flush();\n    }\n    this._draining = false;\n  }\n});\n\nMeteor._AsynchronousQueue = AsynchronousQueue;\n\n\n// Sleep. Mostly used for debugging (eg, inserting latency into server\n// methods).\n//\nconst _sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));\nMeteor._sleepForMs = function (ms) {\n  return _sleep(ms);\n};\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/meteor/startup_server.js                                                                                   //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nMeteor.startup = function startup(callback) {\n  callback = Meteor.wrapFn(callback);\n  if (process.env.METEOR_PROFILE) {\n    // Create a temporary error to capture the current stack trace.\n    var error = new Error(\"Meteor.startup\");\n\n    // Capture the stack trace of the Meteor.startup call, excluding the\n    // startup stack frame itself.\n    Error.captureStackTrace(error, startup);\n\n    callback.stack = error.stack\n      .split(/\\n\\s*/) // Split lines and remove leading whitespace.\n      .slice(0, 2) // Only include the call site.\n      .join(\" \") // Collapse to one line.\n      .replace(/^Error: /, \"\"); // Not really an Error per se.\n  }\n\n  var bootstrap = global.__meteor_bootstrap__;\n  if (bootstrap &&\n      bootstrap.startupHooks) {\n    bootstrap.startupHooks.push(callback);\n  } else {\n    // We already started up. Just call it now.\n    callback();\n  }\n};\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/meteor/debug.js                                                                                            //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nif (Meteor.isServer) {\n  if (typeof __meteor_runtime_config__ === 'object') {\n    __meteor_runtime_config__.debug =\n      !!process.env.NODE_INSPECTOR_IPC ||\n      !!process.env.VSCODE_INSPECTOR_OPTIONS ||\n      process.execArgv.some(function(_arg) {\n        return /^--(inspect|debug)(-brk)?(=\\d+)?$/i.test(_arg);\n      });\n  }\n}\n\nMeteor.isDebug = Meteor.isClient\n  ? typeof window === 'object' && !!window.__meteor_runtime_config__.debug\n  : typeof __meteor_runtime_config__ === 'object' &&\n  !!__meteor_runtime_config__.debug;\n\nvar suppress = 0;\n\n// replacement for console.log. This is a temporary API. We should\n// provide a real logging API soon (possibly just a polyfill for\n// console?)\n//\n// NOTE: this is used on the server to print the warning about\n// having autopublish enabled when you probably meant to turn it\n// off. it's not really the proper use of something called\n// _debug. the intent is for this message to go to the terminal and\n// be very visible. if you change _debug to go someplace else, etc,\n// please fix the autopublish code to do something reasonable.\n//\nMeteor._debug = function (/* arguments */) {\n  if (suppress) {\n    suppress--;\n    return;\n  }\n  if (typeof console !== 'undefined' &&\n      typeof console.log !== 'undefined') {\n    if (arguments.length == 0) { // IE Companion breaks otherwise\n      // IE10 PP4 requires at least one argument\n      console.log('');\n    } else {\n      // IE doesn't have console.log.apply, it's not a real Object.\n      // http://stackoverflow.com/questions/5538972/console-log-apply-not-working-in-ie9\n      // http://patik.com/blog/complete-cross-browser-console-log/\n      if (typeof console.log.apply === \"function\") {\n        // Most browsers\n\n        // Chrome and Safari only hyperlink URLs to source files in first argument of\n        // console.log, so try to call it with one argument if possible.\n        // Approach taken here: If all arguments are strings, join them on space.\n        // See https://github.com/meteor/meteor/pull/732#issuecomment-13975991\n        var allArgumentsOfTypeString = true;\n        for (var i = 0; i < arguments.length; i++)\n          if (typeof arguments[i] !== \"string\")\n            allArgumentsOfTypeString = false;\n\n        if (allArgumentsOfTypeString)\n          console.log.apply(console, [Array.prototype.join.call(arguments, \" \")]);\n        else\n          console.log.apply(console, arguments);\n\n      } else if (typeof Function.prototype.bind === \"function\") {\n        // IE9\n        var log = Function.prototype.bind.call(console.log, console);\n        log.apply(console, arguments);\n      }\n    }\n  }\n};\n\n// Suppress the next 'count' Meteor._debug messsages. Use this to\n// stop tests from spamming the console.\n//\nMeteor._suppress_log = function (count) {\n  suppress += count;\n};\n\nMeteor._suppressed_log_expected = function () {\n  return suppress !== 0;\n};\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/meteor/string_utils.js                                                                                     //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n// Like Perl's quotemeta: quotes all regexp metacharacters.\n// Code taken from\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions\nMeteor._escapeRegExp = function (string) {\n    return String(string).replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n};\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/meteor/test_environment.js                                                                                 //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n\n\nvar TEST_METADATA_STR;\nif (Meteor.isClient) {\n  TEST_METADATA_STR = meteorEnv.TEST_METADATA;\n} else {\n  TEST_METADATA_STR = process.env.TEST_METADATA;\n}\n\nvar TEST_METADATA = JSON.parse(TEST_METADATA_STR || \"{}\");\nvar testDriverPackageName = TEST_METADATA.driverPackage;\n\n// Note that if we are in test-packages mode neither of these will be set,\n// but we will have a test driver package\n/** \n *@memberof Meteor\n * @summary Boolean variable. True when running unit tests (false if running\n * tests in full app mode).\n * @locus Anywhere\n * @static\n * @type {Boolean}\n */\nMeteor.isTest = !!TEST_METADATA.isTest;\n\n/** \n *@memberof Meteor\n * @summary Boolean variable.  True if running tests against your application i.e `meteor test --full-app`.\n * @locus Anywhere\n * @static\n * @type {Boolean}\n */\nMeteor.isAppTest = !!TEST_METADATA.isAppTest;\n\n/** \n *@memberof Meteor\n * @summary Boolean variable.  True if running tests against a Meteor package.\n * @locus Anywhere\n * @static\n * @type {Boolean}\n */\nMeteor.isPackageTest = !!testDriverPackageName && !Meteor.isTest && !Meteor.isAppTest; \n\nif (typeof testDriverPackageName === \"string\") {\n  Meteor.startup(function() {\n    var testDriverPackage = Package[testDriverPackageName];\n    if (! testDriverPackage) {\n      throw new Error(\"Can't find test driver package: \" + testDriverPackageName);\n    }\n\n    // On the client, the test driver *must* define `runTests`\n    if (Meteor.isClient) {\n      if (typeof testDriverPackage.runTests !== \"function\") {\n        throw new Error(\"Test driver package \" + testDriverPackageName\n          + \" missing `runTests` export\");\n      }\n      testDriverPackage.runTests();\n    } else {\n      // The server can optionally define `start`\n      if (typeof testDriverPackage.start === \"function\") {\n        testDriverPackage.start();\n      }\n    }\n  });\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/meteor/dynamics_nodejs.js                                                                                  //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n// Implementation of dynamic scoping, for use on the server with AsyncLocalStorage\nlet nextSlot = 0;\nlet callAsyncMethodRunning = false;\n\nconst CURRENT_VALUE_KEY_NAME = \"currentValue\";\nconst UPPER_CALL_DYNAMICS_KEY_NAME = \"upperCallDynamics\";\n\nconst SLOT_CALL_KEY = \"slotCall\";\n/**\n * @memberOf Meteor\n * @summary Constructor for EnvironmentVariable\n * @locus Anywhere\n * @class\n */\nclass EnvironmentVariableAsync {\n  constructor() {\n    this.slot = nextSlot++;\n  }\n\n  /**\n   * @memberOf Meteor.EnvironmentVariable\n   * @summary Getter for the current value of the variable, or `undefined` if\n   * called from outside a `withValue` callback.\n   * @method get\n   * @locus Anywhere\n   * @returns {any} The current value of the variable, or `undefined` if no\n   */\n  get() {\n    if (this.slot !== Meteor._getValueFromAslStore(SLOT_CALL_KEY)) {\n      const dynamics = Meteor._getValueFromAslStore(UPPER_CALL_DYNAMICS_KEY_NAME) || {};\n\n      return dynamics[this.slot];\n    }\n    return Meteor._getValueFromAslStore(CURRENT_VALUE_KEY_NAME);\n  }\n\n  getOrNullIfOutsideFiber() {\n    return this.get();\n  }\n\n  /**\n   * @summary takes a value and a function, calls the function with the value set for the duration of the call\n   * @memberof Meteor.EnvironmentVariable\n   * @method withValue\n   * @param {any} value The value to set for the duration of the function call\n   * @param {Function} func The function to call with the new value of the\n   * @param {Object} [options] Optional additional properties for adding in [asl](https://nodejs.org/api/async_context.html#class-asynclocalstorage)\n   * @returns {Promise<any>} The return value of the function\n   */\n  withValue(value, func, options = {}) {\n    const self = this;\n    const slotCall = self.slot;\n    const dynamics = Object.assign(\n      {},\n      Meteor._getValueFromAslStore(UPPER_CALL_DYNAMICS_KEY_NAME) || {}\n    );\n\n    if (slotCall != null) {\n      dynamics[slotCall] = value;\n    }\n\n    return Meteor._runAsync(\n      function () {\n        Meteor._updateAslStore(CURRENT_VALUE_KEY_NAME, value);\n        Meteor._updateAslStore(UPPER_CALL_DYNAMICS_KEY_NAME, dynamics);\n        return func();\n      },\n      self,\n      Object.assign(\n        {\n          callId: `${this.slot}-${Math.random()}`,\n          [SLOT_CALL_KEY]: this.slot,\n        },\n        options,\n      ),\n    );\n  }\n\n  _set(context) {\n    const _meteor_dynamics =\n      Meteor._getValueFromAslStore(\"_meteor_dynamics\") || [];\n    _meteor_dynamics[this.slot] = context;\n  }\n\n  _setNewContextAndGetCurrent(value) {\n    let _meteor_dynamics = Meteor._getValueFromAslStore(\"_meteor_dynamics\");\n    if (!_meteor_dynamics) {\n      _meteor_dynamics = [];\n    }\n\n    const saved = _meteor_dynamics[this.slot];\n    this._set(value);\n    return saved;\n  }\n\n  _isCallAsyncMethodRunning() {\n    return callAsyncMethodRunning;\n  }\n\n  _setCallAsyncMethodRunning(value) {\n    callAsyncMethodRunning = value;\n  }\n}\n\n/**\n * @memberOf Meteor\n * @summary Constructor for EnvironmentVariable\n * @locus Anywhere\n * @class\n */\nMeteor.EnvironmentVariable = EnvironmentVariableAsync;\n\n// Meteor application code is always supposed to be run inside a\n// fiber. bindEnvironment ensures that the function it wraps is run from\n// inside a fiber and ensures it sees the values of Meteor environment\n// variables that are set at the time bindEnvironment is called.\n//\n// If an environment-bound function is called from outside a fiber (eg, from\n// an asynchronous callback from a non-Meteor library such as MongoDB), it'll\n// kick off a new fiber to execute the function, and returns undefined as soon\n// as that fiber returns or yields (and func's return value is ignored).\n//\n// If it's called inside a fiber, it works normally (the\n// return value of the function will be passed through, and no new\n// fiber will be created.)\n//\n// `onException` should be a function or a string.  When it is a\n// function, it is called as a callback when the bound function raises\n// an exception.  If it is a string, it should be a description of the\n// callback, and when an exception is raised a debug message will be\n// printed with the description.\n/**\n * @summary Stores the current Meteor environment variables, and wraps the\n * function to run with the environment variables restored. On the server, the\n * function is wrapped within Async Local Storage.\n *\n *  This function has two reasons:\n *  1. Return the function to be executed on the MeteorJS context, having it assigned in Async Local Storage.\n *  2. Better error handling, the error message will be more clear.\n * @locus Anywhere\n * @memberOf Meteor\n * @param {Function} func Function that is wrapped\n * @param {Function} onException\n * @param {Object} _this Optional `this` object against which the original function will be invoked\n * @return {Function} The wrapped function\n */\nMeteor.bindEnvironment = (func, onException, _this) => {\n  const dynamics = Meteor._getValueFromAslStore(CURRENT_VALUE_KEY_NAME);\n  const currentSlot = Meteor._getValueFromAslStore(SLOT_CALL_KEY);\n\n  if (!onException || typeof onException === \"string\") {\n    var description = onException || \"callback of async function\";\n    onException = function (error) {\n      Meteor._debug(\"Exception in \" + description + \":\", error);\n    };\n  } else if (typeof onException !== \"function\") {\n    throw new Error(\n      \"onException argument must be a function, string or undefined for Meteor.bindEnvironment().\"\n    );\n  }\n\n  return function (/* arguments */) {\n    var args = Array.prototype.slice.call(arguments);\n\n    var runWithEnvironment = function () {\n      return Meteor._runAsync(\n        () => {\n          let ret;\n          try {\n            if (currentSlot) {\n              Meteor._updateAslStore(CURRENT_VALUE_KEY_NAME, dynamics);\n            }\n            ret = func.apply(_this, args);\n\n            // Using this strategy to be consistent between client and server and stop always returning a promise from the server\n            if (Meteor._isPromise(ret)) {\n              ret = ret.catch(onException);\n            }\n          } catch (e) {\n            onException(e);\n          }\n          return ret;\n        },\n        _this,\n        {\n          callId: `bindEnvironment-${Math.random()}`,\n          [SLOT_CALL_KEY]: currentSlot,\n        }\n      );\n    };\n\n    if (Meteor._getAslStore()) {\n      return runWithEnvironment();\n    }\n\n    return Meteor._getAsl().run({}, runWithEnvironment);\n  };\n};\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/meteor/url_server.js                                                                                       //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nif (process.env.ROOT_URL &&\n    typeof __meteor_runtime_config__ === \"object\") {\n  __meteor_runtime_config__.ROOT_URL = process.env.ROOT_URL;\n  if (__meteor_runtime_config__.ROOT_URL) {\n    var parsedUrl = Npm.require('url').parse(__meteor_runtime_config__.ROOT_URL);\n    // Sometimes users try to pass, eg, ROOT_URL=mydomain.com.\n    if (!parsedUrl.host || ['http:', 'https:'].indexOf(parsedUrl.protocol) === -1) {\n      throw Error(\"$ROOT_URL, if specified, must be an URL\");\n    }\n    var pathPrefix = parsedUrl.pathname;\n    if (pathPrefix.slice(-1) === '/') {\n      // remove trailing slash (or turn \"/\" into \"\")\n      pathPrefix = pathPrefix.slice(0, -1);\n    }\n    __meteor_runtime_config__.ROOT_URL_PATH_PREFIX = pathPrefix;\n  } else {\n    __meteor_runtime_config__.ROOT_URL_PATH_PREFIX = \"\";\n  }\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/meteor/url_common.js                                                                                       //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n/**\n * @summary Generate an absolute URL pointing to the application. The server reads from the `ROOT_URL` environment variable to determine where it is running. This is taken care of automatically for apps deployed to Galaxy, but must be provided when using `meteor build`.\n * @locus Anywhere\n * @param {String} [path] A path to append to the root URL. Do not include a leading \"`/`\".\n * @param {Object} [options]\n * @param {Boolean} options.secure Create an HTTPS URL.\n * @param {Boolean} options.replaceLocalhost Replace localhost with 127.0.0.1. Useful for services that don't recognize localhost as a domain name.\n * @param {String} options.rootUrl Override the default ROOT_URL from the server environment. For example: \"`http://foo.example.com`\"\n */\nMeteor.absoluteUrl = function (path, options) {\n  // path is optional\n  if (!options && typeof path === 'object') {\n    options = path;\n    path = undefined;\n  }\n  // merge options with defaults\n  options = Object.assign({}, Meteor.absoluteUrl.defaultOptions, options || {});\n\n  var url = options.rootUrl;\n  if (!url)\n    throw new Error(\"Must pass options.rootUrl or set ROOT_URL in the server environment\");\n\n  if (!/^http[s]?:\\/\\//i.test(url)) // url starts with 'http://' or 'https://'\n    url = 'http://' + url; // we will later fix to https if options.secure is set\n\n  if (! url.endsWith(\"/\")) {\n    url += \"/\";\n  }\n\n  if (path) {\n    // join url and path with a / separator\n    while (path.startsWith(\"/\")) {\n      path = path.slice(1);\n    }\n    url += path;\n  }\n\n  // turn http to https if secure option is set, and we're not talking\n  // to localhost.\n  if (options.secure &&\n      /^http:/.test(url) && // url starts with 'http:'\n      !/http:\\/\\/localhost[:\\/]/.test(url) && // doesn't match localhost\n      !/http:\\/\\/127\\.0\\.0\\.1[:\\/]/.test(url)) // or 127.0.0.1\n    url = url.replace(/^http:/, 'https:');\n\n  if (options.replaceLocalhost)\n  {\n    url = url.replace( /^http:\\/\\/localhost([:\\/].*)/, 'http://127.0.0.1$1');\n  }\n  return url;\n};\n\n// allow later packages to override default options\nvar defaultOptions = Meteor.absoluteUrl.defaultOptions = {};\n\n// available only in a browser environment\nvar location = typeof window === \"object\" && window.location;\n\nif (typeof __meteor_runtime_config__ === \"object\" &&\n    __meteor_runtime_config__.ROOT_URL) {\n  defaultOptions.rootUrl = __meteor_runtime_config__.ROOT_URL;\n} else if (location &&\n           location.protocol &&\n           location.host) {\n  defaultOptions.rootUrl = location.protocol + \"//\" + location.host;\n}\n\n// Make absolute URLs use HTTPS by default if the current window.location\n// uses HTTPS. Since this is just a default, it can be overridden by\n// passing { secure: false } if necessary.\nif (location &&\n    location.protocol === \"https:\") {\n  defaultOptions.secure = true;\n}\n\nMeteor._relativeToSiteRootUrl = function (link) {\n  if (typeof __meteor_runtime_config__ === \"object\" &&\n      link.substr(0, 1) === \"/\")\n    link = (__meteor_runtime_config__.ROOT_URL_PATH_PREFIX || \"\") + link;\n  return link;\n};\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/meteor/flush-buffers-on-exit-in-windows.js                                                                 //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nif (process.platform === \"win32\") {\n  /*\n   * Based on https://github.com/cowboy/node-exit\n   *\n   * Copyright (c) 2013 \"Cowboy\" Ben Alman\n   * Licensed under the MIT license.\n   */\n  var origProcessExit = process.exit.bind(process);\n  process.exit = function (exitCode) {\n    var streams = [process.stdout, process.stderr];\n    var drainCount = 0;\n    // Actually exit if all streams are drained.\n    function tryToExit() {\n      if (drainCount === streams.length) {\n        origProcessExit(exitCode);\n      }\n    }\n    streams.forEach(function(stream) {\n      // Count drained streams now, but monitor non-drained streams.\n      if (stream.bufferSize === 0) {\n        drainCount++;\n      } else {\n        stream.write('', 'utf-8', function() {\n          drainCount++;\n          tryToExit();\n        });\n      }\n      // Prevent further writing.\n      stream.write = function() {};\n    });\n    // If all streams were already drained, exit now.\n    tryToExit();\n    // In Windows, when run as a Node.js child process, a script utilizing\n    // this library might just exit with a 0 exit code, regardless. This code,\n    // despite the fact that it looks a bit crazy, appears to fix that.\n    process.on('exit', function() {\n      origProcessExit(exitCode);\n    });\n  };\n}\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/meteor/emitter-promise.js                                                                                  //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nconst { EventEmitter } = Npm.require('events');\n\nconst DEFAULT_TIMEOUT =\n  Meteor.settings && Meteor.settings.EMITTER_PROMISE_DEFAULT_TIMEOUT || 3000;\n\n/**\n *\n * @param emitter { EventEmitter } - EventEmitter used to trigger events emitter.emit(\"data\", OBJ) or emitter.emit(\"error\", ERROR_OBJ).\n * @param timeout { Number } - Timout em ms to wait for events. Default 3000ms.\n * @param onSuccess {function(data)} - Function called on succeceful receive data.\n * @param onError {function(err)} - Function called when error or timeout occur.\n * @returns {{promise: Promise<unknown>, emitter: EventEmitter}}\n */\nconst newPromiseResolver = ({\n  emitter = new EventEmitter(),\n  timeout = DEFAULT_TIMEOUT,\n  onSuccess,\n  onError,\n} = {}) => {\n  const promise = new Promise((resolve, reject) => {\n    const handler = setTimeout(() => {\n      emitter.emit(\n        'error',\n        new Meteor.Error(`EmitterPromise timeout: ${timeout}ms.`)\n      );\n    }, timeout);\n    emitter.once('data', (data) => {\n      clearTimeout(handler);\n      emitter.removeAllListeners();\n      resolve(data);\n      if (onSuccess) {\n        onSuccess(data);\n      }\n    });\n    emitter.once('error', (err) => {\n      clearTimeout(handler);\n      emitter.removeAllListeners();\n      reject(err);\n      if (onError) {\n        onError(err);\n      }\n    });\n  });\n  return {\n    emitter,\n    promise,\n  };\n};\n\nEmitterPromise = {\n  newPromiseResolver,\n};\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n/* Exports */\nreturn {\n  export: function () { return {\n      Meteor: Meteor,\n      global: global,\n      meteorEnv: meteorEnv,\n      EmitterPromise: EmitterPromise\n    };}\n}});\n","servePath":"/packages/meteor.js"}]