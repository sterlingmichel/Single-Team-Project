[{"type":"js","data":"//////////////////////////////////////////////////////////////////////////\n//                                                                      //\n// This is a generated file. You can view the original                  //\n// source in your browser if your browser supports source maps.         //\n// Source maps are supported by all recent versions of Chrome, Safari,  //\n// and Firefox, and by Internet Explorer 11.                            //\n//                                                                      //\n//////////////////////////////////////////////////////////////////////////\n\n\n(function() {\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                             //\n// packages/core-runtime/package-registry.js                                                                   //\n//                                                                                                             //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                               //\nfunction PackageRegistry() {\n  this._promiseInfoMap = Object.create(null);\n}\n\nvar PRp = PackageRegistry.prototype;\n\n// Set global.Package[name] = pkg || {}. If additional arguments are\n// supplied, their keys will be copied into pkg if not already present.\n// This method is defined on the prototype of global.Package so that it\n// will not be included in Object.keys(Package).\nPRp._define = function definePackage(name, pkg) {\n  pkg = pkg || {};\n\n  var argc = arguments.length;\n  for (var i = 2; i < argc; ++i) {\n    var arg = arguments[i];\n    for (var s in arg) {\n      if (! (s in pkg)) {\n        pkg[s] = arg[s];\n      }\n    }\n  }\n\n  this[name] = pkg;\n\n  var info = this._promiseInfoMap[name];\n  if (info) {\n    info.resolve(pkg);\n  }\n\n  return pkg;\n};\n\nPRp._has = function has(name) {\n  return Object.prototype.hasOwnProperty.call(this, name);\n};\n\n// Returns a Promise that will resolve to the exports of the named\n// package, or be rejected if the package is not installed.\nPRp._promise = function promise(name) {\n  var self = this;\n  var info = self._promiseInfoMap[name];\n\n  if (! info) {\n    info = self._promiseInfoMap[name] = {};\n    info.promise = new Promise(function (resolve, reject) {\n      info.resolve = resolve;\n      if (self._has(name)) {\n        resolve(self[name]);\n      } else {\n        Meteor.startup(function () {\n          if (! self._has(name)) {\n            reject(new Error(\"Package \" + name + \" not installed\"));\n          }\n        });\n      }\n    });\n  }\n\n  return info.promise;\n};\n\n// Initialize the Package namespace used by all Meteor packages.\nvar global = this;\nglobal.Package = new PackageRegistry();\n\nif (typeof exports === \"object\") {\n  // This code is also used by meteor/tools/isobuild/bundler.js.\n  exports.PackageRegistry = PackageRegistry;\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                             //\n// packages/core-runtime/load-js-image.js                                                                      //\n//                                                                                                             //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                               //\n// This file needs to work in old web browsers and old node versions\n// It should not use js features newer than EcmaScript 5.\n//\n// Handles loading linked code for packages and apps\n// Ensures packages and eager requires run in the correct order\n// when there is code that uses top level await\n\nvar hasOwn = Object.prototype.hasOwnProperty;\n\nvar pending = [];\nfunction queue(name, runImage) {\n  pending.push({name: name, runImage: runImage});\n  processNext();\n}\n\nvar isProcessing = false;\nfunction processNext() {\n  if (isProcessing) {\n    return;\n  }\n\n  var next = pending.shift();\n  if (!next) {\n    return;\n  }\n\n  isProcessing = true;\n\n  var config = next.runImage.call(this);\n  runEagerModules(config, function (mainModuleExports) {\n    // Get the exports after the eager code has been run\n    var exports = config.export ? config.export() : {};\n    if (config.mainModulePath) {\n      Package._define(next.name, mainModuleExports, exports);\n    } else {\n      Package._define(next.name, exports);\n    }\n\n    isProcessing = false;\n    processNext();\n  });\n}\n\nfunction runEagerModules(config, callback) {\n  if (!config.eagerModulePaths) {\n    return callback();\n  }\n\n  var index = -1;\n  var mainExports = {};\n  var mainModuleAsync = false;\n\n  function evaluateNextModule() {\n    index += 1;\n    if (index === config.eagerModulePaths.length) {\n      if (mainModuleAsync) {\n        // Now that the package has loaded, mark the main module as sync\n        // This allows other packages and the app to `require` the package\n        // and for it to work the same, regardless of if it uses TLA or not\n        // XXX: this is a temporary hack until we find a better way to do this\n        const reify = config.require('/node_modules/meteor/modules/node_modules/@meteorjs/reify/lib/runtime');\n        reify._requireAsSync(config.mainModulePath);\n      }\n\n      return callback(mainExports);\n    }\n\n    var path = config.eagerModulePaths[index];\n    var exports = config.require(path);\n    if (checkAsyncModule(exports)) {\n      if (path === config.mainModulePath) {\n        mainModuleAsync = true;\n      }\n\n      // Is an async module\n      exports.then(function (exports) {\n        if (path === config.mainModulePath) {\n          mainExports = exports;\n        }\n        evaluateNextModule();\n      })\n      // This also handles errors in modules and packages loaded sync\n      // afterwards since they are run within the `.then`.\n      .catch(function (error) {\n        if (\n          typeof process === 'object' &&\n          typeof process.nextTick === 'function'\n        ) {\n          // Is node.js\n          process.nextTick(function () {\n            throw error;\n          });\n        } else {\n          // TODO: is there a faster way to throw the error?\n          setTimeout(function () {\n            throw error;\n          }, 0);\n        }\n      });\n    } else {\n      if (path === config.mainModulePath) {\n        mainExports = exports;\n      }\n      evaluateNextModule();\n    }\n  }\n\n  evaluateNextModule();\n}\n\nfunction checkAsyncModule (exports) {\n  var potentiallyAsync = exports && typeof exports === 'object' &&\n    hasOwn.call(exports, '__reifyAsyncModule');\n\n  if (!potentiallyAsync) {\n    return;\n  }\n\n  return typeof exports.then === 'function';\n}\n\n// For this to be accurate, all linked files must be queued before calling this\n// If all are loaded, returns null. Otherwise, returns a promise\nfunction waitUntilAllLoaded() {\n  if (pending.length === 0 && !isProcessing) {\n    // All packages are loaded\n    // If there were no async packages, then there might not be a promise\n    // polyfill loaded either, so we don't create a promise to return\n    return null;\n  }\n\n  return new Promise(function (resolve) {\n    queue(null, function () {\n      resolve();\n      return {};\n    });\n  });\n}\n\n// Since the package.js doesn't export load or waitUntilReady\n// these will never be globals in packages or apps that depend on core-runtime\nPackage['core-runtime'] = {\n  queue: queue,\n  waitUntilAllLoaded: waitUntilAllLoaded\n};\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n})();\n","servePath":"/packages/core-runtime.js"}]